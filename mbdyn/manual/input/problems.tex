% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2009
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Problems}\label{sec:PROBLEMS}
This section is used to insert all the data related to the problem that
one needs MBDyn to solve in the simulation.
The section data is included between the cards:
\begin{verbatim}
    begin : <problem_name> ;
        ...
    end : <problem_name> ;
\end{verbatim}

Implemented problems are:
\begin{itemize}
\item \kw{initial value}, the time integration of mechanical
and multidisciplinary problems formulated
as Differential-Algenraic Equations (DAE).
It can be downgraded to the solution of static and kinemtic problems,
by selecting purely static or kinematic contributions
to the governing equations, thus giving time the role
of an ordinal parameter.

\item \kw{inverse dynamics}, the computation of the generalized forces
required to make a generic system perform a given trajectory.
This problem currently under development, so it is not deiscussed
in detail.

\end{itemize}





\section{Initial-Value Problem}
\label{sec:IVP}
At present, the main problem is \kw{initial value},
which solves initial value problems
by means of generic integration schemes that can be casted
in a broad family of multistep and, experimentally,
Implicit Runge-Kutta-like schemes
\cite{MASARATI-LANZ-MANTEGAZZA-2001}.

The syntax of the module is:
\begin{verbatim}
    begin: initial value;
        ...
    end: initial value;
\end{verbatim}
At present, there are a number of cards that can be grouped as follows, 
based on the integration phase they refer to.

\subsection{General Data}
those data that refer to the main integration phase or the simulation as a
whole. They are:

\subsubsection{Initial Time}
\begin{verbatim}
    <card> ::= initial time : <time> ;
\end{verbatim}

\subsubsection{Final Time}
\begin{verbatim}
    <card> ::= final time : {forever | <time>} ;
\end{verbatim}

\subsubsection{Strategy}
\begin{verbatim}
    <card> ::= strategy : <strategy_data> ;
\end{verbatim}
where the available strategies are:
\begin{verbatim}
    <strategy_data> ::= no change 
\end{verbatim}
obviously the step is never changed;
\begin{verbatim}
    <strategy_data> ::= factor , 
                        <reduction_factor> ,
                        <steps_before_reduction> ,
                        <raise_factor> ,
                        <steps_before_raise> ,
                        <min_iterations>
			[ , <max_iteration> ]
\end{verbatim}
the time step is reduced or raised of the proper factor not before a
minimum number of time steps; it is reduced if more than 
\kw{max\_iterations} are performed at a time step, or it the current
step do not converge; it is raised if less
than \kw{min\_iterations} are performed at a time step;
\kw{max\_iterations} defaults to the global \kw{max\_iterations}
simulation value; however, it is better to set it to a lower value,
leaving some spare iterations before bailing out the simulation; 
the simulation bails out if two consecutive solution steps
are performed without converging.
\begin{verbatim}
    <strategy_data> ::= change , 
                        (drive_caller) <time_step_change>
\end{verbatim}
the time step is change according to the \kw{time\_step\_change} law.

\subsubsection{Min Time Step}
\begin{verbatim}
    <card> ::= min time step : <time_step> ;
\end{verbatim}

\subsubsection{Max Time Step}
\begin{verbatim}
    <card> ::= max time step : { <time_step> | unlimited } ;
\end{verbatim}
both are significant only if the time step can vary.

\subsubsection{Time Step}
\begin{verbatim}
    <card> ::= time step : <time_step> ;
\end{verbatim}
The initial time step.

\subsubsection{Tolerance}
\begin{verbatim}
    <card> ::= tolerance : { null | <residual_tolerance> }
            [ , test , { none | norm | minmax } [ , scale ] ]
        [ , { null | <solution_tolerance> } 
            [ , test , { none | norm | minmax } ] ] ;
\end{verbatim}
The only mandatory value is \kw{residual\_tolerance}, 
the tolerance used for the residual test; the keyword \kw{null}
disables the residual testing, disabling the computation
of the test on the residual.
The \kw{test} mechanism is used to select what kind of test must
be performed; currently, only \kw{norm} (the default) 
and \kw{minmax} are supported.
The special value \kw{none} means that the test is not actually 
computed; it is the default when the test is disabled by setting
the tolerance to zero, or by using the keyword \kw{null};
however, it can be restored to any mechanism for output purposes.
The optional parameter \kw{scale} is used to enable the scaling
of the residual before performing the test; default scale factors 
can be set for each type of degree of freedom owner, and some
entities allow individual scaling; by default, no scaling takes place.
A tolerance \kw{solution\_tolerance} to test the solution 
(the difference between the states at two iterations) is allowed, 
and also in this case a test mechanism can be chosen;
by default, no test on the solution convergence is done.
Currently, no scaling is allowed in the solution test.

\noindent
Examples:
\begin{verbatim}
    # residual test by means of the norm
    tolerance: 1.e-6;
    # residual test with minmax method
    tolerance: 1.e-6, test, minmax;
    # residual test with norm method and scaling
    tolerance: 1.e-6, test, norm, scale;
    # solution test
    tolerance: null, 1.e-9;
    # residual and solution test
    # (the first that succeeds breaks the loop)
    tolerance: 1.e-6, 1.e-9;
    # residual test with computation of solution norm
    tolerance: 1.e-6, null, test, norm;
\end{verbatim}

\subsubsection{Max Iterations}
\begin{verbatim}
    <card> ::= max iterations : <max_iterations> ;
\end{verbatim}

\subsubsection{Modify Residual Test}
\begin{verbatim}
    <card> ::= modify residual test;
\end{verbatim}
modify the residual test taking in account the rate of change of the status.

\subsubsection{Method}
\begin{verbatim}
    <card> ::= method : <method_data> ;
\end{verbatim}
there are four multistep methods at present. 
The first is Crank-Nicolson:
\begin{verbatim}
    <method_data> ::= crank nicolson
\end{verbatim}
the second and the third are original 
methods; the former is discussed in \cite{MASARATI-LANZ-MANTEGAZZA-2001},
see also
\begin{quote}
\htmladdnormallink{\kw{http://www.aero.polimi.it/\~{}mbdyn/publications.html}}{http://www.aero.polimi.it/~mbdyn/publications.html}
\end{quote} 
Those methods are unconditionally stable and can be tuned to give 
the desired algorithmic dissipation
by setting the value of the asymptotic spectral radius.
The radius can be set independently for the differential
and the algebraic variables, and a driver is used, to allow parameter 
dependent radius variation.
\begin{verbatim}
    <method_data> ::= { ms | hope } ,
        (drive_caller) <differential_radius>
        [ , (drive_caller) <algebraic_radius> ]
\end{verbatim}
The first method proved to be more accurate at high values of asymptotic
radius (low dissipation), while the second proved to be more accurate
at low values of the radius (high dissipation).
They look nearly equivalent at radii close to 0.4, with the former
giving the best compromise between algorithmic dissipation and accuracy 
at about 0.6.
The algebraic radius can be omitted, defaulting to the same 
as the differential one.
It is unclear whether a different spectral radius can help in increasing
accuracy or dissipation of the algebraic unknowns.
The fourth method is experimental. It is a third-order,
two stage unconditionally stable method, which can be tuned to give 
the desired algorithmic dissipation by setting the value 
of the asymptotic spectral radius, which should not be 
too close to zero.
Currently it is not possible to independently set the radius 
for the differential and the algebraic variables.
\begin{verbatim}
    <method_data> ::= third order ,
        { ad hoc | (drive_caller) <differential_radius> }
\end{verbatim}
When the keyword \kw{ad hoc} is used, a method equivalent
to a Runge Kutta Radau IIA results, with zero asymptotic
spectral radius; otherwise, an original third-order
integration method is used, with tunable algorithmic dissipation.

\noindent
The multistep method, when the asymptotic radius is zero, degenerates
in the Backward Differentiation Formulas of order two.
A shortcut to this case is provided as
\begin{verbatim}
    <method_data> ::= bdf [ , order , <order> ]
\end{verbatim}
The keyword \kw{order} can be used to indicate a specific order
of the BDF formulas; only first order (implicit Euler) and 
second order formulas are currently implemented, and the default
is the second order formula, which is the most useful.
The first order formula may be of help for very specific problems.
It can also be selected using the shortcut
\begin{verbatim}
    <method_data> ::= implicit euler
\end{verbatim}

\subsubsection{Nonlinear Solver}
The nonlinear solver solves a nonlinear problem $F(x)=0$.
Two nonlinear solvers are currently available:
a Newton-Raphson iterator and a matrix-free solver.
The first nonlinear solver, a modified Newton-Raphson, 
is well tested.
\begin{verbatim}
    <card> ::= nonlinear solver : <nonlinear_solver_data> ;
\end{verbatim}
\begin{verbatim}
    <nonlinear_solver_data> ::= newton raphson : { 
        true | modified , <iterations>
            [ , keep jacobian matrix ]
            [ , honor element requests ] } ;
\end{verbatim}
if \kw{modified}, the number of \kw{<iterations>} the same Jacobian matrix 
will be reused, and thus factored only once, is expected.
If the option \kw{keep jacobian matrix} is selected,
the Jacobian matrix is preserved
for the desired \kw{<iterations>} even across time steps.
By default, the Jacobian matrix is recomputed at the beginning 
of each time step.
If the option \kw{honor element requests} is selected, the preconditioned
is updated also when an element changes the structure of its equations.
The default behavior is to ignore such requests\footnote{
	At present, only few elements that can change the structure
	of the equations, or at least radically change the Jacobian matrix,
	actually issue this request.
}.
The second nonlinear solver, based on a
matrix-free algorithm, is experimental.
\begin{verbatim}
    <nonlinear_solver_data> ::= matrix free, { bicgstab | gmres }
        [ , tolerance, < tolerance > ]
        [ , steps , <steps> ]
        [ , tau , <tau> ]
        [ , eta , <eta> ]
        [ , preconditioner, {
            full jacobian matrix [ , steps, <steps> ] 
	        [ , honor element requests ]
    } ];
\end{verbatim}
where \kw{<tolerance>} is the iterative linear solver tolerance;
\kw{<steps>} is the maximum number of linear solver iterations;
\kw{<tau>} is a measure of the configuration perturbation used
to obtain a matrix-free approximation of the product
of the Jacobian matrix times the solution vector;
it is seldom necessary to change the default value of this parameter,
mainly for very ``stiff'' problems.
By setting \kw{<eta>} one changes the convergence requirements; 
further reference for this parameter may be found in \cite{KELLEY-1995}; 
do not change it unless you know what you are doing.
The value \kw{<steps>} of the \kw{steps} keyword 
of the \kw{preconditioner} sub-block 
sets the maximum number of iterations that can be performed 
without requiring an update of the preconditioner; 
this parameter can heavily influence
the performance of the matrix-free solver.
If the option \kw{honor element requests} is selected, the preconditioned
is updated also when an element changes the structure of its equations.
The default behavior is to ignore such requests\footnote{See note above}.


\subsubsection{Eigenanalysis}
\label{sec:IVP:eigenanalysis}
\begin{verbatim}
    <card> ::= eigenanalysis , <when>
        [ , parameter , <param> ]
        [ , { output [ full ] matrices
            | output sparse matrices
            | output eigenvectors
            | use lapack
            | use arpack , <nev> , <ncv> , <tol> } [ , ... ] ]
\end{verbatim}
Performs the direct eigenanalysis of the problem.
This functionality is experimental.
Direct eigenanalysis based on the matrices of the system
only makes sense when the system is in a steady configuration,
so the user needs to ensure this configuration has been reached.
Moreover, not all elements currently contribute to the Jacobian
matrix of the system, so YMMV.
In case of rotating systems, a steady configuration could be reached
when the model is expressed in a relative reference frame,
using the \kw{rigid body kinematics} card
(see Section~\ref{sec:CONTROLDATA:RBK}).

\begin{itemize}
\item \kw{when} indicates at what time the eigenanalysis is performed;
\item \kw{param} is the value of the coefficient that is used to project
	the problem in the discrete time domain; it can be interpreted
	as inverse of half the largest frequency that can be computed.
	However, accuracy is lost by the projection procedure,
	so it should be much larger than the largest frequencies of interest
	by at least two orders of magnitude;
\item \kw{output full matrices} causes the output
	of the (full) problem matrices in a \kw{.m} file,
	intended to be loaded by tools like octave/matlab;
\item \kw{output sparse matrices} causes the output
	of the problem matrices in sparse form in a \kw{.m} file,
	intended to be loaded by tools like octave/matlab;
\item \kw{output eigenvectors} causes the output of the eigenvalues
	and of the eigenvectors in a \kw{.m} file,
	intended to be loaded by tools like octave/matlab;
\item \kw{use lapack} performs the eigenanalysis using
	LAPACK's \kw{dggev()} routine (generalized unsymmetric eigenanalysis
	using the QZ decomposition);
\item \kw{use arpack} performs the eigenanalysis using
	ARPACK's \kw{dnaupd()} and \kw{dneupd()} routines
	(canonical unsymmetric eigenanalysis,
	using the Implicitly Restarted Arnoldi Method, IRAM).
	It requires the additional parameters:
	\begin{itemize}
	\item \kw{nev}, the number of the desired eigenvalues;
	\item \kw{ncv}, the number of the Arnoldi vectors;
	\item \kw{tol}, the tolerance (positive; zero means machine error).
	\end{itemize}
\end{itemize}
This functionality is experimental, so the syntax could need adjustments
and change across versions.



\subsubsection{Abort After}
\label{sec:IVP:abort after}
\begin{verbatim}
    <card> ::= abort after : { input 
                             | assembly 
                             | derivatives 
                             | dummy steps } ;
\end{verbatim}
mainly used to cleanly check models and simulations at various phases.
When set to \kw{input}, the simulation ends after input is completed;
when set to \kw{assembly}, the simulation ends after initial assembly,
if required;
when set to \kw{derivatives}, the simulation ends after the computation
of the derivatives, i.e.\ after the system is solved at the initial
time to compute initial momentum and momenta moment derivatives and 
reaction forces;
when set to \kw{dummy steps}, the simulation ends after the dummy steps
execution, if required.
In any case, the output is generated with the system configured 
as resulting from the last computation phase, so this mode can be useful 
to check how the system is actually configured after phases that are not 
usually output.


\subsubsection{Linear Solver}   
\label{sec:LINEAR-SOLVER}
\begin{verbatim}
    <card> ::= linear solver :
            { naive | umfpack | y12 | lapack 
                | harwell | meschach | superlu | taucs }
        [ , { map | cc | dir } ]
        [ , { colamd | mmdata } ]
        [ , mt , <threads> ]
        [ , workspace size , <workspace_size> ] 
        [ , pivot factor , <factor> ]
        [ , block size, <block_size> ] ;
\end{verbatim}
The default, if available, is \kw{umfpack} which dynamically
allocates memory as required, so the \kw{workspace size} 
parameter, if given, is ignored.
The \kw{umfpack} linear solver honors the \kw{block size} keyword,
which refers to an internal parameter.
The default value (32) is usually good for most problems; however,
it has been observed that a lower value can slightly improve
performances on small problems (e.g.\ a rigid rotorcraft model
with some 180 degrees of freedom showed a 10\% speedup with 
a block size of 4, while a rigid robot showed eve higher speedups,
in the 30\%, with a block size between 4 and 16).
The \kw{y12} linear solver requires static allocation of the workspace;
the optimal size is between 3 and 5 times the number of nonzero 
coefficients.
By default, twice the size of the full matrix is allocated
(which sounds a bit nonsense, but is conservative enough);
then the linear solver automatically uses an optimal amount of memory
based on the results of the previous factorization; this could
result in a failure if the filling of the matrix changes 
dramatically between two factorizations.
Another linear solver, that is available mostly for historical reasons, 
is \kw{harwell}, with a \kw{workspace size}
of $ numdofs\times{numdofs} $, but in certain cases the user
might prefer a smaller workspace, since the matrix is handled as sparse,
while sometimes a larger space is required, since when the matrix is
full, a little more space is required, due to extra storage needs when
the matrix fills up.
Finally, \kw{superlu} is an experimental linear solver that is able to perform
the factorization in a multi-threaded environment.
If more than one CPU is available, it automatically uses all the CPUs;
the keyword \kw{mt} allows to enforce the desired number of threads.
See also the \kw{threads} keyword for more details on multi-threaded
solution.
The keywords \kw{map} (Sparse Map), \kw{cc} (Column Compressed)
and \kw{dir} (Direct Access) can be used to modify the way
the sparse matrix is handled:
\begin{itemize}
\item \kw{map} uses an array of binary trees to store the matrix
coefficients; right before the factorization, the matrix is transformed
in the form required by each linear solver, usually Column Compressed
(also known as Harwell-Boeing format) or Index (as used by \kw{y12}).
The matrix is regenerated each time an assembly is required.
\item \kw{cc} uses the compact format resulting from the transformation
required by the linear solver to store the coefficients in subsequent assemblies,
thus saving the time required to transform the matrix.
If the profile of the matrix changes, the compact form is invalidated,
and the matrix is reset to \kw{map} form.  As a consequence, this matrix
form allows faster access and reduced factorization cost, but in certain
cases may require an additional cost.
\item \kw{dir} uses a full index table to grant direct access time to
the actual location of each coefficient.
In principle it should be a bit faster than \kw{cc}, at the cost
of some memory waste.
However, in practical applications, the cost of these operations
is a very small fraction of the factorization time.
If the problem is quite large, the memory consumption might
become unacceptable; if the problem is quite small, the access time
of \kw{cc} is quite limited ($\log_2\plbr{\mathrm{<nz>}}$, where
\kw{<nz>} is the number of non-zeroes in a column) so it is definitely
comparable to that of \kw{cc}.
\end{itemize}
Only \kw{umfpack}, \kw{y12} and \kw{superlu} linear solvers allow these
settings.

\noindent
The keyword \kw{colamd} is honored by the \kw{naive} and SuperLU linear solvers;
it enables the column rearrangement that minimizes the sparsity
of the factored matrix, as implemented in \kw{libcolamd}
(part of \kw{umfpack} package). The keyword \kw{mmdata} is honored by 
the scalar SuperLU linear solver only; it enables column rearrangement
based on the MMD ordering ot the symmetric matrix $A^T A$.


\noindent
The \kw{pivot factor} is a real number, which in a heuristic sense 
can be regarded as the threshold for the ratio between two coefficients 
below which they are switched, so $ 0.0 $ means no pivoting, 
while $ 1.0 $ means switch as soon as the norm of the ratio 
is less than unity.

\noindent
Table~\ref{tab:linear-solvers-props} summarizes the properties that can be set
for each type of linear solver; Table~\ref{tab:linear-solvers-memory}
summarizes  the memory usage of the linear solvers;
Table~\ref{tab:linear-solvers-pivot}
summarizes how each linear solver deals with pivoting policies.

\begin{table}
\centering
\caption{Linear solvers properties}\label{tab:linear-solvers-props}
\begin{tabular}{lccccccc}
\hline\hline
	\multicolumn{1}{c}{\textbf{\emph{Solver}}} &
	\multicolumn{1}{c}{\textbf{\emph{Map}}} &
	\multicolumn{1}{c}{\textbf{\emph{Column}}} &
	\multicolumn{1}{c}{\textbf{\emph{Dir}}} &
	\multicolumn{1}{c}{\textbf{\emph{Multi-}}} &
	\multicolumn{1}{c}{\textbf{\emph{Worksp.}}} &
	\multicolumn{1}{c}{\textbf{\emph{Pivot}}} &
	\multicolumn{1}{c}{\textbf{\emph{Block}}} \\
	& & \multicolumn{1}{c}{\textbf{\emph{Compr.}}} &
	& \multicolumn{1}{c}{\textbf{\emph{Thread}}}
	& \multicolumn{1}{c}{\textbf{\emph{Size}}}
	& \multicolumn{1}{c}{\textbf{\emph{Factor}}}
	& \multicolumn{1}{c}{\textbf{\emph{Size}}} \\
\hline
	Naive		& 	&	&	&	&	& x	&	\\
	Umfpack		& x	& x	& x	&	&	& x	& x	\\
	Y12m		& x	& x	& x	&	& x	& x	&	\\
	Lapack		&	&	&	&	&	& x	&	\\
	Harwell		&	&	&	&	&	& x	&	\\
	Meschach	&	&	&	&	&	& x	&	\\
	SuperLU		& x	& x	& x	& x	&	& x	&	\\
	TAUCS		& x	& x	& x	&	&	&	&	\\
	Watson		& x	& x	& x	& x	&	& x	&	\\
\hline\hline
\end{tabular}
\end{table}

\noindent

\begin{table}
\centering
\caption{Linear solvers memory usage}\label{tab:linear-solvers-memory}
\begin{tabular}{llll}
\hline\hline
	\multicolumn{1}{c}{\textbf{\emph{Solver}}} &
	\multicolumn{1}{c}{\textbf{\emph{Workspace}}} &
	\multicolumn{1}{c}{\textbf{\emph{Memory}}} &
	\multicolumn{1}{c}{\textbf{\emph{Block Size}}} \\
	&
	&
	\multicolumn{1}{c}{\textbf{\emph{Size}}} &
	\multicolumn{1}{c}{\textbf{\emph{Allocation}}} \\
\hline
	Naive		& 			& full		&		\\
	Umfpack 	& 			& dynamic	& default=32	\\
	Y12m 		& default=$2\times{n^2}$& static	&		\\
			& $3nz \rightarrow 5nz$	&		&		\\
	Lapack		&			& full		&		\\
	Harwell		& ?			& static	&		\\
	Meschach	& 			& dynamic	&		\\
	SuperLU		& 			& dynamic 	&		\\
	TAUCS		&			& ?		&		\\
	Watson		&			& dynamic	&		\\
\hline\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Linear solvers pivot handling}\label{tab:linear-solvers-pivot}
\begin{tabular}{llll}
\hline\hline
	\multicolumn{1}{c}{\textbf{\emph{Solver}}} &
	\multicolumn{1}{c}{\textbf{\emph{Pivot}}} &
	\multicolumn{1}{c}{\textbf{\emph{Default}}} &
	\multicolumn{1}{c}{\textbf{\emph{Description}}} \\
\hline
	Naive		& 1.0$\rightarrow$0.0		& 1.e$-8$	& \\
	Umfpack 	& 0.0$\rightarrow$1.0 		& 0.1 		& \\
	Y12m 		& boolean: none=0.0, full=1.0	& full		& \\
	Lapack		& 1.0$\rightarrow$0.0		&		& \\
	Harwell		& full: 1.0			& 1.0		& \\
	Meschach	& full: 1.0			& 1.0		& \\
	SuperLU		& 0.0$\rightarrow$1.0		& 1.0		& \\
	TAUCS		&				&		& \\
	Watson		&				&		& \\
\hline\hline
\end{tabular}
\end{table}



\subsubsection{Solver}   
Deprecated; see
\hyperref{\kw{linear solver}}{\kw{linear solver} (Section~}{)}{sec:LINEAR-SOLVER}.


\subsubsection{Threads}   
\begin{verbatim}
    <card> ::= threads :
        { auto | disable | [ { assembly | solver } , ] <threads> }
\end{verbatim}
By default, if enabled at compile time, the assembly is performed
in a multi-threaded environment if more than one CPU is available 
and the selected solver allows it (e.g.\ if it supports any form 
of compressed matrix handling, \kw{cc} or \kw{dir}).
However, this behavior can be influenced by the \kw{threads} directive.
The value \kw{auto} is the default; the value \kw{disable} reverts
to the usual scalar behavior; otherwise \kw{<threads>}, the desired 
number of threads, is read.
If it is prefixed by the keyword \kw{assembly}, the desired number
of threads is used only in assembly; if it is prefixed by the keyword
\kw{solver}, the desired number of threads is used only during 
factorization/solution, if the linear solver supports it (currently,
only the \kw{superlu} solver does).
As an example, on a 4 CPU architecture, to use 2 threads for assembly
and 4 threads for solution, use
\begin{verbatim}
    threads: assembly, 2;
    solver: superlu, cc, mt, 4;
\end{verbatim}





\subsection{Derivatives Data}
Data related to the derivatives phase. They are:


\subsubsection{Derivatives Tolerance}
\begin{verbatim}
    <card> ::= derivatives tolerance : <tolerance> ;
\end{verbatim}

\subsubsection{Derivatives Max Iterations}
\begin{verbatim}
    <card> ::= derivatives max iterations : <max_iterations> ;
\end{verbatim}

\subsubsection{Derivatives Coefficient}
\begin{verbatim}
    <card> ::= derivatives coefficient : <coefficient> ;
\end{verbatim}
right after the initial assembly and before the simulation starts, the
so-called derivatives solution is performed. The system is solved with
the kinematic unknowns constrained, in order to properly determine the
dynamic unknowns, namely momenta and constraint reactions. For this
purpose, the coefficient that relates the state perturbation to the
derivative perturbation must be set to a value that is small enough to
allow the determination of accurate derivatives with very small change
in the states. This coefficient should be zero, but this leads to matrix
singularity, so it must be chosen by the user, since it is highly
problem dependent. A rule-of-thumb is: if the system has small
stiffness and high inertia, the coefficient can be big, if the system
has high stiffness and small inertia, the coefficient must be small.


\subsection{Dummy Steps Data}
Data related to the dummy steps phase. They are:

\subsubsection{Dummy Steps Tolerance}
\begin{verbatim}
    <card> ::= dummy steps tolerance : <tolerance> ;
\end{verbatim}

\subsubsection{Dummy Steps Max Iterations}
\begin{verbatim}
    <card> ::= dummy steps max iterations : <max iterations> ;
\end{verbatim}    
{\em
    Note: no step change, modified Newton-Raphson and so on is allowed
    during the dummy steps.
}

\subsubsection{Dummy Steps Number}
\begin{verbatim}
    <card> ::= dummy steps number : <number> ;
\end{verbatim}
number of dummy steps.

\subsubsection{Dummy Steps Ratio}
\begin{verbatim}
    <card> ::= dummy steps ratio : <ratio> ;
\end{verbatim}
ratio of the time step to be used in the dummy steps to the regular
time step.

\subsubsection{Dummy Steps Method}
\begin{verbatim}
    <card> ::= method : <method_data> ;
\end{verbatim}
Same as for the normal simulation method. 
The dummy steps are intended as a sort of numerical computation 
of the second order derivatives of the constraint equations. 
The displacement constraint equations in an index three 
Differential-Algebraic Equations system
(DAE) represent the second derivative effect of the constraints on the
kinematic unknowns. Thus, to ensure the proper initial conditions, the
constraint equations should be differentiated twice. To simplify the code,
those equations have been differentiated once only, in the initial assembly,
the second derivation being performed numerically by the dummy steps.
During these steps the system converges to a solution whose error from
the sought solution is bounded. For this reason, the dummy steps
should be performed with a very short time step, to seek accuracy, and
with a high numerical damping, to cancel as quickly as possible the high
frequency numerical noise.

\subsection{Output Data}\label{sec:PROBLEMS:OUTPUT}
Model output, e.g.\ nodes and elements output, is handled
by the data manager; the integrator only deals with
simulation-related output, and takes care of some debug output.

\subsubsection{Output}
This command requests special output related to the solution phase.
\begin{verbatim}
    <card> ::= output : <item> [ , <item> [ , ... ] ] ;
    <item> ::= { iterations
               | residual
               | solution
               | jacobian matrix
               | messages
               | none }
\end{verbatim}
The item \kw{iterations} logs a detailed output of the error
at each iteration inside a time step 
% in the \kw{.out} file.
on the standard output.
The items \kw{residual}, \kw{solution} and \kw{jacobian matrix} log
the residual, the solution and the Jacobian matrix to standard output;
they are currently available only for the umfpack solver, and they are
mainly intended for last resort debugging purposes.
The item \kw{messages} refers to all messaging 
on the \kw{.out} file; by default, it is on.
The special item \kw{none} clears the output flags; the items
are additive, so, for instance, to clear out the default 
and add the iterations output, use:
\begin{verbatim}
    output: none, iterations;
\end{verbatim}



\subsection{Real-Time Execution}\label{sec:REAL-TIME}
\emph{Initially implemented by Michele Attolico} \\
\emph{Extensively reworked by Pierangelo Masarati}

\noindent
This statement forces MBDyn to be scheduled in real-time,
based on the capabilities of the underlying OS.
\begin{verbatim}
    <card> ::= real time : [ { RTAI | POSIX } , ]
        <mode>
        [ , reserve stack , <stack-size> ]
        [ , allow nonroot ]
        [ , cpu map , <cpu-map> ]
        [ , output , { yes | no } ]
        [ , hard real time ]
        [ , real time log [ , file name , <command-name> ] ]
    <mode> ::= {
        [ mode , period , ] time step , <time_step>
        | mode , semaphore [ , <semaphore_args> ]
        | mode , IO
    }
\end{verbatim}
where:
\begin{itemize}
\item the optional \kw{RTAI} or \kw{POSIX} keywords indicate whether
RTAI (Lunx Real-Time Application Interface, \kw{http://www.rtai.org/})
or POSIX should be used to schedule the execution of MBDyn in real-time
(defaults to \kw{RTAI});

\item when the keyword \kw{mode} is set to \kw{period}, the execution
is scheduled periodically; when set to \kw{semaphore}, it waits 
for an external trigger to start a new step;
when set to \kw{IO}, it assumes synchronization is provided
by waiting on blocking I/O streams
(note: \kw{semaphore} is not implemented yet,
so \kw{semaphore\_args} 
is currently undefined; default is \kw{period});

\item the \kw{time\_step}, required when the scheduling is \kw{periodic},
is the sample rate in nanoseconds (ns); 
usually, it matches the time step of the simulation,
but it can be different for other purposes;

\item \kw{allow nonroot} means that the program should be allowed to run
as a regular (non-root) user while performing hard real-time operations
with the underlying OS (by default, only the superuser is allowed
to execute in real-time, since this requires the process to acquire
the highest priority; only honored by \kw{RTAI});

\item the keyword \kw{reserve stack} instructs the program 
to statically reserve the desired stack size by means 
of the \kw{mlockall(2)} system call; it should be used to ensure 
that no page swapping occurs during the real-time simulation;
a minimal default value (1024 bytes) is set in any case;

\item the keyword \kw{cpu map} allows the program to force its
execution on a specific subset of CPUs on multiprocessor hardware;
the syntax of the \kw{<cpu-map>} field is a byte-sized integer 
(between 0 and 255) whose active bits are the desired CPUs (up to 8);

\item the keyword \kw{output} determines whether output is entirely disabled
or not; this option is only available to \kw{POSIX} real-time,
and should always be set to \kw{no} in order to disable any output,
so that I/O only occurs for the purpose of interprocess communication;

\item the keyword \kw{hard real time} instructs the program to run
in hard real-time; the default is soft real-time
(RTAI only; by default scheduling is in soft real-time);

\item the keyword \kw{real time log} enables logging by means 
of RTAI mailboxes; an optional \kw{filename} argument allows 
to set the name of the logging process that is used.
It should be a low priority soft real-time process that communicates
with the simulator by means of the RTAI mailbox called \kw{logmb}.
The log process mailbox may receive a sequence of message consisting
in two integers: the time step number and the amount of nanoseconds
that time step overrun the scheduling period.

Note: if no \kw{<command-name>} is given, to guarantee the detection 
of the default log command the process \kw{PATH} environment variable 
is augmented by prepending ``\kw{.:BINPATH}''; by default,
\kw{BINPATH} is the \verb;${bindir}; directory of the build environment,
so it can be set by using the \verb;--bindir; configure switch.
\end{itemize}
The keywords must be given in the sequence reported above.
Real-time simulation is mostly useless without interaction 
with external programs.
The input is dealt with by the stream file drivers described
in Sections~\ref{sec:RTAI_in} and~\ref{sec:Stream}.
The output is dealt with by the stream output
elements described in Sections~\ref{sec:EL:OUTELEM:RTAI_out},
\ref{sec:EL:OUTELEM:STREAM_OUTPUT}
and~\ref{sec:EL:OUTELEM:STREAM_MOTION_OUTPUT}.

\section{Other Problems}
Other types of problems are either possible or being developed.
Typically, static problems can be obtained in terms of a downgrading
of the initial value problem, by eliminating time-dependent
interactions and treating time as an ordering parameter.

A special problem that is currently under development
is \kw{inverse dynamics}.
