% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2012
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Modules}

\section{Element Modules}

\subsection{Module-aerodyn}
\emph{Authors: Fanzhong Meng and Pierangelo Masarati}

\noindent
Implements NREL's AeroDyn v 12.58 wind turbine aerodynamic loads.

\subsection{Module-asynchronous\_machine}
\emph{Author: Reinhard Resch}

\noindent
Implements an asynchronous electric motor.

\subsection{Module-hydrodynamic\_plain\_bearing}
\emph{Author: Reinhard Resch}

\noindent
Implements a lubricated bearing.

\subsection{Module-imu}
\emph{Author: Pierangelo Masarati}

\noindent
Implements an element that provides the motion of a structural node
in the form of the output of an Inertial Measurement Unit
(3 components of acceleration, 3 components of angular velocity in body axes)
and an element that prescribes the motion of a structural node
in terms of acceleration and angular velocity.

\subsection{Module-mds}
Simple example of run-time loadable user-defined element,
implements a scalar mass-damper-spring system.

\subsection{Module-nonsmooth-node}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{type} ::= \kw{nonsmooth node}

    \bnt{args} ::=
        [ \kw{frictional} , \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{frictional} \} , ]
        (\ty{StructDispNode}) \bnt{NonsmoothNODELABEL} ,
        \kw{mass} , (\ty{real}) \bnt{mass} ,
        \kw{radius} , (\ty{real}) \bnt{radius} ,
        \kw{planes} , (\ty{int}) \bnt{number_of_planes} ,
            \bnt{PlaneDefiningNODELABEL} ,
                \kw{position} , (\ty{Vec3}) \bnt{relative_plane_position} ,
                \kw{rotation orientation} , (\ty{OrientationMatrix}) \bnt{rel_rot_orientation_1} ,
                \kw{restitution} , (\ty{real}) \bnt{rest_coeff}
                [ , \kw{frictional coefficient} , (\ty{real}) \bnt{mu} ] # only if \nt{frictional} is true
                [ , ... ]
        [ , \kw{constraint type} , \{ \kw{position} | \kw{velocity} | \kw{both} \} ] # default: both
        [ , \kw{theta} , \bnt{theta} ]
        [ , \kw{gamma} , \bnt{gamma} ]
        [ , \kw{LCP solver} , \bnt{solver} ]
        [ , \kw{tolerance} , \bnt{tolerance} ]
        [ , \kw{max iterations} , \bnt{num_iter} ]
            # these options depend on LCP solver support, see
            # \url{http://siconos.gforge.inria.fr/Numerics/LCPSolvers.html}
        [ , \kw{limit iterations} , \bnt{niterations} ]
        [ , \kw{limit LCP iterations} , \bnt{niterations} ]
        [ , \kw{verbose} , \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{verbose} \} ]

    \bnt{solver} ::=
        \kw{lexico lemke} # the default
        | \kw{rpgs}
        | \kw{qp}
        | \kw{cpg}
        | \kw{pgs}
        | \kw{psor}
        | \kw{nsqp}
        | \kw{latin}
        | \kw{latin_w}
        | \kw{newton_min}
        | \kw{newton_FB}
\end{Verbatim}

\subsubsection{Output}
\begin{itemize}
\item 1: element label
\item 2-4:   impulse on nonsmooth node in global ref. frame
\item 5-7:   position of nonsmooth node in global ref. frame
\item 8-10:  velocity of nonsmooth node in global ref. frame
\item 11-13: constraint reaction between multibody node and nonsmooth node
\item 14:    norm of the impulse reaction in global ref. frame
\item 15:    number of active constraints during step
\end{itemize}
if verbose, also:
\begin{itemize}
\item 16-18: position constraint relaxation factor (if any)
\item 19:    LCP solver status: 0 indicates convergence, 1 indicates \nt{iter}=\nt{maxiter}, $>1$ indicates failure
(only for some solvers)
\item 20:    LCP solver \nt{resulting\_error}
(only for some solvers)
\end{itemize}


\subsection{Module-template2}
Template of user-defined element.

\subsection{Module-wheel2}
\emph{Authors: Marco Morandini, Stefania Gualdi and Pierangelo Masarati}

\noindent
Implements a simple tire model for aircraft landing and ground handling.



\section{Constitutive Law Modules}

\subsection{Module-constlaw}
Simple example of run-time loadable user-defined constitutive law.

\subsection{Module-constlaw-f90}
Simple example of run-time loadable user-defined constitutive law in Fortran 90.

\subsection{Module-constlaw-f95}
Simple example of run-time loadable user-defined constitutive law in Fortran 95.

\subsection{Module-cont-contact}
\emph{Author: Matteo Fancello}

\noindent
Implements various formulas of 1D continuous contact models.

\subsection{Module-damper-graall}
\emph{Author: Pierangelo Masarati, based on an original work of Gian Luca Ghiringhelli}

This module implements a 1D constitutive law that models
the behavior of a landing gear shock absorber.
It requires the user to supply the name of the GRAALL-style 
input file that contains the data of the damper.
It will be documented as soon as it reaches an appreciable level
of stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL:SHOCK-ABSORBER}
constitutive law.

\subsection{Module-damper-hydraulic}
\emph{Author: Pierangelo Masarati}

\noindent
Implements a simple hydraulic damper with turbulent orifice and relief valve.

\subsection{Module-muscles}
\emph{Authors: Andrea Zanoni and Pierangelo Masarati}

\noindent
Implements a family of simple muscle constitutive laws.



\section{Drive Caller Modules}

\subsection{Module-drive}
Simple example of run-time loadable user-defined drive caller.



\section{Template Drive Caller Modules}

\subsection{Module-eu2phi}
Implements a \ty{TplDriveCaller<Vec3>} drive caller
that converts three Euler angles into the corresponding Euler vector.

Syntax:
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{eu2phi} ,
        [ \kw{help} , ]
        [ \kw{format} , \{ \kw{euler123} | \kw{euler313} | \kw{euler321} \} , ]
        (\ty{TplDriveCaller<Vec3>}) \bnt{drive}
\end{Verbatim}
Example:
\begin{verbatim}
    # assuming that file drive 1 provides Euler angles 1, 2 and 3 in channels 1, 2, 3:
    joint: 10, total joint,
        1001,
        1002,
        orientation constraint, active, active, active,
            eu2phi, format, euler123,
            component, file, 1, 1,
            component, file, 1, 2,
            component, file, 1, 3;
\end{verbatim}


\section{Scalar Function Modules}

\subsection{Module-scalarfunc}
Simple example of run-time loadable user-defined scalar function.



\section{Miscellaneous Modules}

\subsection{Module-octave}
\emph{Author: Reinhard Resch}

\noindent
Implements support for octave-based user-defined entities, including
drive callers, constitutive laws, scalar functions, and elements.

\subsubsection{General octave flags}
Every GNU Octave based entity supports the following flags:
\begin{Verbatim}[commandchars=\\\{\}]
	\bnt{octave_flags} ::= [ \kw{update octave variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
			   [ \kw{update mbdyn variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
			   [ \kw{update global variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
			   [ \kw{pass data manager}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
			   [ \kw{embed octave}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
			   [ \kw{octave search path}, (\ty{string}) \bnt{path1} [ , \ldots ] ]
						   
\end{Verbatim}
\paragraph{Global variables}
If the flag \kw{update octave variables} is enabled, MBDyn's symbol table is copied to the global Octave name space before each function call.
This flag should be used only if the Octave function has to access things like plug in variables which depend on the state of the simulation.
If this flag is not enabled (the default) MBDyn's symbol table is copied only before the first call of any Octave function.
If the flag \kw{update mbdyn variables} is enabled, MBDyn's symbol table is updated by Octave's global variables after each function call.
Only those variables that exist in MBDyn's symbol table are updated.
The flag \kw{update global variables} is a combination of \kw{update octave variables} and \kw{update mbdyn variables}.

\paragraph{Additional arguments}
If the flag \kw{pass data manager} is enabled, a pointer to MBDyn's data manager is passed to the Octave function as the last argument.

\paragraph{Embed octave}
The flag \kw{embed octave} makes it possible to write Octave functions directly inside the MBDyn input file.
This is especially useful for small models. If this flag is enabled, the MBDyn input file where \kw{embed octave} appears will be sourced into Octave before the first function call.
In order to work it is necessary to put all MBDyn specific commands inside a $\#\lbrace$ \ldots $\#\rbrace$ comment, and to put all Octave specific code inside a \#/* \ldots \#*/ comment.

\paragraph{Octave's search path}
Directories which should be appended to Octave's search path should appear after \kw{octave search path}.
This is rather a global option and is not specific to a particular element or drive caller.

\subsubsection{Element}
An Octave element is a full featured user defined MBDyn element written in GNU Octave scripting language.
From Octave's point of view an Octave element is a special class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{elem_type} ::= \kw{user defined}

    \bnt{normal_arglist} ::= \kw{octave} , " \bnt{class\_name} " \\
                         [ , \bnt{octave\_flags} ] \\
                         [ , \bnt{elem\_data} ]
\end{Verbatim}
All member functions of this class must reside in a directory named "\texttt{@}\bnt{class\_name}".
The parent directory of "\texttt{@}\bnt{class\_name}" must be on Octave's search path.
Additional Element specific data in \bnt{elem\_data} like node labels, vectors and rotation matrices may be accessed from within the constructor of the Octave class. If the \texttt{octave-ad} package is installed, the $\textit{\textbf{D}}$ function can be used to in order to compute the Jacobian matrix.

\paragraph{Octave element member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item $\left[elem\right] = \bnt{class\_name}\left(pMbElem,\,pDM,\,HP\right)$
\item $\left[iRows,\,iCols\right] = \textit{\textbf{WorkSpaceDim}}\left(elem\right)$
\item $\left[iNumDof\right] = \textit{\textbf{iGetNumDof}}\left(elem\right)\quad_{(optional)}$
\item $\left[f,\,ridx\right] = \textit{\textbf{AssRes}}\left(elem,\,dCoef,\,XCurr,\,XPrimeCurr\right)$
\item $\left[Jac,\,ridx,\,cidx,\,bSparse\right] = \textit{\textbf{AssJac}}\left(elem,\,dCoef,\,XCurr,\,XPrimeCurr\right)\quad_{(optional)}$
\item $\left[elem\right] = \textit{\textbf{Update}}\left(elemin, XCurr, XPrimeCurr\right)\quad_{(optional)}$
\item $\textit{\textbf{SetValue}}\left(elem,\,XCurr,\,XPrimeCurr\right)\quad_{(optional)}$
\item $\left[iNumDof\right] = \textit{\textbf{iGetInitialNumDof}}\left(elem\right)\quad_{(optional)}$
\item $\textit{\textbf{SetInitialValue}}\left(elem,\,XCurr\right)\quad_{(optional)}$
\item $\left[f,\,ridx\right] = \textit{\textbf{InitialAssRes}}\left(elem,\,XCurr\right)\quad_{(optional)}$
\item $\left[Jac,\,ridx,\,cidx,\,bSparse\right] = \textit{\textbf{InitialAssJac}}\left(elem,\,XCurr\right)\quad_{(optional)}$
\item $\left[iRows,\,iCols\right] = \textit{\textbf{InitialWorkSpaceDim}}\left(elem\right)\quad_{(optional)}$
\item $\left[order\right] = \textit{\textbf{GetDofType}}\left(elem,\,i\right)\quad_{(optional)}$
\item $\left[order\right] = \textit{\textbf{GetEqType}}\left(elem,\,i\right)\quad_{(optional)}$
\item $\left[elem\right] = \textit{\textbf{AfterConvergence}}\left(elemin,\,XCurr,\,XPrimeCurr\right)\quad_{(optional)}$
\item $\left[iNumPrivData\right] = \textit{\textbf{iGetNumPrivData}}\left(elem\right)\quad_{(optional)}$
\item $\left[iPrivDataIdx\right] = \textit{\textbf{iGetPrivDataIdx}}\left(elem,\,name\right)\quad_{(optional)}$
\item $\left[dPrivData\right] = \textit{\textbf{dGetPrivData}}\left(elem,\,i\right)\quad_{(optional)}$
\item $\left[iNumConnectedNodes\right] = \textit{\textbf{iGetNumConnectedNodes}}\left(elem\right)\quad_{(optional)}$
\item $\left[connectedNodes\right] = \textit{\textbf{GetConnectedNodes}}\left(elem\right)\quad_{(optional)}$
\item $\textit{\textbf{Output}}\left(elem,\,Loadable\right)\quad_{(optional)}$
\item $\textit{\textbf{DescribeDof}}\left(elem,\,out,\,prefix,\,bInitial\right)\quad_{(optional)}$
\item $\textit{\textbf{DescribeEq}}\left(elem,\,out,\,prefix,\,bInitial\right)\quad_{(optional)}$
\item $\left[elem\right] = \textit{\textbf{AfterPredict}}\left(elemin, XCurr, XPrimeCurr\right)\quad_{(optional)}$
\item $\textit{\textbf{Restart}}\left(elem,\,out\right)\quad_{(optional)}$
\end{itemize}
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsubsection{Drive Caller}
An Octave drive caller could be used as an alternative to string drives or Ginac drives. 
If the \texttt{octave-ad} package is installed, Octave based drive callers are differentiable by default.
An arbitrary number of additional arguments can be passed to the Octave function \bnt{function\_name} after the \kw{arguments} keyword.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
                       [ , \bnt{octave\_flags} ] \\
                       [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Template Drive Caller}
The syntax of a template drive caller is the same like the scalar drive caller. Of course the Octave function must return a matrix or a vector according to the dimension of the drive caller. The template drive caller is also differentiable by default.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{tpl_drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
                           [ , \bnt{octave\_flags} ] \\
                           [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Scalar Function}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{scalar_function} ::= \kw{octave} , " \bnt{function\_name} "
                          [ , \bnt{octave_flags} ] \\
                          [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Constitutive Law}
Octave constitutive laws are full featured user defined constitutive laws.
Additional constitutive law specific data in \bnt{const\_law\_data} may be accessed from within the constructor of the Octave class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{specific_const_law} ::= \kw{octave} , " \bnt{class\_name} " \\
                             [ , \bnt{octave\_flags} ] \\
                             \kw{dimension} , \bnt{dimension} \\
                             [ , \bnt{const\_law\_data} ]
\end{Verbatim}

\paragraph{Octave constitutive law member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item $\left[cl\right] = \bnt{class\_name}\left(pDM,\,HP\right)$
\item $\left[cl,\,F,\,FDE,\,FDEPrime\right] = \textit{\textbf{Update}}\left(clin,\,Eps,\,EpsPrime\right)$
\item $\left[constLawType\right] = \textit{\textbf{GetConstLawType}}\left(cl\right)$
\end{itemize}
If the \texttt{octave-ad} package is installed, the $\textit{\textbf{D}}$ function can be used to compute $FDE$ and $FDEPrime$.
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsection{Module-tclpgin}
Implements the tcl pluging in form of run-time loadable module.
 
\subsection{Module-template}
Loadable element template (deprecated).

\subsection{Module-udunits}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements a namespace called \kw{units}
that provides unit-conversion capabilities
to the mathematical parser, based on the UDUnits library.
The namespace provides only the function \kw{convert},
which is thus invoked as \texttt{units::convert}.
This function's prototype is
\begin{Verbatim}[commandchars=\\\{\}]
    (\ty{real}) \kw{units}::\kw{convert}( (\ty{string}) \bnt{from} , (\ty{string}) \bnt{to} [ , (\ty{real}) \bnt{val} ] )
\end{Verbatim}
where
\begin{itemize}
\item \nt{from} is a string indicating what units to convert from;
\item \nt{to} is a string indicating what units to convert to;
\item \nt{val} is an optional real argument that indicates what value should be converted.
\end{itemize}
When called with just the two mandatory arguments, the function returns the
scale factor between the two units; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m")
\end{Verbatim}
returns 0.3048.

When called with the third optional argument \nt{val} as well, the function returns
the optional argument \nt{val} converted according to the conversion arguments;
for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m", 10.)
\end{Verbatim}
returns 3.048, corresponding to
\begin{Verbatim}[commandchars=\\\{\}]
    0.3048 m/ft * 10 ft
\end{Verbatim}

The first form may not be enough, for example, for those conversions
that include an "intercept"; for example, when converting from degrees 
Celsius to degrees Fahrenheit, the actual conversion would be
\begin{Verbatim}[commandchars=\\\{\}]
    F = 32 + 9 / 5 * C
\end{Verbatim}
In those cases, the conversion fails, unless the third argument 
is specified; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit")
\end{Verbatim}
would fail, while
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit", 0.)
\end{Verbatim}
would return 32.

This module requires UNIDATA's \texttt{libudunits}; get it from
\begin{center}
\url{http://www.unidata.ucar.edu/software/udunits/}.
\end{center}
Some Linux distributions provide it packaged;
for example, recent Ubuntu releases provide a library \texttt{libudunits2};
to use it, tweak the configuration variables
in \texttt{modules/module-udunits/Makefile.inc}.



