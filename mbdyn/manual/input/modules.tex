% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2015
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Modules}

\section{Element Modules}
Recall that element modules are invoked as \kw{user defined} elements,
whose syntax is
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{elem_type} ::= \kw{user defined}

    \bnt{normal_arglist} ::= \bnt{name} [ , \bnt{module_data} ]
\end{Verbatim}

\subsection{Module-aerodyn}
\emph{Authors: Fanzhong Meng and Pierangelo Masarati}

\noindent
This module implements NREL's AeroDyn v 12.58 wind turbine aerodynamic loads.

\subsection{Module-asynchronous\_machine}
\emph{Author: Reinhard Resch}

\noindent
This module implements an asynchronous electric motor.

\subsection{Module-cyclocopter}
\emph{Author: Mattia Mattaboni (turned into module by Pierangelo Masarati)}

\noindent
This module implements inflow models for cycloidal rotors.

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{cycloidal no inflow}

    \bnt{module_data} ::=
        \bnt{aircraft_node_label} ,
        [ \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} , ]
        \bnt{rotor_node_label}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{cycloidal} \{ \kw{uniform 1D} | \kw{uniform 2D} | \kw{Polimi} \}

    \bnt{module_data} ::=
        \bnt{aircraft_node_label} ,
        [ \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} , ]
        \bnt{rotor_node_label}
        (\ty{bool}) \bnt{average} ,
        \bnt{rotor_radius} ,
        \bnt{blade_span}
        [ , \kw{delay} , (\hty{DriveCaller}) \bnt{delay} ]
        [ , \kw{omegacut} , \bnt{cut_frequency} ]
        [ , \kw{timestep} , \bnt{time_step} ]
\end{Verbatim}

\subsection{Module-fab-electric}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several electric components.

\subsubsection{Resistor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{resistor}
\end{Verbatim}

\subsubsection{Capacitor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{capacitor}
\end{Verbatim}

\subsubsection{Inductor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{inductor}
\end{Verbatim}

\subsubsection{Diode}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{diode}
\end{Verbatim}

\subsubsection{Switch}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{switch}
\end{Verbatim}

\subsubsection{Electrical source}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{electrical source}
\end{Verbatim}

\subsubsection{Ideal transformer}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{ideal transformer}
\end{Verbatim}

\subsubsection{Operational amplifier}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{operational amplifier}
\end{Verbatim}

\subsubsection{BJT}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{bjt}
\end{Verbatim}

\subsubsection{Proximity sensor}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{proximity sensor}
\end{Verbatim}



\subsection{Module-fab-motion}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several joints.

\subsubsection{Gear joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{gear joint}
\end{Verbatim}

\subsubsection{Linear transmission joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{linear transmission joint}
\end{Verbatim}

\subsubsection{Motion transmission joint}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{motion transmission joint}
\end{Verbatim}

\subsubsection{Smooth step}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{smooth step}
\end{Verbatim}



\subsection{Module-fab-sbearings}
\emph{Author: Eduardo Okabe}

\noindent
This module implements several joints.

\subsubsection{Hydrodynamic bearing}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{hydrodynamic bearing}
\end{Verbatim}

\subsubsection{Rolling bearing}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{rolling bearing}
\end{Verbatim}



\subsection{Module-hydrodynamic\_plain\_bearing}
\emph{Author: Reinhard Resch}

\noindent
This module implements a lubricated bearing.

\subsection{Module-imu}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements an element that provides the motion of a structural node
in the form of the output of an Inertial Measurement Unit
(3 components of acceleration, 3 components of angular velocity in body axes)
and an element that prescribes the motion of a structural node
in terms of acceleration and angular velocity.

\subsubsection{IMU}
This user-defined element emulates a IMU.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{imu}

    \bnt{module_data} ::=
        \bnt{node_label}
            [ , \kw{position} , (\hty{Vec3}) \bnt{offset} ]
            [ , \kw{orientation} , \hty{OrientationMatrix} \bnt{orientation} ]
\end{Verbatim}
It makes the acceleration and the angular velocity of node \nt{node\_label}
available in the node's reference frame as private data.
The location and orientation of the IMU with respect to the node may be modified
by \nt{offset} and \nt{orientation}.

\paragraph{Output.}
This element sends output to the \texttt{.usr} file.
Each entry contains
\begin{itemize}
\item[1)] the label
\item[2--4)] three components of angular velocity, in the reference frame of the node
\item[5--7)] three components of acceleration, in the reference frame of the node
\end{itemize}

\paragraph{Private Data.}
The following data are available:
\begin{enumerate}
\item \kw{"wx"} angular velocity in local direction 1
\item \kw{"wy"} angular velocity in local direction 2
\item \kw{"wz"} angular velocity in local direction 3
\item \kw{"ax"} acceleration in local direction 1
\item \kw{"ay"} acceleration in local direction 2
\item \kw{"az"} acceleration in local direction 3
\end{enumerate}


\subsubsection{IMU constraint}
This user-defined element enforces IMU data as a constraint.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{imu constraint}

    \bnt{module_data} ::=
        \bnt{node_label}
            [ , \kw{position} , (\hty{Vec3}) \bnt{offset} ]
            [ , \kw{orientation} , (\hty{OrientationMatrix}) \bnt{orientation} ]
            (\htybty{TplDriveCaller}{Vec3}) \bnt{omega} ,
            (\htybty{TplDriveCaller}{Vec3}) \bnt{acceleration}
\end{Verbatim}
It imposes the angular velocity \nt{omega} and the acceleration \nt{acceleration},
namely the measurements that come from an IMU, to node \nt{node\_label}.
The location and orientation of the IMU with respect to the node may be modified
by \nt{offset} and \nt{orientation}.

\paragraph{Output.}
This element sends output to the \texttt{.usr} file.
Each entry contains
\begin{itemize}
\item[1)] the label
\item[2--4)] three angular velocity Lagrange multipliers, in the reference frame of the node
\item[5--7)] three acceleration Lagrange multipliers, in the reference frame of the node
\item[8--10)] three components of velocity, in the reference frame of the node
\item[11--13)] three components of velocity derivative, in the reference frame of the node
\end{itemize}





\subsection{Module-mds}
This module is a simple example of run-time loadable user-defined element,
implements a scalar mass-damper-spring system.

\subsection{Module-nonsmooth-node}
\emph{Author: Matteo Fancello}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{nonsmooth node}

    \bnt{module_data} ::=
        (\ty{StructDispNode}) \bnt{NonsmoothNODELABEL} ,
        \kw{mass} , (\ty{real}) \bnt{mass} ,
        \kw{radius} , (\ty{real}) \bnt{radius} ,
        \kw{planes} , (\ty{integer}) \bnt{number_of_planes} ,
            \bnt{PlaneDefiningNODELABEL} ,
                \kw{position} , (\hty{Vec3}) \bnt{relative_plane_position} ,
                \kw{rotation orientation} , (\hty{OrientationMatrix}) \bnt{rel_rot_orientation_1} ,
                \kw{restitution} , (\ty{real}) \bnt{rest_coeff}
                [ , \kw{friction coefficient} , (\ty{real}) \bnt{mu} ] 
            [ , ... ] # as many blocks as \nt{number_of_planes}
        [ , \kw{constraint type} , \{ \kw{position} | \kw{velocity} | \kw{both} \} ] # default: \kw{both}
        [ , \kw{theta} , \bnt{theta} ]
        [ , \kw{gamma} , \bnt{gamma} ]
        [ , \kw{LCP solver} , \bnt{solver} ]
        [ , \kw{tolerance} , \bnt{tolerance} ]
        [ , \kw{max iterations} , \bnt{num_iter} ]
            # these options depend on LCP solver support, see
            # \url{http://siconos.gforge.inria.fr/Numerics/LCPSolvers.html}
        [ , \kw{limit iterations} , \bnt{niterations} ]
        [ , \kw{limit LCP iterations} , \bnt{niterations} ]
        [ , \kw{verbose} , \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{verbose} \} ]

    \bnt{solver} ::=
        \kw{lexico lemke} # the default
        | \kw{rpgs}
        | \kw{qp}
        | \kw{cpg}
        | \kw{pgs}
        | \kw{psor}
        | \kw{nsqp}
        | \kw{latin}
        | \kw{latin_w}
        | \kw{newton_min}
        | \kw{newton_FB}
\end{Verbatim}

\subsubsection{Output}
\begin{itemize}
\item 1: element label
\item 2--4:   impulse on nonsmooth node in global ref. frame
\item 5--7:   position of nonsmooth node in global ref. frame
\item 8--10:  velocity of nonsmooth node in global ref. frame
\item 11--13: constraint reaction between multibody node and nonsmooth node
\item 14:    norm of the impulse reaction normal to the contact plane
\item 15:    number of active constraints during step
\end{itemize}
if verbose, also:
\begin{itemize}
\item 16--18: position constraint relaxation factor
	(only when \kw{constraint type} is \kw{both})
\item 19:    LCP solver status:
	0 indicates convergence,
	1 indicates \nt{iter} $\equiv$ \nt{maxiter},
	$>1$ indicates failure
(only for some solvers)
\item 20:    LCP solver \nt{resulting\_error}
(only meaningful for some solvers)
\end{itemize}


\subsection{Module-template2}
Template of user-defined element.

\subsection{Module-wheel2}
\emph{Authors: Marco Morandini, Stefania Gualdi and Pierangelo Masarati}

\noindent
This module implements a simple tire model for aircraft landing and ground handling.


\subsection{Module-wheel4}
%% written on April 2015
\emph{Authors: Louis Gagnon, Marco Morandini, and Pierangelo Masarati}

\noindent
This module implements a rigid ring tire model similar to the models commonly known as SWIFT. It is used as an element that will apply a 3D force and a 3D moment to the ring node of a wheel-ring multibody system. A wheel node is also necessary for inertia and contact forces calculations. It is intended to evaluate the transient behavior of the tire rolling on a deteriorated road profile. The equations are integrated implicitly except for the road profile, which is an input. This profile has to be previously filtered by a super ellipse function because the wheel4 module will only apply the tandem-cam part of the profile filtering. It is tailored for, but not restricted to, applications at low camber angles, limited steering and velocity changes, and continuous contact with the road. It is expected to be accurate under excitation frequencies up to 100~Hz and road deformations up to 20\% of the tire radius. A variable time-step algorithm is also embed and speeds up the simulation in cases where the road is flat.

Two runnable examples are available and will clarify the implementation in an actual multibody simulation:
\begin{itemize}
\item the simple example \textit{axleExampleNoData} located within the module-wheel4 directory of the MBDyn package
\item the more complex \textit{semitrailer} model is available on the example page of the MBDyn website; this example provides the script necessary to apply the super ellipse filter on the road profile; \htmladdnormallink{\kw{http://www.mbdyn.org/?Documentation\_\_\_Official\_Documentation\_\_\_Examples}}{http://www.mbdyn.org/?Documentation\_\_\_Official\_Documentation\_\_\_Examples}
\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{name} ::= \kw{wheel4}

    \bnt{module_data} ::=
        (\ty{StructDispNode}) \bnt{WheelStructNodeLabel} , (\ty{StructBody}) \bnt{WheelBodyLabel} ,
        (\ty{OrientationVector}) \bnt{wheel_axle_direction} , (\ty{real}) \bnt{tire_radius} ,
        \kw{swift} ,
        (\ty{StructDispNode}) \bnt{RingStructNodeLabel} , (\ty{StructBody}) \bnt{RingBodyLabel} ,
        (\ty{vector}) \bnt{patch_stiffness} , (\ty{drive}) \bnt{stiffness_modifier} ,
        (\ty{vector}) \bnt{patch_damping} , (\ty{drive}) \bnt{damping_modifier} ,
        (\ty{vector}) \bnt{initial_patch_velocity} , (\ty{real}) \bnt{patch_mass} ,
        (\hty{DriveCaller}) \bnt{road_profile_driver} ,
        (\ty{real}) \bnt{patch_to_ellip_cam_ratio} ,
        (\ty{real}) \bnt{r_a1_param} , (\ty{real}) \bnt{r_a2_param} ,
        (\ty{real}) \bnt{patchToTireCircumf_ratio} ,
        (\ty{real}) \bnt{vert_wheel_ring_stiff}
        [ , \kw{loadedRadius} ]
        [ , \kw{slip} ,
        \kw{ginac} , \bnt{longi_tire_force_funct} ,
        \kw{ginac} , \bnt{lateral_tire_force_funct} ,
        \kw{ginac} , \bnt{pneumatic_trail_funct} ,
        \kw{ginac} , \bnt{aligning_residual_moment} ,
        (\ty{real}) \bnt{S_ht} , (\ty{real}) \bnt{S_hf} ,
        (\ty{real}) \bnt{q_sy1} , (\ty{real}) \bnt{q_sy3} ,
        (\ty{real}) \bnt{dvao}
        [ , \kw{threshold}, (\ty{real}) \bnt{TRH} , (\ty{real}) \bnt{TRHA} , (\ty{real}) \bnt{TRHT} , 
        (\ty{real}) \bnt{TRHTA} , (\ty{real}) \bnt{TRHC} , (\ty{real}) \bnt{TdLs} , (\ty{real}) \bnt{TdReDiv} ,
        (\ty{real}) \bnt{TdRe} , (\ty{real}) \bnt{dtOn} , (\ty{real}) \bnt{TmaxH} , 
        (\ty{real}) \bnt{dtRes} , (\ty{real}) \bnt{maxstep} , (\ty{real}) \bnt{minstep} , 
        (\ty{real}) \bnt{TmaxF} , (\ty{real}) \bnt{TminF} , (\ty{integer}) \bnt{TminS} , (\ty{real}) \bnt{TdivF} ,
        (\ty{real}) \bnt{TdivF3} , (\ty{real}) \bnt{TdivF4} , (\ty{real}) \bnt{RDA} , 
        (\ty{real}) \bnt{RDB} , (\ty{real}) \bnt{RDL} ] ]
\end{Verbatim}
where the keyword \kw{loadedRadius} enables the use of the alternative, validated, loading radius instead of the more generally used definition. The keywords \kw{slip} and \kw{threshold} should always be present. Although the given examples are the best way to understand the model, the following tables clarify most input parameters,

%theoretically allows turning off the contact forces, the code has never been adjusted to work that way and thus the keyword 
%A similar reasoning applies to the  keyword, which enables the threshold parameters that stabilize the tire model. 

\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
	\hline
		  & \textbf{tire parameters} \\
        \bnt{wheel\_axle\_direction}      & 3D vector of the wheel axle direction in the absolute reference frame (care should be taken if set to a value other than \textit{0.,1.,0.} because no elaborate testing has been carried for alternate axle initial orientations; any comments or on its functionality are welcome) \\
	\bnt{tire\_radius}	               &   rigid ring radius (undeformed radius of the tire) \\
	\bnt{patch\_stiffness}                  & 3D stiffness vector of the contact patch to ring connection (in the ring reference frame) \\
	\bnt{stiffness\_modifier}     & modifier drive to allow, for example, a gradual application of the stiffness   \\
	\bnt{patch\_damping}          & 3D damping vector of the contact patch to ring connection (usually about 6\% to 10\% of critical damping and distributed over ring and patch connections)   \\
	\bnt{damping\_modifier}       & modifier drive to allow, for example, a gradual application of the damping   \\ 
	 \bnt{initial\_patch\_velocity}          & 3D vector for the initial velocity of the patch in absolute reference frame \\
        \bnt{patch\_to\_ellip\_cam\_ratio}          &  patch contact-length to elliptical cam tandem base parameter (Schmeitz eq. 4.15, $l_s/(2a)$ )  \\
	\bnt{r\_a1\_param} 	        &  $r_{a1}$ contact length parameter from Besselink eq. 4.85 \\
	\bnt{r\_a2\_param} 	        & $r_{a2}$ contact length parameter from Besselink eq. 4.85  \\
	\bnt{patchToTireCircumf\_ratio} & ratio of the contact patch length to tire circumference (to calculate how much mass contributes to the ring's centripetal forces)  \\	  
	\bnt{vert\_wheel\_ring\_stiff}     & vertical stiffness given to the viscoelastic connection between the ring and the wheel nodes      \\ 
	\bnt{longi\_tire\_force\_func}       & longitudinal force $F_x/F_z$ given in Ginac format \\
        \bnt{lateral\_tire\_force\_func}            & lateral force $F_y/F_z$ given in Ginac format \\
        \bnt{pneumatic\_trail\_func}               & pneumatic trail divided by vertical force and given in Ginac format  \\
        \bnt{aligning\_residual\_moment}      & residual torque $M_{zr}/F_z$  given in Ginac format   \\
	\bnt{S\_ht}      & horizontal shift of pneumatic trail, for aligning moment angle modifier \\
	\bnt{S\_hf}   & residual aligning moment angle modifier/shift \\
	\bnt{q\_sy1}   & tire rolling resistance linear velocity coefficient (usually between 0.01 and 0.02) \\
	\bnt{q\_sy3}  & rolling resistance velocity correction coefficient \\
	\bnt{dvao} & reference velocity for rolling resistance velocity influence factor \\
	\hline
\end{tabular}

\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{variable timestep algorithm parameter} \\
	\bnt{dtOn} & boolean to enable or disable adjustable timestep calculation (will greatly increase the rapidity of the solution only if you have few bumps on a very smooth road and will otherwise slow down the simulation) \\
	\bnt{TmaxH} & maximum height change wanted on the road profile for one step \\
	\bnt{dtRes} & resolution of bump search  \\
	\bnt{maxstep} & maximum timestep imposed in the initial value section \\
	\bnt{minstep} &  minimum timestep imposed in the initial value section \\
	\bnt{TdivF3} &  timestep adjustment factor if force switched sign 3 times in the last \kw{TminS} steps\\
	\bnt{TdivF4} &  timestep adjustment factor if force switched sign 4 or more times in the last \kw{TminS} steps\\
	\hline
\end{tabular}
	
\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{road offset parameters} \\
	\bnt{RDA} & road offset (null before position reaches that value) \\
	\bnt{RDB} & road offset (interpolated when position is between \bnt{RDA} and that value) \\
	\bnt{RDL} & road loop condition (will loop after \bnt{RDB}+\bnt{RDL} over \bnt{RDL}) \\
	\hline
\end{tabular}
	
\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
\hline
	           & \textbf{algorithm threshold parameters} \\
	\bnt{TRH} &   prevents division by zero at null x-velocity at the price of losing validity for velocities near \bnt{TRH} \\
	\bnt{TRHA} & buffer used to prevent division by zero \\
	\bnt{TRHT} & prevents division by zero when computing the angle of the vehicle or wheels \\
	\bnt{TRHTA} & buffer used on angle zero division prevention \\
	\bnt{TRHC} & maximum value allowed for the longitudinal slip ratio \\
	\bnt{TdLs} & minimum value that the half contact patch length may take \\
	\bnt{TdReDiv} & minimum value that the wheel angular velocity may take in the calculation of the effective rolling radius \\
	\bnt{TdRe} & maximum ratio $\left|\frac{effective rolling radius}{ring radius}\right|$ which will be allowed to reach \\
	\hline
\end{tabular}
\newline

Information about the informally cited works may be found in the following two theses,
\begin{itemize}
\item Schmeitz, A. J. C. (2004) \textit{A Semi-Empirical Three-Dimensional Model of the Pneumatic Tyre Rolling over Arbitrarily Uneven Road Surfaces} available on request
\item Besselink, I.J.M. (2000). \textit{Shimmy of Aircraft Main Landing Gears} available at
\newline
\htmladdnormallink{\kw{http://www.tue.nl/en/publication/ep/p/d/ep-uid/227775/}}{http://www.tue.nl/en/publication/ep/p/d/ep-uid/227775/}
\end{itemize}

\subsubsection{Output}
The output can be obtained either in plain text in the \textbf{.usr} file or in NetCDF format in the \textbf{.nc} file. Section~\ref{sec:NetCDF:Node:Structural Node} explains the NetCDF output whereas the plain text output is as follows,
\begin{itemize}
\item 1: element label
\item 2: velocity of wheel in x-dir (longitudinal, forward)
\item 3: velocity of wheel in y-dir (lateral)
\item 4: relative speed between center of wheel and contact point on tire in the forward direction
\item 5--7: moment applied on ring by this module
\item 8--10: moment arm on ring
\item 11: slip ratio
\item 12: slip angle
\item 13: longitudinal friction coefficient
\item 14: lateral friction coefficient
\item 15: road height
\item 16--18: road normal
\item 19--21: position of patch
\item 22--24: velocity of patch
\item 25--27: relative position of patch
\item 28--30: relative velocity of patch
\item 31--33: force between ring and patch acting on patch
\item 34--36: force between ring and patch acting on ring and thus applied on ring by this module
\item 37--39: forward direction vector of the wheel
\item 40--42: forward direction vector of the ring
\item 43--45: forward direction vector of the ring without the slope of the profile
\item 46--48: point of contact on ring between ring and springs (contact patch viscoelastic elements)
\item 49: normal force for Pacejka's formulas
\item 50--52: relative velocity between patch and wheel
\item 53: sum of wheel, ring, and patch kinetic energies
\item 54: sum of wheel and ring potential energies (patch is not included because it is not subjected to gravity)
\item 55: sum of wheel, ring, and patch total energies (kinetic + potential)
\item 56: virtually calculated effective rolling radius
\item 57: half length of the tandem elliptical cam follower
\item 58: modified loaded radius (distance between ring center and patch center)
\item 59--61: distance between ring contact point and patch as seen from the ring in its own reference frame (not rotated with road slope)
\item 62: centrifugal force added to tire
\item 63--65: rolling resistance force vector (this force is then applied as a moment only)
\item 66--68: aligning moment
\item 69: center point x-value of the road profile (this is not actual position, but only position on the input road file
\item 70: front edge x-point of the tandem (front contact point of patch)
\item 71: rear edge x-point of the tandem (rear contact point of patch)
\item 72: centrifugally induced virtual displacement of tire in the radial direction (units of distance)
\item 73: patch vertical velocity calculated using road displacement and timestep
\item 74: timestep
\end{itemize}



\section{Constitutive Law Modules}

\subsection{Module-constlaw}
Simple example of run-time loadable user-defined constitutive law.

\subsection{Module-constlaw-f90}
Simple example of run-time loadable user-defined constitutive law in Fortran 90.

\subsection{Module-constlaw-f95}
Simple example of run-time loadable user-defined constitutive law in Fortran 95.

\subsection{Module-cont-contact}
\emph{Author: Matteo Fancello}

\noindent
Implements various formulas of 1D continuous contact models.

\subsection{Module-damper-graall}
\emph{Author: Pierangelo Masarati, based on an original work of Gian Luca Ghiringhelli}

This module implements a 1D constitutive law that models
the behavior of a landing gear shock absorber.
It requires the user to supply the name of the GRAALL-style 
input file that contains the data of the damper.
It will be documented as soon as it reaches an appreciable level
of stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL:SHOCK-ABSORBER}
constitutive law.

\subsection{Module-damper-hydraulic}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements a simple hydraulic damper with turbulent orifice and relief valve.

\subsection{Module-muscles}
\emph{Authors: Andrea Zanoni and Pierangelo Masarati}

\bigskip

\noindent
This module implements a family of simple muscle constitutive laws,
based on \cite{PENNESTRI-2007-JB}.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{muscle Pennestri} ,
        [ \kw{initial length} , \bnt{Li} , ]
        \kw{reference length} , \bnt{L0} ,
        [ \kw{reference velocity} , \bnt{V0} , ]
        \kw{reference force} , \bnt{F0} ,
        \kw{activation} , (\hty{DriveCaller}) \bnt{activation}
            [ , \kw{activation check} , (\ty{bool}) \bnt{activation_check} ]
        [ , \kw{ergonomy} , \{ \kw{yes} | \kw{no} \} ]
        [ , \kw{reflexive} , # only when ergonomy == no
            \kw{proportional gain} , \bnt{kp} ,
            \kw{derivative gain} , \bnt{kd} ,
            \kw{reference length} , (\hty{DriveCaller}) \bnt{lref} ]
\end{Verbatim}
The \kw{ergonomy} flag, when active, indicates that the equivalent damping
must not be used.
It is used to indicate that the constitutive law acts as an ``ergonomy''
spring in an inverse kinematics analysis.

The \kw{reflexive} keyword indicates that reflexive behavior is being defined;
its use is mutually exclusive with the active status of the \kw{ergonomy} flag.

The \kw{initial length} equal to \kw{reference length} unless specified.
It is used to differentiate the length of the rod as computed from the input
from the length used to formulate the constitutive law.

The \kw{reference velocity} is set to 2.5 m/s unless specified.

The second occurrence of the \kw{reference length} is related
to the reflexive contribution to muscular activation, which is defined as
\begin{align}
	a
	&=
	\nt{activation}
	+
	\nt{kp} \cdot \plbr{
		\frac{\ell}{\nt{L0}}
		-
		\frac{\nt{lref}}{\nt{L0}}
	}
	+
	\nt{kd} \cdot \frac{\dot{\ell}}{\nt{V0}}
\end{align}



\section{Drive Caller Modules}

\subsection{Module-drive}
Simple example of run-time loadable user-defined drive caller.


\subsection{Module-randdrive}
Generates normally distributed pseudo-random numbers
with given mean and variance (standard deviation) using 
the random number handling capabilities
provided by Boost\footnote{\url{http://www.boost.org/}}.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{boost random} ,
        (\ty{real}) \bnt{mean} , (\ty{real}) \bnt{variance}
\end{Verbatim}
The module itself supports load-time input parameters:
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{module load} : "libmodule-randdrive"
        [ , \{ \kw{seed} , (\ty{integer}) \bnt{seed} ]
            | \kw{seed input file name} , " \bnt{seed_input_file_name} " \} ]
        [ , \kw{seed output file name} , " \bnt{seed_output_file_name} " ]
\end{Verbatim}
where the integer \nt{seed} is used to seed the random number generator,
whereas \nt{seed\_input\_file\_name} and \nt{seed\_output\_file\_name}
are used to load/save the random number generator's state
in Boost's internal format.



\section{Template Drive Caller Modules}

\subsection{Module-eu2phi}
This module implements a \htybty{TplDriveCaller}{Vec3} drive caller
that converts three Euler angles into the corresponding Euler vector.

Syntax:
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{eu2phi} ,
        [ \kw{help} , ]
        [ \kw{format} , \{ \kw{euler123} | \kw{euler313} | \kw{euler321} \} , ]
        (\htybty{TplDriveCaller}{Vec3}) \bnt{drive}
\end{Verbatim}
Example:
\begin{verbatim}
    # assuming that file drive 1 provides Euler angles 1, 2 and 3 in channels 1, 2, 3:
    joint: 10, total joint,
        1001,
        1002,
        orientation constraint, active, active, active,
            eu2phi, format, euler123,
                component,
                    file, 1, 1,
                    file, 1, 2,
                    file, 1, 3;
\end{verbatim}


\section{Scalar Function Modules}

\subsection{Module-scalarfunc}
Simple example of run-time loadable user-defined scalar function.



\section{Miscellaneous Modules}

\subsection{Module-octave}
\emph{Author: Reinhard Resch}

\noindent
This module implements support for octave-based user-defined entities, including
drive callers, constitutive laws, scalar functions, and elements.

\subsubsection{General octave flags}
Every GNU Octave based entity supports the following flags:
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{octave_flags} ::= [ \kw{update octave variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{update mbdyn variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{update global variables}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{pass data manager}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{embed octave}, \{ \kw{yes} | \kw{no} | (\ty{bool}) \bnt{status} \}, ] \\
        [ \kw{octave search path}, (\ty{string}) \bnt{path1} [ , \ldots ] ]
\end{Verbatim}
\paragraph{Global variables}
If the flag \kw{update octave variables} is enabled, MBDyn's symbol table is copied to the global Octave name space before each function call.
This flag should be used only if the Octave function has to access things like plug in variables which depend on the state of the simulation.
If this flag is not enabled (the default) MBDyn's symbol table is copied only before the first call of any Octave function.
If the flag \kw{update mbdyn variables} is enabled, MBDyn's symbol table is updated by Octave's global variables after each function call.
Only those variables that exist in MBDyn's symbol table are updated.
The flag \kw{update global variables} is a combination of \kw{update octave variables} and \kw{update mbdyn variables}.

\paragraph{Additional arguments}
If the flag \kw{pass data manager} is enabled, a pointer to MBDyn's data manager is passed to the Octave function as the last argument.

\paragraph{Embed octave}
The flag \kw{embed octave} makes it possible to write Octave functions directly inside the MBDyn input file.
This is especially useful for small models. If this flag is enabled, the MBDyn input file where \kw{embed octave} appears will be sourced into Octave before the first function call.
In order to work it is necessary to put all MBDyn specific commands inside a $\#\lbrace$ \ldots $\#\rbrace$ comment, and to put all Octave specific code inside a \#/* \ldots \#*/ comment.

\paragraph{Octave's search path}
Directories which should be appended to Octave's search path should appear after \kw{octave search path}.
This is rather a global option and is not specific to a particular element or drive caller.

\subsubsection{Element}
An Octave element is a full featured user defined MBDyn element written in GNU Octave scripting language.
From Octave's point of view an Octave element is a special class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{elem_type} ::= \kw{user defined}

    \bnt{normal_arglist} ::= \kw{octave} , " \bnt{class\_name} " \\
        [ , \bnt{octave\_flags} ] \\
        [ , \bnt{elem\_data} ]
\end{Verbatim}
All member functions of this class must reside in a directory named ``\texttt{@}\bnt{class\_name}''.
The parent directory of ``\texttt{@}\bnt{class\_name}'' must be in Octave's search path.
Additional Element specific data in \bnt{elem\_data} like node labels,
vectors and rotation matrices may be accessed from within the constructor
of the Octave class.
If the \texttt{octave-ad} package is installed,
the \texttt{D} function can be used to in order to compute
the Jacobian matrix from the residual.

\paragraph{Octave element member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item \verb![elem] = !\bnt{class\_name}\verb!(pMbElem, pDM, HP) !
\item \verb![iRows, iCols] = !\kw{WorkSpaceDim}\verb!(elem) !
\item \verb![iNumDof] = !\kw{iGetNumDof}\verb!(elem) # optional; iNumDof == 0 if missing !
\item \kw{SetValue}\verb!(elem, XCurr, XPrimeCurr) # optional !
\item \verb![f, ridx] = !\kw{AssRes}\verb!(elem, dCoef, XCurr, XPrimeCurr) !
\item \verb![Jac, ridx, cidx, bSparse] = !\kw{AssJac}\verb!(elem, dCoef, XCurr, XPrimeCurr) # optional !
\item \verb![elem] = !\kw{Update}\verb!(elemin, XCurr, XPrimeCurr) # optional !
\item \verb![iRows, iCols] = !\kw{InitialWorkSpaceDim}\verb!(elem) # optional !
\item \verb![iNumDof] = !\kw{iGetInitialNumDof}\verb!(elem) # optional !
\item \kw{SetInitialValue}\verb!(elem, XCurr) # optional !
\item \verb![f, ridx] = !\kw{InitialAssRes}\verb!(elem, XCurr) # optional !
\item \verb![Jac, ridx, cidx, bSparse] = !\kw{InitialAssJac}\verb!(elem, XCurr) # optional !
\item \verb![order] = !\kw{GetDofType}\verb!(elem, i) # optional !
\item \verb![order] = !\kw{GetEqType}\verb!(elem, i) # optional !
\item \verb![elem] = !\kw{AfterPredict}\verb!(elemin, XCurr, XPrimeCurr) # optional !
\item \verb![elem] = !\kw{AfterConvergence}\verb!(elemin, XCurr, XPrimeCurr) # optonal !
\item \verb![iNumPrivData] = !\kw{iGetNumPrivData}\verb!(elem) # optional !
\item \verb![iPrivDataIdx] = !\kw{iGetPrivDataIdx}\verb!(elem, name) # optional !
\item \verb![dPrivData] = !\kw{dGetPrivData}\verb!(elem, i) # optional !
\item \verb![iNumConnectedNodes] = !\kw{iGetNumConnectedNodes}\verb!(elem) # optional !
\item \verb![connectedNodes] = !\kw{GetConnectedNodes}\verb!(elem) # optional !
\item \kw{Output}\verb!(elem, outStream) # optional !
\item \kw{DescribeDof}\verb!(elem, out, prefix, bInitial) # optional !
\item \kw{DescribeEq}\verb!(elem, out, prefix, bInitial) # optional !
\item \kw{Restart}\verb!(elem, out) # optional !
\end{itemize}
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsubsection{Drive Caller}
An Octave drive caller could be used as an alternative to string drives or Ginac drives. 
If the \texttt{octave-ad} package is installed, Octave based drive callers are differentiable by default.
An arbitrary number of additional arguments can be passed to the Octave function \bnt{function\_name} after the \kw{arguments} keyword.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave\_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Template Drive Caller}
The syntax of a template drive caller is the same like the scalar drive caller. Of course the Octave function must return a matrix or a vector according to the dimension of the drive caller. The template drive caller is also differentiable by default.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{tpl_drive_caller} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave\_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Scalar Function}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{scalar_function} ::= \kw{octave} , " \bnt{function\_name} "
        [ , \bnt{octave_flags} ] \\
        [ , \kw{arguments}, (\ty{integer}) \bnt{count}, \bnt{arg_1} [ , \ldots , \bnt{arg_n} ] ]
\end{Verbatim}

\subsubsection{Constitutive Law}
Octave constitutive laws are full featured user defined constitutive laws.
Additional constitutive law specific data in \bnt{const\_law\_data} may be accessed from within the constructor of the Octave class.
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{specific_const_law} ::= \kw{octave} , " \bnt{class\_name} " \\
        [ , \bnt{octave\_flags} ] \\
        \kw{dimension} , \bnt{dimension} \\
        [ , \bnt{const\_law\_data} ]
\end{Verbatim}

\paragraph{Octave constitutive law member functions}
At the moment the following member functions are supported:
\begin{itemize}
\item \verb![cl] = !\bnt{class\_name}\verb!(pDM, HP) !
\item \verb![cl, F, FDE, FDEPrime] = !\kw{Update}\verb!(clin, Eps, EpsPrime) !
\item \verb![constLawType] = !\kw{GetConstLawType}\verb!(cl) !
\end{itemize}
If the \texttt{octave-ad} package is installed, the \texttt{D} function
can be used to compute \texttt{FDE} and \texttt{FDEPrime}
from function \texttt{F}.
Semantic and parameters of these functions are almost the same like in C++. \\
\textbf{TODO}: Describe the meaning of the parameters!

\subsection{Module-tclpgin}
This module implements the tcl pluging in form of run-time loadable module.
 
\subsection{Module-template}
Loadable element template (deprecated).

\subsection{Module-udunits}
\emph{Author: Pierangelo Masarati}

\noindent
This module implements a namespace called \kw{units}
that provides unit-conversion capabilities
to the mathematical parser, based on the UDUnits library.
The namespace provides only the function \kw{convert},
which is thus invoked as \texttt{units::convert}.
This function's prototype is
\begin{Verbatim}[commandchars=\\\{\}]
    (\ty{real}) \kw{units}::\kw{convert}( (\ty{string}) \bnt{from} , (\ty{string}) \bnt{to} [ , (\ty{real}) \bnt{val} ] )
\end{Verbatim}
where
\begin{itemize}
\item \nt{from} is a string indicating what units to convert from;
\item \nt{to} is a string indicating what units to convert to;
\item \nt{val} is an optional real argument that indicates what value should be converted.
\end{itemize}
When called with just the two mandatory arguments, the function returns the
scale factor between the two units; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m")
\end{Verbatim}
returns 0.3048.

When called with the third optional argument \nt{val} as well, the function returns
the optional argument \nt{val} converted according to the conversion arguments;
for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("ft", "m", 10.)
\end{Verbatim}
returns 3.048, corresponding to
\begin{Verbatim}[commandchars=\\\{\}]
    0.3048 m/ft * 10 ft
\end{Verbatim}

The first form may not be enough, for example, for those conversions
that include an ``intercept''; for example, when converting from degrees 
Celsius to degrees Fahrenheit, the actual conversion would be
\begin{Verbatim}[commandchars=\\\{\}]
    F = 32 + 9 / 5 * C
\end{Verbatim}
In those cases, the conversion fails, unless the third argument 
is specified; for example
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit")
\end{Verbatim}
would fail, while
\begin{Verbatim}[commandchars=\\\{\}]
    units::convert("Celsius", "Fahrenheit", 0.)
\end{Verbatim}
would return 32.

This module requires UNIDATA's \texttt{libudunits}; get it from
\begin{center}
\url{http://www.unidata.ucar.edu/software/udunits/}.
\end{center}
Some Linux distributions provide it packaged;
for example, recent Ubuntu releases provide a library \texttt{libudunits2};
to use it, tweak the configuration variables
in \texttt{modules/module-udunits/Makefile.inc}.



