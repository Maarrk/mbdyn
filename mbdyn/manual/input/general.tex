% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2006
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{General}\label{sec:GENERAL}
This chapter describes how data structures are read 
and how they participate, as building blocks, to the definition
of specific cards.
Consistency across the software and the input file has been 
a driving principle in designing the input of MBDyn.
As such, the very same elementary data structures are present
in very different contexts.



\section{Types}



\subsection{Keywords}




\subsection{Strings}
Strings are not so important in MBDyn; however, they may be used
in quite a few significant places, like when parsing file names,
so a few details on their syntax are provided.
Strings are typically delimited by double quotes (").
When a string is requested, the parser looks for the opening 
double quotes and eats up all the white space before it.
Then all characters are read as they are until the closing 
double quotes are encountered.
The escape character is the backslash ($\backslash$); it is used:
\begin{itemize}
	\item to escape the escape character itself ($\backslash$);
	\item to break a string on multiple lines by placing it
		before the newline character (\texttt{$\backslash$n}); in this case,
		the escape character and the newline are eaten up;
	\item to allow the use of non-printing characters,
		represented in the form \texttt{$\backslash$<hexpair>},
		so that the hexadecimal representation of the
		non-printing char is converted into its integer
		equivalent in the 0--255 range.
\end{itemize}



\subsection{Numeric Values}
Every time a numeric value is expected, the result of evaluating 
a mathematical expression can be used, including variable declaration 
and assignment (variable names and values are kept in memory throughout
the input phase and the simulation) and simple math functions.
Named variables and non-named constants are strongly typed; two types are
currently available, \kw{integer} and \kw{real}.
Operations account for the type and perform implicit cast when allowed.
For instance \kw{1+2.5} returns a \kw{real} whose value 
is \kw{3.5}, since one of the 
two addenda is \kw{real}, while \kw{1/3} returns \kw{0} because 
the integer division is used.
An empty field, delimited by a valid separator (a comma or a semicolon,
depending on whether other arguments are expected or not) returns the
(program supplied) default value for that field, if supplied by the caller, 
otherwise the parser automatically defaults to zero.
Multiple expressions can be used, provided they are enclosed in plain 
brackets and are separated by semicolons; the result 
of the last expression will be used as the expected numeric value,
but all the expressions (which may have persistent effects, 
like variable declarations and assignments) will be evaluated.
Example:
\begin{verbatim}
    1.
    (real r = 2.*pi; integer i = 1; sin(i*r*Time+.87))      
\end{verbatim}
the latter results in $ sin\plbr{2\pi{t}+.87} $; 
note that the constant \kw{pi} is always defined
as the machine $ \pi $, as well as the constants \kw{e},
\kw{MAX\_RAND} and more; use
\begin{verbatim}
    mbdyn -H
\end{verbatim}
for an up-to-date list of predefined variables; a typical output
is shown in Figure~\ref{fig:MBDYN-H}.
Of course values are stored with the maximum precision allowed
by the underlying real type (by default, double precision, 64 bit).

\begin{figure}
\label{fig:MBDYN-H}
\centering
\small
\begin{minipage}{120mm}
\begin{verbatim}
user@host:~> mbdyn -H

MBDyn - MultiBody Dynamics 1.2-Engineering
compiled on May 20 2004 at 10:42:24

Copyright 1997-2006 (C) Paolo Mantegazza and Pierangelo Masarati,
Dipartimento di Ingegneria Aerospaziale, Politecnico di Milano.

MBDyn is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Use 'mbdyn --license' to see the conditions.
There is absolutely no warranty for MBDyn.  Use "mbdyn --warranty" for details.

default symbol table:
  real mm2in = 0.0393701
  real lb2kg = 0.4535
  real m2in = 39.3701
  real m2ft = 3.28084
  real in2m = 0.0254
  real in2mm = 25.4
  real pi = 3.14159
  real deg2rad = 0.0174533
  real kg2lb = 2.20507
  real e = 2.71828
  real rad2deg = 57.2958
  int RAND_MAX = 2147483647
  real ft2m = 0.3048

MBDyn terminated normally
user@host:~>
\end{verbatim}
\end{minipage}
\caption{Predefined variables in math parser}
\end{figure}

\noindent
The variable \kw{Time} is declared, defined and initialized\footnote{
    A variable is \kw{declared} when its name enters the namespace;
    it is \kw{defined} when it can be referenced;
    it is \kw{initialized} when it is first assigned a value
} from the beginning of the control data section, and during the solution 
phase it is assigned the value of the current time. 

\noindent
Table~\ref{tab:MATHP-OPERATORS} shows the supported mathematical 
operators, while Table~\ref{tab:MATHP-FUNCTIONS} shows the built-in
mathematical functions.
The supported types are listed in Table~\ref{tab:MATHP-TYPES}.
Table~\ref{tab:MATHP-VARS} lists the predefined variables; notice
that they're treated exactly as user-defined variables, so they 
can be reassigned.

\begin{table}
	\begin{center}
	\caption{Builtin mathematical operators in math parser
	(from higher to lower precedence)}\label{tab:MATHP-OPERATORS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{\emph{Operator}}} & 
		\multicolumn{1}{c}{\textbf{\emph{Type}}} &
		\multicolumn{1}{c}{\textbf{\emph{Description}}} \\
		\hline
		\kw{\^} & Binary, right & Power \\
		\kw{+} & Unary, left & Plus sign \\
		\kw{-} & Unary, left & Minus sign \\
		\kw{*} & Binary, left & Multiplication \\
		\kw{/} & Binary, left & Division \\
		\kw{+} & Binary, left & Addition \\
		\kw{-} & Binary, left & Subtraction \\
		\kw{>} & Binary, left & Greater than \\
		\kw{>=} & Binary, left & Greater than or equal to \\
		\kw{==} & Binary, left & Equal to \\
		\kw{<=} & Binary, left & Less than or equal to \\
		\kw{<} & Binary, left & Less than \\
		\kw{!=} & Binary, left & Not equal \\
		\kw{!} & Unary, right & NOT \\
		\kw{\&\&} & Binary, left & AND \\
		\kw{||} & Binary, left & OR \\
		\kw{{~}|} & Binary, left & XOR (exclusive OR) \\
		\kw{=} & Binary, right & Assignment \\
		\hline
	\end{tabular}
	\end{center}
	\footnotesize
	Note: ``left'' and ``right'' refer to the associativity
	of the operators
\end{table}

\begin{table}
	\begin{center}
	\caption{Builtin mathematical functions 
		in math parser}\label{tab:MATHP-FUNCTIONS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{\emph{Name}}} &
		\multicolumn{1}{c}{\textbf{\emph{Arg[s]}}} &
		\multicolumn{1}{c}{\textbf{\emph{Description}}} \\
		\hline
		\kw{asin} & Real & Arc sine \\
		\kw{acos} & Real & Arc cosine \\
		\kw{atan} & Real & Arc tangent \\
		\kw{actan} & Real & Arc co-tangent \\
		\kw{atan2} & Real, Real & Arc tangent 2 (robust) \\
		\kw{actan2} & Real, Real & Arc co-tangent 2 (robust) \\
		\kw{cos} & Real & Cosine \\
		\kw{sin} & Real & Sine \\
		\kw{tan} & Real & Tangent \\
		\kw{ctan} & Real & Co-tangent \\
		\kw{cosh} & Real & Hyperbolic cosine \\
		\kw{sinh} & Real & Hyperbolic sine \\
		\kw{tanh} & Real & Hyperbolic tangent \\
		\kw{ctanh} & Real & Hyperbolic co-tangent \\
		\kw{acosh} & Real & Hyperbolic arc cosine \\
		\kw{asinh} & Real & Hyperbolic arc sine \\
		\kw{atanh} & Real & Hyperbolic arc tangent \\
		\kw{actanh} & Real & Hyperbolic arc co-tangent \\
		\kw{exp} & Real & Exponential \\
		\kw{log} & Real & Natural logarithm \\
		\kw{log10} & Real & Base 10 logarithm \\
		\kw{sqrt} & Real & Square root \\
		\kw{abs} & Real & Absolute value \\
		\kw{sign} & Real & Sign \\
		\kw{copysign} & Real, Real & First arg with sign of second \\
		\kw{floor} & Real & Closest integer from below \\
		\kw{ceil} & Real & Closest integer from above \\
		\kw{round} & Real & Closest integer \\
		\kw{rand} & & random integer 
			$\sqbr{0,\mathrm{RAND\_MAX}}$ \\
		\kw{random} & & random real $\sqbr{-1.0,1.0}$ \\
		\kw{seed} & Integer & Seeds the random number generator \\
		\kw{step} & Real & Step function \\
		\kw{ramp} & Real & Ramp function \\
		\kw{sramp} & Real, Real & Saturated ramp function \\
		\kw{par} & Real & Parabolic function \\
		\kw{print} & Real & Prints a value to standard output \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Builtin types in math parser}\label{tab:MATHP-TYPES}
	\begin{tabular}{ll}
		\hline
		\multicolumn{1}{c}{\textbf{\emph{Name}}} &
		\multicolumn{1}{c}{\textbf{\emph{Description}}} \\
		\hline
		\kw{Real} & Real number \\
		\kw{Integer} & Integer number (promoted to \kw{Real} 
			whenever required) \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Predefined variables in math parser}\label{tab:MATHP-VARS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{\emph{Name}}} &
		\multicolumn{1}{c}{\textbf{\emph{Type}}} &
		\multicolumn{1}{c}{\textbf{\emph{Value}}} \\
		\hline
		\kw{Time} & Real & Current simulation time \\
		\kw{Val} & Real & Set by dof driver with DOF value \\
		\\
		\kw{e} & Real & Neper's number \\
		\kw{pi} & Real & $\pi$ \\
		\kw{RAND\_MAX} & Integer & Maximum random integer \\
		\\
		\kw{in2m} & Real & Inch to meter ratio (0.0254) \\
		\kw{m2in} & Real & Meter to inch ratio (1.0/0.0254) \\
		\kw{in2mm} & Real & Inch to meter ratio (25.4) \\
		\kw{mm2in} & Real & Meter to inch ratio (1.0/25.4) \\
		\kw{ft2m} & Real & Foot to meter ratio (0.3048) \\
		\kw{m2ft} & Real & Meter to foot ratio (1.0/0.3048) \\
		\kw{lb2kg} & Real & Pound to kilogram ratio (0.4535) \\
		\kw{kg2lb} & Real & Kilogram to pound ratio (1.0/0.4535) \\
		\kw{deg2rad} & Real & Degree to radiant ratio ($\pi$/180) \\
		\kw{rad2deg} & Real & Radiant to degree ratio (180/$\pi$) \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\subsection{Namespaces}
The math parser uses the notion of \emph{namespace} to separate
functions.
The functions listed in Table~\ref{tab:MATHP-FUNCTIONS}
are implicitly defined in the \kw{default} namespace, 
i.e.\ they should be referenced by writing
\begin{verbatim}
    default::sqrt(2.)
\end{verbatim}
Other namespaces may be defined by the user, and loaded by means
of the \kw{module load} card described
in Section~\ref{sec:GENERAL:MODULE-LOAD}.
The namespace that refers to the current model is loaded by default.
Its name is \kw{model}, and contains the functions 
defined in Table~\ref{tab:MODEL-NS-FUNCS}.

\begin{table}
	\begin{center}
	\caption{Mathematical Functions in \kw{model} namespace}
	\label{tab:MODEL-NS-FUNCS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{\emph{Name}}} &
		\multicolumn{1}{c}{\textbf{\emph{Arg[s]}}} &
		\multicolumn{1}{c}{\textbf{\emph{Description}}} \\
		\hline
		\kw{position} & Int & norm of structural node position \\
		\kw{position2} & Int & square norm of structural node position \\
		\kw{xposition} & Int & $X$ component of structural node position \\
		\kw{yposition} & Int & $Y$ component of structural node position \\
		\kw{zposition} & Int & $Z$ component of structural node position \\
		\kw{distance} & Int, Int & distance between structural nodes \\
		\kw{distance2} & Int, Int & square distance between structural nodes \\
		\kw{xdistance} & Int, Int & $X$ component of distance between structural nodes \\
		\kw{ydistance} & Int, Int & $Y$ component of distance between structural nodes \\
		\kw{zdistance} & Int, Int & $Z$ component of distance between structural nodes \\
		\kw{anglerel} & Int, Int & angle between structural nodes (norm of angulr vector) \\
		\kw{xanglerel} & Int, Int & $X$ component of angular vector between structural nodes \\
		\kw{yanglerel} & Int, Int & $Y$ component of angular vector between structural nodes \\
		\kw{zanglerel} & Int, Int & $Z$ component of angular vector between structural nodes \\
		\kw{velocity} & Int & norm of structural node velocity \\
		\kw{velocity2} & Int & square norm of structural node velocity \\
		\kw{xvelocity} & Int & $X$ component of structural node velocity \\
		\kw{yvelocity} & Int & $Y$ component of structural node velocity \\
		\kw{zvelocity} & Int & $Z$ component of structural node velocity \\
		\kw{vrel} & Int, Int & norm of relative velocity between structural nodes \\
		\kw{vrel2} & Int, Int & square norm of relative velocity between structural nodes \\
		\kw{xvrel} & Int, Int & $X$ component of relative velocity between structural nodes \\
		\kw{yvrel} & Int, Int & $Y$ component of relative velocity between structural nodes \\
		\kw{zvrel} & Int, Int & $Z$ component of relative velocity between structural nodes \\
		\hline
	\end{tabular}
	\end{center}
\end{table}


\section{Higher Level Structures}
Every time a higher level structure is expected, it can be
preceded by a keyword that influences how the structure is read.
All of the available structures support the keyword \kw{null}
which causes the structure to be initialized with zeros.
When a non-null value is input, it can be followed by the keyword
\kw{scale} and by a scale factor; the scale factor can be any
mathematical expression.
This is useful to rescale structure values by reassigning the value 
of the scale factor.
The main data structures are:
\subsection{\kw{3 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 3 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized
	with zeros.
\end{enumerate}
As an example, all the following lines define an empty \kw{3 x 1} vector:
\begin{verbatim}
    default
    null
    0.,0.,0.
    ,,
\end{verbatim}
the first case is correct if no default was actually available
for that specific vector, thus falling back to three zeros.
The following rescales an arbitrary vector
\begin{verbatim}
    cos(pi/3.),0.,sin(pi/3.), scale, 100.
\end{verbatim}

\subsection{\kw{6 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 6 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized 
    with zeros.	
\end{enumerate}
\subsection{\kw{3 x 3} matrices}
\begin{enumerate}
    \item general case: a sequence of 9 reals, comma-separated, which
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{32} $, $ a_{33} $.
    \emph{Note: the 9 coefficients can be preceded by the keyword
    \kw{matr} for consistency with other entities; its use is recommended
    whenever an ambiguity is possible.}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 6 reals, comma-separated, that represents the upper triangle, 
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{13} $, $ a_{22} $, $ a_{23} $, $ a_{33} $.
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 3 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix.
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
For example, the identity matrix can be defined as:
\begin{verbatim}
    matr, 1.,0.,0., 0.,1.,0., 0.,0.,1.
    1.,0.,0., 0.,1.,0., 0.,0.,1.
    sym, 1.,0.,0., 1.,0., 1.
    diag, 1.,1.,1.
    eye
\end{verbatim}
\subsection{\kw{3 x 3} orientation matrices}
\begin{enumerate}
    \item general case: two vectors that define an orthonormal reference
    system, each of them preceded by its index in the final orientation 
    matrix. The first vector is normalized and assumed to represent the
    desired direction, while the second simply defines the plane the
    vector that is not given is normal to, e.g.:
    \begin{verbatim}
    1, 1.,0.,0., 2, 0.,1.,0.
    1, (real alpha=pi/6.; 
       cos(alpha)), sin(alpha), 0., 3, 0.,0.,1.
    \end{verbatim}
    the first example represents the identity matrix i.e.\ no rotation 
    occurs with respect to the global reference frame: direction 1
    in the local frame is parallel to \kw{1.,0.,0.} which represents
    direction 1 in the global frame, while direction 2 in the local frame
    is parallel to \kw{0.,1.,0.} which represents direction 2
    in the global frame.

    \noindent
    The second example describes a rotation of $ \pi/6 $ rad.\ about
    global direction 3: direction 1 in the local frame results from 
    composing \kw{cos(pi/6.)} in global direction 1 and \kw{sin(pi/6.)}
    in global direction 2, while direction 3 in the local frame remains
    parallel to \kw{0.,0.,1.} which represents direction 3 in the global
    frame.
    \item a variant of the above, which may be useful when only one
    direction really matters, is illustrated in the example below:
    \begin{verbatim}
    1, 1.,0.,0., 2, guess
    \end{verbatim}
    The keyword \kw{guess} tells the parser to generate a random vector
    that is orthogonal to the given one, which is used as the direction
    indicated by the index.
    The vector is computed based on a very simple algorithm: it contains
    \begin{itemize}
        \item 1.0 corresponding to the index with smallest module,
        $v_1\plbr{\mathrm{min}}$;
	\item $-v_1\plbr{\mathrm{min}}/v_1\plbr{\mathrm{max}}$
	corresponding to the index with the largest module,
	$v_1\plbr{\mathrm{max}}$;
	\item 0.0 on the remaining index.
    \end{itemize}
    \item identity matrix: keyword \kw{eye}; the identity matrix,
    which means there is no rotation with respect to the global reference
    frame.
    \item a complete orientation matrix: keyword \kw{matr}
    followed by the nine, row-oriented, coefficients, namely
    $ r_{11} $, $ r_{12} $, \ldots, $ r_{33} $.
    \emph{Note: no orthogonality check is performed; be sure an orthogonal
    matrix, within the desired tolerance, is input}.
    \item Euler angles: keyword \kw{euler}, followed by the three
    values, as output by structural nodes.
    \emph{Note: the definition of the three angles that are used 
    by the code to express orientations may vary between versions.
    Currently, Bryant-Cardano angles are used in place of Euler
    angles.  The code will remain consistent, i.e. the same angle
    definition will be used for input and output, but models
    over versions may become incompatible, so this syntax should 
    really be used only as a means to quickly reproduce in the input
    an orientation as resulting from a previous analysis.}
\end{enumerate}
\subsection{\kw{6 x 6} matrices}
\begin{enumerate}
    \item general case: a sequence of 36 reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{65} $, $ a_{66} $.
    \item ANBA format: keyword \kw{anba}, followed by 36 reals, 
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the beam section analysis code ANBA,
    namely the following transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \emph{Note: this format is mainly intended for backwards compatibility
    with older versions of that beam section analysis software,
    which used a different numbering convention for the reference frame
    that is local to the beam section.}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 21 reals, comma-separated, that represents the upper triangle,
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{16} $, $ a_{22} $,
    \ldots , $ a_{26} $, \ldots, $ a_{66} $.
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 6 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix.
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
\subsection{\kw{6 x N} matrices}
\begin{enumerate}
    \item general case: a sequence of \kw{6 x N} reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{6\plbr{N-1}} $, $ a_{6N} $.
    \item ANBA format: keyword \kw{anba}, followed by \kw{6 x N} reals,
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the code ANBA, namely the following
    transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}


\section{Input Related Cards} 
(Almost) everywhere in the input file the statement cards defined 
in the following can be used.
They are handled directly by the parsing object, and merely act as
an indirect reference to entities that are not explicitly enumerated.
They are:



\subsection{Constitutive Law}\label{sec:CONSTITUTIVE-LAW}
\begin{verbatim}
    <card> ::= constitutive law : <label>
        [ , name , " <name> " ]
        <dim> , (ConstitutiveLaw<dim>D) <constitutive_law> ;
\end{verbatim}
Constitutive laws are grouped by their dimensionality \kw{<dim>},
which can be any of 1, 3 and 6; the \kw{<constitutive\_law>}
is parsed according to the rules described
in Section~\ref{sec:CONSTITUTIVE-LAWS}.



\subsection{C81 Data}\label{sec:C81-DATA}
This keyword allows to define and read the \kw{c81 data} 
airfoil tables that are used by aerodynamic elements.
\begin{verbatim}
    <card> ::= c81 data : <label> [ , name , " <name> " ]
        " <filename> " [ , fc511 | free format ] ;
\end{verbatim}
The file is in textual form; the format is:
\begin{itemize}
\item first line: \kw{"\%30s\%2d\%2d\%2d\%2d\%2d\%2d"} 
where the first 30 chars are a title string, currently ignored by MBDyn,
followed by 6 two-digit integers that indicate:
	\begin{itemize}
	\item the number \kw{ML} of \emph{Mach} points for $C_l$;
	\item the number \kw{NL} of angle of attack points for $C_l$;
	\item the number \kw{MD} of \emph{Mach} points for $C_d$;
	\item the number \kw{ND} of angle of attack points for $C_d$;
	\item the number \kw{MM} of \emph{Mach} points for $C_m$;
	\item the number \kw{NM} of angle of attack points for $C_m$.
	\end{itemize}
The example in \kw{var/naca0012.c81} contains:
{\small
\begin{verbatim}
PROFILO NACA 0012             11391165 947
\end{verbatim}
}
\item the format of each following line is up to 10 fields of 7 chars each;
records longer than 10 fields are broken on multiple lines,
with the first field filled with blanks;
\item a block containing the $C_l$ data, made of:
	\begin{itemize}
	\item a record with the first field blank, followed by
	the \kw{ML} \emph{Mach} values for the $C_l$;
	\item \kw{NL} records containing the angle of attack
	in the first field, followed by \kw{ML} values of $C_l$
	for each \emph{Mach} number; angles of attack wrap around 
	360 deg, starting from -180.
	\end{itemize}
The example in \kw{var/naca0012.c81} contains 11 \emph{Mach} points
and 39 angle of attack records for $C_l$:
{\small
\begin{verbatim}
       0.     .20    .30    .40    .50    .60    .70    .75    .80
       .90    1.
-180.  0.     0.     0.     0.     0.     0.     0.     0.     0.
       0.     0.
-172.5 .78    .78    .78    .78    .78    .78    .78    .78    .78
       .78    .78
...
\end{verbatim}
}
\item a block containing the $C_d$ data, same as for $C_l$,
with \kw{MD} \emph{Mach} points and \kw{ND} angle of attack records;
\item a block containing the $C_m$ data, same as for $C_l$,
with \kw{MM} \emph{Mach} points and \kw{NM} angle of attack records.
\end{itemize}
An alternative format, required by some projects, can be used by supplying
the optional switch \kw{fc511}; it is not documented.
Finally, to allow higher precision whenever available, a native format,
based on \kw{c81}, is available; it is called \kw{free format} and 
basically consists in the c81 format without continuation lines
and with arbitrary precision, with fields separated by blanks.
The header is made of an arbitrary string, terminated by a semicolon,
followed by the six numbers that define the dimensionality of the expected data.


\subsection{Drive Caller}\label{sec:DRIVE-CALLER}
\begin{verbatim}
    <card> ::= drive caller : <label>
        [ , name , " <name> " ]
        (DriveCaller)<drive_caller> ;
\end{verbatim}
The keyword \kw{drive caller} allows to define
a \hyperref{\kw{drive caller}}{\kw{drive caller} (see Section~}{)}{sec:DRIVE}
that can be subsequently reused.
It is useful essentially in two cases:
\begin{enumerate}
	\renewcommand{\labelenumi}{\alph{enumi})}
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE}
	that will be used many times throughout a model;
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE} 
	that needs to be used in a later defined part of a model, 
	in order to make it parametric.
\end{enumerate}



\subsection{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID}
The \kw{hydraulic fluid} directive:
\begin{verbatim}
    <card> ::= hydraulic fluid : <unique_label> , 
        <fluid_type> , <fluid_properties> ;
\end{verbatim}
allows to define a hydraulic fluid to be later used in hydraulic elements,
see Section~\ref{sec:EL:HYDR}.
The fluid is identified by a numerical label. 
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are
described in \ref{sec:HYDRAULIC-FLUID-DATA}



\subsection{Include}
The \kw{include} directive:
\begin{verbatim}
    <card> ::= include : " <file_name> " ;
\end{verbatim}
where \kw{file\_name} is a valid filename for the operative system in
use, that must be enclosed in double quotes (").
The full (absolute or relative) path must be given if the included file 
is not in the directory of the including one.
There is no check for recursive \kw{include}s, so 
{\bf the user must take care of recursion}.
The \kw{include} directive forces the parser to scan the included file
\kw{file\_name} before continuing with the including one.
This is very useful if, for instance, a big model can be made of many
small models that are meaningful by themselves.
It can be used to replicate parts of the model, by simply using parametric 
labels for nodes, elements, reference systems, and setting a bias value 
before multiple-including the same bulk data file.
Examples of this usage are given in the tutorials
\htmladdnormallink{(\texttt{http://www.aero.polimi.it/\~{}mbdyn/documentation/tutorials/})}
	{http://www.aero.polimi.it/~mbdyn/documentation/tutorials/}.



\subsection{Module Load}\label{sec:GENERAL:MODULE-LOAD}
The \kw{module load} directive:
\begin{verbatim}
    <card> ::= module load : " <file_name> "
        [ , <module_arglist> ] ;
\end{verbatim}
where \kw{file\_name} is the name of a runtime loadable object,
causes the object to be opened, and a function \kw{module\_init},
with prototype
\begin{verbatim}
    int module_init(const char *module_name,
        void *data_manager, void* mbdyn_parser);
\end{verbatim}
to be executed; the function is assumed to perform the operations
required by the module, eventually taking advantage of the parsing
and of the data manager; see the technical manual for details.
The typical use consists in registering some methods for later use;
a clear example is given in
\begin{verbatim}
        modules/module-wheel2/module-wheel2.cc
\end{verbatim}
where the function registers the loadable element in the set
of loadable element handlers which can later be retrieved by using
the syntax described in Section~\ref{sec:EL:BASE:LOADABLE}.
Note, however, that the execution of the \kw{module\_init} function 
may be used for any purpose; typically, to register handlers of any kind
for subsequent use.


\subsection{Reference}
The \kw{reference} directive:
\begin{verbatim}
    <card> ::= reference : <unique_label> , 
        <absolute_position> ,
        <absolute_orientation_matrix> ,
        <absolute_velocity> ,
        <absolute_angular_velocity> ;
\end{verbatim}
A \kw{reference} system is declared and defined.
It must be given a unique identifier, scanned by the math parser
(which means that any regular expression is allowed, and the result is
rounded up to the nearest unsigned integer).
The entries \kw{absolute\_*} are parsed by routines that
compute absolute (i.e.\ referring to the global frame) entities
starting from a given entity in a given reference frame.
These routines are very general, and make intense use of the 
\kw{reference} entries themselves, which means that a reference 
can be recursively defined by means of previously defined 
\kw{reference} entries.

\subsubsection{Use of Reference Frames}
Every time an absolute or a relative geometric or physical entity is
required, it is processed by a set of routines that allow the entity to be
expressed in the desired reference frame.
The following cases are considered:
\begin{itemize}
    \item relative position (physical)
    \item absolute position (physical)
    \item relative orientation matrix (physical)
    \item absolute orientation matrix (physical)
    \item relative velocity (physical)
    \item absolute velocity (physical)
    \item relative angular velocity (physical)
    \item absolute angular velocity (physical)
    \item relative arbitrary vector (geometric)
    \item absolute arbitrary vector (geometric)    
\end{itemize}
The caller is responsible for the final interpretation of the input. 
The caller always supplies the routines a default reference structure
the input must be referred to.
So, depending on the caller, the entry can be in the following forms:
\begin{enumerate}
\item \kw{<entity>}: \\ 
	the data supplied in \kw{<entity>} is intended 
	in the default reference frame
\item \kw{reference , <reference\_type> , <entity>}: \\
	the data is in \kw{<reference\_type>} reference frame, where
\begin{verbatim}
        <reference_type> ::= { global | node | local }
\end{verbatim}
\item \kw{reference , <reference\_number> , <entity>}: \\
	the data is in \kw{reference reference\_number} reference frame. 
	This reference frame must be already defined. 
\end{enumerate}
Examples:
\begin{itemize}
    \item absolute position:
    \begin{verbatim}
    null
    reference, global, null
    reference, 8, 1., sin(.3*pi), log(3.)
    \end{verbatim}
    \item relative orientation matrix (e.g.\ as required by many constraints and
    thus referred to a node):
    \begin{verbatim}
    eye
    reference, node, eye
    reference, 8,
        3, 0., 1., 0., 
        1, .5, sqrt(3)/2., 0.
    \end{verbatim}
\end{itemize}
Notes: 
\begin{itemize}
    \item the global reference frame has position $ \cubr{0, 0, 0} $,
    orientation matrix \kw{eye}, velocity $ \cubr{0, 0, 0} $ and angular
    velocity $ \cubr{0, 0, 0} $.
    \item if the caller is not related to a node, the reference type
    \kw{node} should not be defined. 
    In this case it is considered equivalent to \kw{local}.
    \item when processing a velocity or an angular velocity, the resulting
    value always accounts for the velocity and angular velocity of the frame
    the entry is referred to. 
    As an example, if a node is defined on a reference frame $\T{R}_R$
    that has non-null angular velocity $ \T{\Omega}_R $, and its position 
    $ \T{x}_{input} $ is not in the origin $ \T{X}_R $ of the reference frame
    it is attached to, its global velocity and angular velocity result
    as the composition of the input values and of those of the reference 
    frame:
    \begin{eqnarray*}    
        \T{w} & = & \T{R}_R \T{\omega}_{input} + \T{\Omega}_R \\
	\T{v} & = & \T{R}_R \T{v}_{input} + \T{V}_R
		+\T{\Omega}_R\times\plbr{\T{R}_R \T{x}_{input}}
    \end{eqnarray*}
    This, for instance, eases the input of all the parts of a complex system
    that is moving as a rigid body, by defining a reference frame with the
    proper initial velocities, and then referring all the entities, e.g.\ the 
    nodes, to that frame, with null local velocity.
\end{itemize}  
{\em
    Recalling the declaration and the definition of reference frames,
    a simple reference frame definition, with all the entries referring 
    by default to the global system, would be:
    \begin{verbatim}
    reference: 1000,
        null,
        eye,
        null,
        null;			 
    \end{verbatim}
    which represents a redefinition of the global system.
    A more verbose, and self-explanatory definition would be:
    \begin{verbatim}
    reference: 1000,
        reference, global, null,
        reference, global, eye,
        reference, global, null,
        reference, global, null;			 
    \end{verbatim}
    the reference frame one is referring to must be repeated for all the entries
    since they must be allowed to refer to whatever frame is preferred 
    by the user.
    A fancier definition would be:
    \begin{verbatim}
    reference: Rotating_structure, 
        reference, Fixed_structure, null,
        reference, Spindle_1,
            1, 0.,0.,1., 
            3, 0.,1.,0.,
        reference, Fixed_structure, null,
        reference, Spindle_1, 0.,0.,Omega_1;
    \end{verbatim}
}

\subsubsection{Output}
The reference frames are used only during the input phase, 
where they help referring entities either absolute 
or relative to other entities depending on their internal representation
during the analysis.
As such, reference frames cannot be ``used'' or ``visualized'' neither 
directly nor indirectly at any time during the analysis or by interpreting
the output, because they do not ``evolve'' nor are attached
to any state-dependent entity.
To allow their debugging, however, they can be output in the global
reference frame according to the representation of structural nodes,
as described in Section~\ref{sec:NODE:STRUCTURAL:OUTPUT}, 
by using the \kw{default output} directive 
with the value \kw{reference frames}, as detailed
in Section~\ref{sec:CONTROLDATA:DEFAULTOUTPUT}.



\subsection{Print symbol table}
The \kw{print symbol table} directive:
\begin{verbatim}
    <card> ::= print symbol table ;
\end{verbatim}
allows to print to standard output the contents of the parser's symbol
table at any stage of the input phase.
This may be useful for debugging purposes.



\subsection{Remark}
The \kw{remark} directive:
\begin{verbatim}
    <card> ::= remark : " <remark_string >
        [ , <math_expression> [ , ... ] ] ;
\end{verbatim}
This directive simply prints to stdout the string \kw{remark\_string} and
optionally evaluates any subsequent expression \kw{math\_expression}
according to the \kw{set} directive.
It is used to allow rough input debugging, where the file name and line 
is logged, followed by a message, possibly followed by the evaluation 
of expressions. 
Example:
a file ``remarks'', containing only the statements
\begin{verbatim}
    remark: "square root of 2", sqrt(2);
    set: (
        real EA = 1e6; # N, axial stiffness
        real GA = 1e6; # N, shear stiffness
        real EJ = 1e3; # Nm^2, bending stiffness
        real GJ = 1e3; # Nm^2, torsional stiffness
    0);
    remark: "Stiffness properties", EA, GA, EJ, GJ;
\end{verbatim}
results in
\begin{verbatim}
user@host:~>$ mbdyn -f remarks

MBDyn - Multi-Body Dynamics 1.2.5
compiled on Nov 18 2005 at 15:15:39

Copyright 1996-2006 (C) Paolo Mantegazza and Pierangelo Masarati,
Dipartimento di Ingegneria Aerospaziale <http://www.aero.polimi.it/>
Politecnico di Milano                   <http://www.polimi.it/>

MBDyn is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it
under certain conditions.  Use 'mbdyn --license' to see the conditions.
There is absolutely no warranty for MBDyn.  Use "mbdyn --warranty"
for details.

reading from file "remarks"
registering namespace "default"
line 1, file <remarks>: square root of 2, 1.41421
line 8, file <remarks>: Stiffness properties, 1e+06, 1e+06, 1000, 1000
MBDyn terminated normally
user@host:~>$
\end{verbatim}


\subsection{Set}
The \kw{set} directive:
\begin{verbatim}
    <card> ::= set : <math_expression> ;
\end{verbatim}
This directive simply invokes the math parser to evaluate the expression
\kw{math\_expression} and then discards the result. It can be used
to declare new variables, or to set the values of existing ones.



\subsection{Setenv}
The \kw{setenv} directive:
\begin{verbatim}
    <card> ::= setenv : [ overwrite , ] " <varname> [ = <value> ] " ;
\end{verbatim}
This directive sets the environment variable \kw{<varname>} 
to the value \kw{<value>}, if given; otherwise, the variable
is unset.
If the keyword \kw{overwrite} is set, the variable is overwritten, 
if already set.
\begin{verbatim}
    # set FILE to "test", if it does not exist
    setenv: "FILE=test";
    # set FILE to "test", even if it exists
    setenv: override, "FILE=test";
    # unset FILE
    setenv: "FILE";
    # set FILE to the empty string, if it does not exist
    setenv: "FILE=";
\end{verbatim}
See \kw{setenv(3)} and \kw{unsetenv(3)} man pages for details.



\section{Node Degrees of Freedom}\label{sec:NODEDOF}
A node in MBDyn is nothing but an entity that owns degrees of freedom and
can lend them to other entities. 
Usually elements access nodal degrees of freedom through well-defined
interfaces, at a high level. 
But in a few cases, nodal degrees of freedom must be accessed
at a very low level, with the bare knowledge of the node label,
the node type,
the internal number of the degree of freedom, and the order 
(algebraic or differential, if any).
The data that allows an entity to track a nodal degree of freedom
is read as follows:
\begin{verbatim}
    <node_dof> :: = <node_label> , 
        <node_type> 
        [ , <dof_number> ]
        [ , { algebraic | differential } ]
\end{verbatim}
The label and the type of the node are used to track the pointer to the
desired node. 
If the node is not scalar, the \kw{dof\_number} field is required
to address the appropriate degree of freedom.
Finally, the order of the degree of freedom is checked, if required.
It must be one of \kw{algebraic} or \kw{differential}.
If the \kw{dof\_number} degree of freedom is differential, both
of them can be addressed, while in case of an algebraic node there is no
choice, only the \kw{algebraic} order can be addressed and thus this field
is not required.
The \kw{dof\_number} must range between 1 and the number of \emph{dof}s that
belong to the node.
When the node is used to address an equation (abstract forces, 
discrete control elements), the distinction between \kw{algebraic} 
and \kw{differential} is meaningless, and thus this filed is not required.




\section{Drives and Drive Callers}\label{sec:DRIVE}
Every time some entity can be ``driven'', i.e.\ a value can be
expressed as dependent on some ``external'' input, an object of the class 
\kw{DriveCaller} is used. 
The \kw{drive} essentially represents a scalar function, whose
value can change over time or, through some more sophisticated
means, based on the state of the analysis.
Usually, the dependence over time is implicitly assumed, unless
otherwise specified.
For example, the amplitude of the force applied by a 
\hyperref{\kw{force} element}{\kw{force} element (see Section~}{)}{sec:EL:FORCE}
is defined by means of a \kw{drive}; as such, the value of the \kw{drive} 
is implicitly calculated as a function of the time.
However, a 
\hyperref{\kw{dof drive}}{\kw{dof drive} (see Section~}{)}{sec:DRIVE-DOF}
uses a subordinate \kw{drive} to compute its value based on the value
of a degree of freedom of the analysis; as a consequence,
the value of the \kw{dof drive} is represented by the
value of the subordinate \kw{drive} when evaluated as a function
of that specific degree of freedom at the desired time.

\noindent
The family of the \kw{DriveCaller} object is very large, 
and should require a dedicated chapter.
The type of the \kw{DriveCaller} is declared as follows:
\begin{verbatim}
    <drive_caller> ::=
        { <drive_caller_type> [ , <arglist> ]
            | reference , <label> }
\end{verbatim}    
where \kw{arglist}, if any, is a comma-separated list of arguments
that depends on \kw{drive\_caller\_type}.
As an exception, a constant \kw{DriveCaller} (that behaves exactly as a
numerical constant with little or no overhead depending on the optimizing
capability of the compiler) is assumed when a numeric value is used instead
of a keyword.
If the alternative format is used, the keyword \kw{reference} 
must be followed by the label of an already defined, valid drive caller
(See Section~\ref{sec:DRIVE-CALLER}).

\subsection{Null drive}
\begin{verbatim}
    <drive_caller> ::= null
\end{verbatim}
Zero valued; the \kw{arglist} is empty.

\subsection{Unit drive}
\begin{verbatim}
    <drive_caller> ::= unit
\end{verbatim}
Always 1; the \kw{arglist} is empty.

\subsection{Constant drive}
\begin{verbatim}
    <drive_caller> ::= [ const , ] <const_coef>                    
\end{verbatim}
The keyword \kw{const} can be omitted thus highlighting the real nature
of this driver, that is completely equivalent to a constant, static real
value.

\subsection{Time drive}
\begin{verbatim}
    <drive_caller> ::= time
\end{verbatim}
Yields the current time; the arglist is empty.
  
\subsection{Linear drive}
\begin{verbatim}
    <drive_caller> ::= linear ,
        <const_coef> ,
        <slope_coef>
\end{verbatim}

\subsection{Parabolic drive}
\begin{verbatim}
    <drive_caller> ::= parabolic ,
        <const_coef> , 
        <linear_coef> , 
        <parabolic_coef>
\end{verbatim}

\subsection{Cubic drive}
\begin{verbatim}
    <drive_caller> ::= cubic ,
        <const_coef> , 
        <linear_coef> ,
        <parabolic_coef>, 
        <cubic_coef>
\end{verbatim}

\subsection{Step drive}
\begin{verbatim}
    <drive_caller> ::= step ,
        <initial_time> , 
        <step_value> ,
        <initial_value>
\end{verbatim}    

\subsection{Double step drive}
\begin{verbatim}
    <drive_caller> ::= double step ,
        <initial_time> , 
        <final_time> ,
        <step_value> , 
        <initial_value>
\end{verbatim}

\subsection{Ramp drive}
\begin{verbatim}
    <drive_caller> ::= ramp ,
        <slope> , 
        <initial_time> ,
        { forever | <final_time> } ,
        <initial_value>
\end{verbatim}
  
\subsection{Double ramp drive}
\begin{verbatim}
    <drive_caller> ::= double ramp ,
        <asc_slope> , 
        <asc_initial_time> , 
        <asc_final_time> , 
        <desc_slope> , 
        <desc_initial_time> , 
        { forever | <desc_final_time> } , 
        <initial_value>
\end{verbatim}

\subsection{Piecewise linear drive}
\begin{verbatim}
    <drive_caller> ::= piecewise linear ,
        <num_points> ,
            <point> , <value> 
            [ , ... ]
\end{verbatim}
Piecewise linear function; the first and the last point/value pairs are
extrapolated in case a value beyond the extremes is required.
Linear interpolation between pairs is used.

\subsection{Sine drive}
\begin{verbatim}
    <drive_caller> ::= sine ,
        <initial_time> ,
        <pulsation> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
the value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles}$-1/2$ oscillations are
performed. 
If it is negative, the oscillations end after 
\kw{number\_of\_cycles}$-3/4$ cycles at the top of the sine, with null
tangent.
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
	\item \kw{half}, which means exactly half cycle is performed,
	so the function stops at \kw{amplitude} + \kw{initial\_value}.
\end{itemize}

\subsection{Cosine drive}
\begin{verbatim}
    <drive_caller> ::= cosine ,
        <initial_time> ,
        <pulsation> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
this drive actually computes a function of the type $ 1-\llk{cos}\plbr{x} $.
The value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles} oscillations are
performed.
If it is negative, the oscillations end after
\kw{number\_of\_cycles}$-1/2$ cycles at the top of the cosine, with null
tangent.   
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
	\item \kw{half}, which means exactly half cycle is performed,
	so the function stops at \kw{amplitude} + \kw{initial\_value}.
\end{itemize}

\subsection{Frequency sweep drive}
\begin{verbatim}
    <drive_caller> ::= frequency sweep ,
        <initial_time> ,
        <pulsation_drive> ,
        <amplitude_drive> ,
        <initial_value> ,
        { forever | <final_time> } ,
        <final_value>
\end{verbatim}
this drive recursively calls two other drives that supply the pulsation 
and the amplitude of the oscillation. Any drive can be used.

\subsection{Exponential drive}
\begin{verbatim}
    <drive_caller> ::= exponential ,
        <amplitude_value> ,
        <time_constant_value> ,
        <initial_time> ,
        <initial_value>
\end{verbatim}

\subsection{Random drive}
\begin{verbatim}
    <drive_caller> ::= random ,
        <amplitude_value> ,
        <mean_value> ,
        <initial_time> ,
        { forever | <final_time> }
        [ , steps , <steps_to_hold_value>]
        [ , seed , { time | <seed_value>} ]
\end{verbatim}
the first optional entry, preceded by the keyword \kw{steps}, sets the
number of steps a random value must be held before generating a new
random number. The second optional entry, preceded by the keyword
\kw{seed}, sets the new seed for the random number generator. A numeric
value can be used, or the keyword \kw{time} uses the current time from
the internal clock. A given seed can be used to ensure that two
simulations use exactly the same random sequence (concurrent settings 
are not managed, so it is not very reliable).

\subsection{Meter drive}
The \kw{meter} drive has value zero expect for every \kw{steps} steps,
where it assumes unit value.
\begin{verbatim}
    <drive_caller> ::= meter ,
        <initial_time> ,
        { forever | <final_time> }
        [ , steps , <steps_between_spikes>]
\end{verbatim}
the first optional entry, preceded by the keyword \kw{steps}, sets the
number of steps between spikes.

\subsection{File drive}\label{sec:FILE-DRIVE}
A family of file drivers is being planned.
At present only a multiple-valued, constant time-step file drive is
implemented.
The \kw{DriveCaller} is attached to a file drive object that must be declared
and defined in the \htmlref{\kw{drivers}}{sec:DRIVERS} section 
of the input file (see Section~\ref{sec:DRIVERS}).
\begin{verbatim}
    <drive_caller> ::= file ,
        <drive_label>
        [ , <column_number> ]
        [ , amplitude , <amplitude> ]
\end{verbatim}
\kw{drive\_label} is the label of the \htmlref{\kw{drive}}{sec:DRIVE} 
the \kw{DriveCaller} is attached to, while
\kw{column\_number} is the number of the column the \kw{DriveCaller}
refers to (defaults to 1).
An additional scaling factor \kw{amplitude} can be used to rescale
the drive value (defaults to 1.0).

\subsection{String drive}
\begin{verbatim}
    <drive_caller> ::= string ,
        " <expression_string> "
\end{verbatim}
\kw{expression\_string} is a string, delimited by double quotes.
It is parsed by the math parser every time 
the \htmlref{\kw{drive}}{sec:DRIVE} is invoked.
The variable \kw{Time} is kept up to date and can be used in the 
string to compute the return value.
Another variable, \kw{Var}, is set to the value provided by the caller
in case the drive is called with an explicit argument as, for instance,
in the \hyperref{dof drive}{dof drive (see Section~}{)}{sec:DRIVE-DOF};
e.g.:
\begin{verbatim}
    string, "e^(-Time)*cos(2.*pi*Time)"
\end{verbatim}
generates a cosine modulated by an exponential.


\subsection{Dof drive}\label{sec:DRIVE-DOF}
\begin{verbatim}
    <drive_caller> ::= dof ,
        (node_dof) <driving_dof> ,
        (drive_caller) <func_drive>
\end{verbatim}
a \hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}, 
namely the reference to a degree of freedom of a node, is read. 
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
\htmlref{\kw{node\_dof}}{sec:NODEDOF} as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the displacement
of the node it is applied to) or an active control system; e.g.:
\begin{verbatim}
    dof, 1000, structural, 3, algebraic, 
        linear, 0., 1.
\end{verbatim}
uses the value of the third component (z) of structural node 1000 
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    dof, 1000, abstract, differential, 
        string, "2.*exp(-100.*Var)"
\end{verbatim}
uses the value of the derivative of abstract node 1000 in computing 
a string expression.
Refer to the description of a 
\hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}
entry for further details.

\subsection{Element drive}\label{sec:DRIVE-ELEMENT}
\begin{verbatim}
    <drive_caller> ::= element ,
        <label> ,
        <type>
        [ , { string, "<name>" | index , <index> } ]
        (drive_caller) <func_drive>
\end{verbatim}
a reference to the private data of an element is read.
This is made of: the element's \kw{label}, the element's \kw{type}
and a specification of which private data is being referred;
the \kw{index} can be directly given, prepended by the keyword
\kw{index}, or the symbolic name can be used, prepended by 
the keyword \kw{index}.
If that element allows only one private data, the specification 
can be omitted.
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
element's private data as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the rotation
of a joint) or an active control system; e.g.:
\begin{verbatim}
    element, 1000, joint, name, "rz",
        linear, 0., 1.
\end{verbatim}
uses the value of the rotation about axis $z$ of a revolute hinge
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    element, 1000, joint, index, 1
        string, "2.*exp(-100.*Var)"
\end{verbatim}
uses the same value, addressed in an alternative manner, in computing
a string expression.
The same effect can be obtained by using the element plugin as follows:
\begin{verbatim}
    set: [elem,x,1000,joint,name=rz];
    # ...
    couple: 1, conservative, 1, 0.,0.,1.,
        string, "2.*exp(-100.*x)";
\end{verbatim}
which applies a couple whose amplitude is computed by evaluating
a \kw{string} drive which depends on variable $x$; this, on turn,
is defined as an \kw{element} plugin, which causes its evaluation
in terms of the element's private data at each invocation.

\subsection{Drive drive}
\begin{verbatim}
    <drive_caller> ::= array ,
            <drive_caller1> , 
            <drive_caller2>
\end{verbatim}
This is simply a ``function of function'' drive: the output 
of \kw{drive\_caller2} is fed to \kw{drive\_caller1}
and the result is returned.
Note that the very same thing occurs, for instance, in the
\kw{dof} and in the \kw{element} drives.

\noindent
Example:
\begin{verbatim}
    force: 1, abstract,
        1, abstract,
        drive,
            string, "Var*(Var>0.)",
            sine, 0., 2*pi/.2, 10., forever, 0.;
\end{verbatim}
is equivalent to
\begin{verbatim}
    set: real v;
    force: 1, abstract,
        1, abstract,
        string, "v=sin(5.*2*pi*Time); 10.*v*(v>0)";
\end{verbatim}


\subsection{Array drive}
\begin{verbatim}
    <drive_caller> ::= array ,
        <num_drives> ,
            <drive_caller> 
            [ , <drive_caller> [ , ... ] ]
\end{verbatim}
this is simply a front-end for the linear combination of \kw{num\_drives} 
normal drives; \kw{num\_drives} must be at least 1, in which case 
a simple drive caller is created, otherwise an array of drive callers 
is created and at every call their value is added to give 
the final value of the array drive.


\subsection{Hints}\label{sec:GENERAL:DRIVE:HINT}
In some cases, during the analysis, different entities can be reinitialized
as a consequence of some event, typically triggered by the waking up 
of a so-called \kw{driven} element (See Section~\ref{sec:EL:BASE:DRIVEN}).
The \kw{drive caller} is re-parsed when the entity that owns it is sent
a \kw{hint} of the form
\begin{verbatim}
    "drive{ <drive_caller> }"
\end{verbatim}
is used, where \kw{<drive\_caller} is an arbitrary drive caller specification,
enclosed in double quotes.
Typically, the use of a \kw{hint} is necessary when the specification of the
drive caller parameters depends on the configuration of the system when the
entity that uses it is waken up.
For example, a \kw{distance joint}, an element that enforces the distance
between two nodes, may be waken up by some event.
In the case detailed below, the initial value of the \kw{cosine} drive caller
is computed by extracting the current distance between the nodes at the time
the element is waken up:
\begin{verbatim}
    driven: 1, string, "Time > 10.",
        hint, "drive{cosine, 10., 2., .25, half, model::distance(10, 20)}",
    joint: 1, distance,
        10,
        20,
        const, 1;
\end{verbatim}



\subsection{Template drive}\label{sec:TPL-DRIVE}
A particular \kw{DriveCaller} is the template drive caller. This is made
of a constant entity that multiplies a conventional 
\hyperref{\kw{drive}}{\kw{drive} (see Section~}{)}{sec:DRIVE} to give a drive
entity of dimensionality different from that of a simple scalar \kw{drive}.
there are two types of template drive callers, the \kw{single} template 
drive caller and the \kw{array} template drive caller, 
that is nothing but the sum of an array of \kw{single}
template drive callers. 
They are entered as follows:
\begin{verbatim}
    <tpl_drive_caller> ::= single ,
        <entity> , <drive_caller> 

    <tpl_drive_caller> ::= array ,
        <num_template_drive_callers> ,
        <entity> , <drive_caller>
        [ , <entity> , <drive_caller> [ , ... ] ]
\end{verbatim}
where \kw{entity} is a constant of the expected type (scalar, \kw{3 x 1} 
vector, \kw{6 x 1} vector are the types currently defined, but, since 
a C++ template has been used, the implementation of other ones 
is straightforward).
In case of scalar values, the template reverts by default to a normal 
drive caller, such that no overhead is added.
At least 1 drive caller is expected. 
If \kw{num\_template\_drive\_callers} is exactly 1, only a single
template drive caller is actually constructed, thus avoiding the overhead 
related to the handling of the drive caller array.    

\noindent
Also the \kw{template drive} can be re-parsed; in this case, the syntax
of the \kw{hint} is:
\begin{verbatim}
    "drive<n>{ <entity> , <drive_caller> }"
\end{verbatim}
For example, a \kw{Vec3} drive hint is:
\begin{verbatim}
    "drive3{ 1., 0., 0. , sine, 0., 2*pi, 1., forever, 0.}"
\end{verbatim}



\input{scalarfunctions.tex}


\section{Friction}
Any friction-enabled joint need the definition of
at least a \kw{friction model} and of a \kw{shape function}.
\subsection{Friction models}
The \kw{friction model} input format is:
\begin{verbatim}
    <friction_model> ::= <friction_type> ,
        <friction_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{modlugre}\\
    This friction model is based on 
    Pierre Dupont, Vincent Hayward, Brian Armstrong and
    Friedhelm Altpeter, Single State Elasto-Plastic Friction Models,
    IEEE Transactions on Automatic Control, June 2002. The input format is:
    \begin{verbatim}
    <friction_model> ::= modlugre
    <friction_arglist> ::=
        <sigma0>,
        <sigma1>,
        <sigma2>,
        <kappa>,
        <friction_function>
    <sigma0> ::= <const_value>
    <sigma1> ::= <const_value>
    <sigma2> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    \item \kw{discrete coulomb}\\
    This is a Coulomb model with viscous friction and
    internal states to resolve stick/slip conditions.
    \begin{verbatim}
    <friction_model> ::= discrete coulomb
    <friction_arglist> ::=
        [ sigma2 , <sigma2> , ]
        [ velocity ratio , <vel_ratio> , ]
        <friction_function>
    <sigma2> ::= <const_value>
    <vel_ratio> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    where \kw{sigma2} gives the viscous friction;
    \kw{velocity ratio} defaults to 0.8, and is used
    to discriminate stick/slip conditions
\end{enumerate}
where \kw{friction\_function} give the static friction
as a function of sliding velocity.
\subsection{Shape functions}
A \kw{shape function} input format is:
\begin{verbatim}
    <shape_function> ::= <shape_function_type> ,
        <shape_function_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{simple}\\
    This shape function is equal to one. It does not need arguments.
    \begin{verbatim}
    <shape_function> ::= simple
    <shape_function_arglist> ::=
    \end{verbatim}
    \item \kw{simple plane hinge}
    \begin{verbatim}
    <shape_function> ::= simple plane hinge
    <shape_function_arglist> ::= <radius>
    <radius> ::= <const_value>
    \end{verbatim}
    This is the shape function of a \kw{revolute hinge} with radius equal to 
    \kw{radius} and subject to small loads.
\end{enumerate}
\section{Shapes}
The \kw{shape} entities are objects that return a value depending on one
(or two, for 2D shapes) dimensionless abscissa, ranging $ \sqbr{-1,1} $.
At present, only 1D shapes are used, by aerodynamic elements.
A \kw{shape} input format is:
\begin{verbatim}
    <shape_1D> ::= <shape_type> ,
        <shape_arglist>
\end{verbatim}
The shapes currently available are:
\begin{enumerate}
    \item \kw{const}
    \begin{verbatim}
    <shape_type> ::= const
    <shape_arglist> ::= <const_value>
    \end{verbatim}
    \item \kw{linear}
    \begin{verbatim}
    <shape_type> ::= linear
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_1>
    \end{verbatim}
    \item \kw{piecewise linear}
    \begin{verbatim}
    <shape_type> ::= piecewise linear
    <shape_arglist> ::=
        <number_of_points> , 
            <abscissa> , <value>
            [ , ... ]
    \end{verbatim}
    \item \kw{parabolic}
    \begin{verbatim}
    <shape_type> ::= parabolic
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_0> , 
        <value_at_1>
    \end{verbatim}
\end{enumerate}
This form of input has been chosen since, being the shapes mainly used to
interpolate values, it looks more ``natural'' to insert the mapping values
at characteristic points.
For \kw{piecewise linear} shapes, there must be 
\kw{number\_of\_points} pairs of absciss\ae\ and values; absciss\ae\
must be in the range $\sqbr{-1,1}$, in strict ascending order.


\section{Constitutive Laws}\label{sec:CONSTITUTIVE-LAWS}
Every time a ``deformable'' entity requires a constitutive law, a template
constitutive law is read. This has been implemented by means of C++
templates in order to allow the definition of a general constitutive law
when possible. The ``deformable elements at present are \kw{rod}s, 1D,
\kw{deformable hinge}s and \kw{deformable displacement hinge}s, 3D,  
and \kw{beam}s, 6D.
Some constitutive laws are meaningful only when related to some precise
dimension. 
In some specil cases, general purpose (\kw{genel}) elements 
use 1D constitutive laws to express an arbitrary dependence 
of some value on a scalar state of the system.
Table~\ref{tab:CONST-LAW-DIM} shows the availability of each constitutive law.

\noindent
Usually, constitutive laws can be directly defined when required,
according to the definition of an element.
However, the special card described in Section~\ref{sec:CONSTITUTIVE-LAW}
allows to define constitutive laws stand-alone, and attach them
to the elements by means of the following mechanism:
\begin{verbatim}
    <constitutive_law> ::=
        { <constitutive_law_definition>
            | <constitutive_law_reference> }

    <constitutive_law_reference> ::= reference , <label>
\end{verbatim}
where \kw{<constitutive\_law\_definition>} is described in the following,
while \kw{<label>} is the label of a previously defined constitutive law
of the appropriate dimensionality, as described
in Section~\ref{sec:CONSTITUTIVE-LAW}.



\begin{table}[h]
    \newlength{\constlawwidth}
    \setlength{\constlawwidth}{70mm}
    \centering
    \caption{Constitutive laws dimensionality}\label{tab:CONST-LAW-DIM}
    \begin{tabular}{l|c|c|c} 
        \hline
        \multicolumn{1}{c}{\textbf{\emph{Constitutive Law}}} &
	\multicolumn{1}{c}{\textbf{\emph{1D}}} &
	\multicolumn{1}{c}{\textbf{\emph{3D}}} &
	\multicolumn{1}{c}{\textbf{\emph{6D}}} \\ 
	\hline
	linear elastic, linear elastic isotropic               & x & x & x \\
	linear elastic generic                                 & x & x & x \\
	linear elastic generic axial torsion coupling          &   &   & x \\
	log elastic                                            & x &   &   \\
	linear elastic generic bi-stop                         & x & x & x \\
	double linear elastic                                  & x & x &   \\
	isotropic hardening elastic                            & x & x & x \\
	linear viscous, linear viscous isotropic               & x & x & x \\
	linear viscous generic                                 & x & x & x \\
	linear viscoelastic, linear viscoelastic isotropic     & x & x & x \\
	linear viscoelastic generic                            & x & x & x \\
	linear viscoelastic generic axial torsion coupling     &   &   & x \\
	double linear viscoelastic                             & x & x &   \\
	turbulent viscoelastic                                 & x &   &   \\
	linear viscoelastic generic bi-stop                    & x & x & x \\
	shock absorber                                         & x &   &   \\
	\hline
    \end{tabular}
\end{table}

\noindent 
The constitutive laws are entered as follows:
\begin{verbatim}
    <constitutive_law_definition> ::= <specific_const_law>
        [ , prestress, (entity) <prestress> ]
        [ , prestrain, (entity_tpl_driver) <prestrain> ]
    <specific_const_law> ::= <const_law_name> ,
        <const_law_data>
\end{verbatim}
where \kw{const\_law\_name} is the name of the constitutive law and
\kw{const\_law\_data} depends on the specific constitutive law. 
The latter fields, whose type depends on the dimension of the
constitutive law, are optional, under the assumption that the
constitutive law is the last portion of a card, or that any ambiguity 
can be avoided.
The data specific to the currently available constitutive laws must be
entered as follows:


\subsection{Linear elastic, linear elastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic [ isotropic ] , 
        (scalar) <stiffness>
\end{verbatim}
the isotropic stiffness coefficient; the word \kw{isotropic}
can be omitted, essentially because it has no meaning
for scalar constitutive laws.
Example:
\begin{verbatim}
    constitutive law: 1, name, "scalar isotropic law",
        1, linear elastic, 1.e9;
    constitutive law: 2, name, "3D isotropic law",
        3, linear elastic isotropic, 1.e9;
    constitutive law: 3, name, "6D isotropic law",
        6, linear elastic isotropic, 1.e9;
\end{verbatim}
  
  
\subsection{Linear elastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic generic ,  
        (derivative_of_entity) <stiffness>
\end{verbatim}
the stiffness matrix. In case of 1D, the type is scalar, 
and there is no distinction between \kw{generic} and \kw{isotropic}, 
while, in case of \kw{n x 1} vectors, the type is the corresponding 
\kw{n x n} matrix.
Example:
\begin{verbatim}
    constitutive law: 1, name, "scalar isotropic law",
        1, linear elastic generic, 1.e9;
    constitutive law: 2, name, "3D isotropic law",
        3, linear elastic generic,
            sym, 1.e9,  0.,    0.,
                        1.e6, -1.e5,
                               1.e6;
    constitutive law: 3, name, "6D isotropic law",
        6, linear elastic generic,
            diag, 1.e9, 1.e9, 1.e9, 1.e6, 1.e6, 1.e6;
\end{verbatim}
  

\subsection{Linear elastic generic axial torsion coupling}
\label{sec:CONSTITUTIVE-LAWS:LINEAR-ELASTIC-GENERIC-AXIAL-TORSION-COUPLING}
\begin{verbatim}
    <specific_const_law> ::= 
        linear elastic generic axial torsion coupling ,  
            (derivative_of_entity) <stiffness> ,
            (scalar) <coupling_coefficient>
\end{verbatim}
this is defined only for \kw{6 x 1} vectors, where the torsion stiffness,
coefficient $ a_{44} $ in the stiffness matrix, depends linearly on 
the axial strain, $ \varepsilon_1 $, by means of 
\kw{coupling\_coefficient}, i.e.\ the run-time torsion stiffness is 
\begin{displaymath}
	a_{44} = GJ + \mathtt{coupling\_coefficient} \cdot \varepsilon_1 .
\end{displaymath}
This \kw{<coupling\_coefficient>}, in the classical nonlinear beam theory,
is estimated according to some geometric property \cite{HOUBOLT-BROOKS-1957};
a general approach to the computation of prestressed beam properties
is presented in \cite{BORRI-MERLINI}, which is implemented in some versions
of the ANBA software.

\subsection{Log elastic}
\begin{verbatim}
    <specific_const_law> ::= log elastic ,
        (derivative_of_entity) <stiffness>      
\end{verbatim}
this is defined only for scalars. The force is defined as:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \llk{log}\plbr{1+\varepsilon}
\end{displaymath}
  
\subsection{Linear elastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic bistop,
        (derivative_of_entity) <stiffness> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{Double linear elastic}
\begin{verbatim}
    <specific_const_law> ::= double linear elastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2>
\end{verbatim}
this is defined for scalar and \kw{3 x 1} vectors. In the scalar case the
meaning of the entries is straightforward, while in case of \kw{3 x 1} vectors,
the constitutive law is isotropic but in the local direction 3, where, in
case of strain out of the upper or lower bound, the \kw{stiffness\_2} is
used.

\subsection{Isotropic hardening elastic}
\begin{verbatim}
    <specific_const_law> ::= isotropic hardening elastic ,
        (scalar) <stiffness> ,
        (scalar) <reference_strain>
\end{verbatim}
this constitutive law is defined as follows:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \frac{
        \alpha\shbr{\T{\varepsilon}}^2
    }{
        1+\alpha\shbr{\T{\varepsilon}}^2
    }\varepsilon
\end{displaymath}
where $ \alpha=3/\shbr{\kw{reference\_strain}}^2 $. The resulting
constitutive law, in the scalar case, is somewhat soft when
$ \varepsilon $ is smaller than \kw{reference\_strain}, while it grows to
quasi-linear for higher $ \varepsilon$s

\subsection{Linear viscous, linear viscous isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous [ isotropic ] , 
        (scalar) <viscosity_coefficient>
\end{verbatim}
the linear viscous coefficient. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscous generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous generic , 
        (derivative_of_entity) <viscosity_matrix>
\end{verbatim}
the linear viscous matrix. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscoelastic, linear viscoelastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic [ isotropic ] ,
        (scalar) <stiffness> ,
        { (scalar) <viscosity_coefficient>
        | proportional, (scalar) <factor> }
\end{verbatim}
the isotropic stiffness and viscosity coefficients.
  
\subsection{Linear viscoelastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic generic ,  
        (derivative_of_entity) <stiffness> ,
        { (derivative_of_entity) <viscosity_matrix> 
        | proportional, (scalar) <factor> }
\end{verbatim}
the linear stiffness and viscosity matrices.
  
\subsection{Linear viscoelastic generic axial torsion coupling}
\begin{verbatim}
    <specific_const_law> ::= 
        linear viscoelastic generic axial torsion coupling ,  
            (derivative_of_entity) <stiffness> ,
            { (derivative_of_entity) <viscosity_matrix> 
            | proportional, (scalar) <factor> }
            (scalar) <coupling_coefficient>
\end{verbatim}
this is defined only for \kw{6 x 1} vectors; it is the viscoelastic 
extension of the 
\hyperref{\kw{linear elastic generic axial torsion coupling} constitutive law}{\kw{linear elastic generic axial torsion coupling} constitutive law (see Section~}{)}{sec:CONSTITUTIVE-LAWS:LINEAR-ELASTIC-GENERIC-AXIAL-TORSION-COUPLING}.


\subsection{Double linear viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= double linear viscoelastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2> ,
        (scalar) <viscosity_coefficient>
\end{verbatim}
this is analogous to the \kw{double linear elastic} constitutive law,
except for the isotropic viscosity term.
  
\subsection{Turbulent viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= turbulent viscoelastic ,
        (scalar) <stiffness> ,
        (scalar) <parabolic_viscous_coefficient>
        [ , (scalar) <threshold> 
            [ , (scalar) <linear_viscous_coefficient> ] ]
\end{verbatim}
the constitutive law has the form:
\begin{displaymath}
    \T{f} \ = \ \kw{stiffness} \ \T{\varepsilon} + k \ \dot{\T{\varepsilon}}
\end{displaymath}
where:
\begin{displaymath}
    k = \lcubr{\matr{lcr}{
        \kw{linear\_viscous\_coefficient} & & 
            \shbr{\dot{\T{\varepsilon}}} \leq \kw{threshold} \\
        \kw{parabolic\_viscous\_coefficient} & &
            \shbr{\T{\dot{\varepsilon}}} > \kw{threshold}
    }}
\end{displaymath}
if \kw{threshold} is null, or not defined, the constitutive law is always
parabolic. If the \kw{linear\_viscous\_coefficient} is not defined, it is
computed based on \kw{parabolic\_viscous\_coefficient} and on 
\kw{threshold} to give a continuous force curve (with discontinuous slope).
Otherwise, it can be set by the user to give a discontinuous force curve,
as observed in some fluids at intermediate Reynolds number.

\subsection{Linear viscoelastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic bistop ,
        (derivative_of_entity) <stiffness> ,
        (derivative_of_entity) <viscosity_coefficient> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{GRAALL damper}
This is a very experimental constitutive law, based on a nonlinear model
for a hydraulic damper to be used in landing gear modeling.
Basically, it requires the user to supply the name of the GRAALL-style 
input file with damper data.
It will be documented as soon as it reaches an appreciable level of
stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL-SHOCK-ABSORBER}
constitutive law.


\subsection{shock absorber}\label{sec:CL-SHOCK-ABSORBER}
This constitutive law implements a landing gear hydraulic shock absorber:
\begin{verbatim}
    <specific_const_law> ::= shock absorber ,
        [ prestrain , <value> , ]
        <reference pressure> ,
        <reference area for force computation> ,
        <interaction coefficient> ,
        <polytropic exponent> ,
        [ epsilon max , <upper strain bound> , ]
        [ epsilon min , <lower strain bound> , ]
        [ penalty , <penalty factor for strain> , 
            <penalty factor for strain rate> , ]
        [ metering , <metering area> ,
            [ negative , <metering area for negative strain rate> , ]
        [ orifice , <orifice area> , ]
        <fluid area> ,
        <fluid density> ,
        <drag coefficient / reference length
                (scales strain rate to velocity)>
        [ , friction, <reference epsilon prime> ,
                 <friction amplitude coefficient> ]
\end{verbatim}
where
\begin{itemize}
\item the \kw{interaction coefficient} is represented by
\begin{displaymath}
	\kw{kinematic scale} \frac{L A}{V_0}
\end{displaymath}
where \kw{kinematic scale} is the ratio between the stroke
of the shock absorber and that of the gas;
\item \kw{epsilon max} is the upper strain bound; it must be
at least larger than the prestrain, and defaults to 0,
i.e.\ the shock absorber, at rest, is assumed to be fully
extended;
\item \kw{epsilon min} is the lower strain bound; it must be
at least smaller than the prestrain, and defaults to -0.5, 
i.e.\ the shock absorber is assumed to allow a contraction
equal to half its full length;
\item the \kw{penalty factor for strain} defaults to 1e+9;
it is active only when strain bounds are violated;
\item the \kw{penalty factor for strain rate} defaults to 0;
it is active only when strain bounds are violated;
\item the \kw{metering area} is given by a \kw{drive} 
and is strain dependent; if the keyword \kw{negative} is used, 
then the \kw{metering area for negative strain rate} is used
when the strain rate is negative, i.e.\ the shock absorber
is being compressed, while the \kw{metering area} is used only
when the shock absorber is extending;
\item the \kw{<orifice>} drive determines the area of an
additional orifice, which essentially depends on the sign
of the strain rate; it is used to implement relief valves;
\item ...
\end{itemize}
This constitutive law adds the entities described
in Table~\ref{tab:CL-SHOCK-ABSORBER-OUTPUT} to the output of the
element it is used for.
The table also indicates the names that can be used to reference
the entities as element private data.

\begin{table}
\centering
\caption{Shock absorber output data}\label{tab:CL-SHOCK-ABSORBER-OUTPUT}
\begin{tabular}{ll}
\hline
\multicolumn{1}{c}{\textbf{\emph{entity}}} &
\multicolumn{1}{c}{\textbf{\emph{name}}} \\
\hline
gas pressure	& \kw{p} \\
metering area	& \kw{A} \\
elastic force	& \kw{Fe} \\
viscous force	& \kw{Fv} \\
\hline
\end{tabular}
\end{table}


\section{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID-DATA}
Hydraulic fluid data defines the constitutive properties
of hydraulic fluids, which are generally required by hydraulic elements.
Hydraulic fluid data can be defined in two ways, according to the BNF:
\begin{verbatim}
    <hydraulic_fluid> ::=
        { <fluid_type> , <fluid_properties>
            | reference, <label> }
\end{verbatim}
The latter references a previously defined hydraulic fluid dataset,
described in Section~\ref{sec:HYDRAULIC-FLUID}.
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are:

\subsection{Incompressible}
\begin{verbatim}
    <fluid_type> ::= incompressible
    <fluid_properties> ::=
        [ density , <density> ]
        [ , viscosity , <viscosity> ]
        [ , pressure , <pressure > ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible}
\begin{verbatim}
    <fluid_type> ::= linear compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ]
        [ , viscosity , <viscosity> ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible, with thermal dependency}
\begin{verbatim}
    <fluid_type> ::= linear thermal compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}

\subsection{Super (linearly compressible, with thermal dependency)}
\begin{verbatim}
    <fluid_type> ::= super
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}
according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 + \rho_{ref}\cfrac{1}{2}\plbr{
			1 + \llk{tanh}\plbr{a\plbr{p-p_{ref}}}
		} & p < p_{ref} \\
		+= \ \cfrac{p-p_{ref}}{\beta} & p > p_{ref}
	}
\end{displaymath}
\emph{Note: highly experimental}

\subsection{Exponential compressible fluid, with saturation}
\begin{verbatim}
    <fluid_type> ::= exponential
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> , ]
        [ viscosity , <viscosity> , ]
        <psat>
\end{verbatim}
where \kw{psat} is the saturation pressure, according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 \e{\cfrac{p-p_0}{\beta}} &
		p > p_{sat} \\
		\rho \ = \ \rho_0 \e{1000\cfrac{p-p_0}{\beta}} &
		p < p_{sat}
	}
\end{displaymath}
\emph{Note: this fluid constitutive law is loosely inspired by AMESim's
simply corrected compressible fluid.}



\section{Authentication Methods}
Some authentication methods are defined and made available to specific
program modules; they are used to authenticate before accessing some
resources of the program while it is running.
The syntax is:
\begin{verbatim}
    <authentication_method> ::= <method> [ , <specific_data> ]
\end{verbatim}
Authentication methods in general expect some authentication tokens to be
input.
Usually a user name and a password are required.

\subsection{Note on security and confidentiality}
No encryption is used in communications, unless provided
by the underlying mechanism (e.g. some SASL mechs), 
so the authentication methods are very rough
and should be considered as insecure.
Secure Socket connection or other SSL-like communication protocol
may be considered in the future.
If confidentiality is required, SASL with at least DIGEST-MD5 
is strongly recommended; otherwise no authentication should be used.
As alternatives, a SSH tunnel may be established between the client
and the server machine, and simple authentication can be used.
Otherwise, if the user has direct access to the server where
the computation is being run, sockets with \kw{local} namespace
can be used, and security can be enforced by means of the access
privileges of the socket file.
Since some of the UN*X systems do not honor socket permissions,
a portable way to exploit filesystem access permissions is to put
the socket in a dedicated directory, and use the permissions
of the directory to control access to the socket.

\noindent
Available methods are:
\subsection{No authentication}
\begin{verbatim}
    <authentication_method> ::= no auth
\end{verbatim}

\subsection{Password}
\begin{verbatim}
    <authentication_method> ::= password ,
        user , " <user_name> " ,
        credentials , { prompt | " <user_cred> " }
        [ , salt format , <salt_format> ]
\end{verbatim}
In case the keyword \kw{prompt} is given as credentials, the user is
prompted for a password.
The optional parameter \kw{salt\_format} allows to specify different
formats for the \kw{salt}, for those \kw{crypt(3)} extensions 
that support more sophisticated encryption mechanisms (e.g.\ MD5).
See \kw{crypt(3)} for details.
If the credentials are preceded by the string \kw{\{CRYPT\}},
they are assumed to be already encrypted, and the remaining portion is used.

\subsection{PAM (Pluggable Authentication Modules)}
\begin{verbatim}
    <authentication_method> ::= pam 
        [ , user , " <user_name> " ]
\end{verbatim}
The {\em Linux-PAM} Pluggable Authentication Modules can be used to
authenticate a user. 
If no user name is provided, the effective user id, as provided by the 
\kw{geteuid()} system function, is used to retrieve the username of the
owner of mbdyn process.
the \kw{user} must be valid. 
The authentication is performed through a system-dependent \kw{pam}
configuration file.
No checks on the validity of the account or on the permission of opening a
session are made; account, session and password changes should be explicitly
denied to \kw{mbdyn} to avoid possible security breaks (see the following
example).
The interested reader should consult the documentation that comes with the
package, try for instance
\htmladdnormallink{\kw{http://www.kernel.org/pub/linux/libs/pam/\ }}\
for details.

\noindent
An example is provided with the package, in  \kw{/etc/pam.d/mbdyn}:
\begin{verbatim}
    ### use either of the following:
    auth       required     /lib/security/pam_unix_auth.so
    # auth       required     /lib/security/pam_pwdb.so
    #
    ### no account, session or password allowed
    account    required     /lib/security/pam_deny.so
    session    required     /lib/security/pam_deny.so
    password   required     /lib/security/pam_deny.so
\end{verbatim}
which allows authentication by using standard Un*x or \kw{libpwdb} based
authentication.



\subsection{SASL (Simple Authentication and Security Layer)}
\begin{verbatim}
    <authentication_method> ::= sasl
        [ , user , " <user_name> " ]
        [ , mechanism , " <preferred_mechanism> " ]
\end{verbatim}
This is the preferred authentication method because 
it is mechanism-independent, it can be reasonably secure
and automatically selects the most appropriate mechanism available
on both the client and the server machine.
It requires Cyrus SASL 2 (See 
\htmladdnormallink{\kw{http://asg.web.cmu.edu/sasl/\ }}\
for details, and follow the documentation to obtain a working setup).



\section{Miscellaneous}
Finally there are some miscellaneous points:
\begin{itemize}
    \item (UN*X systems) Environment variables whose name starts with MBDYN may
    be defined and passed to an execution of the mbdyn command.
    The following are recognized at present:
  
    \begin{enumerate}
  
        \item \kw{MBDYNVARS=<expr\_list>}
	where \kw{expr\_list} is a series of mathematical expressions
	separated by semicolons. 
	They are parsed and evaluated; if variables are declared, they are
	added to the symbol table to be used during the whole execution 
	of the program.
    
        \item \kw{MBDYN\_<type>\_<name>=<value>},
	where \kw{type} is a legal mbdyn type (\kw{integer} or \kw{real};
	see Table~\ref{tab:MATHP-TYPES} for details),
	\kw{name} is a legal symbol name and \kw{value} is a legal
	mathematical expression.
    
    \end{enumerate}
    
    \item Newlines and indentations are not meaningful. But good indentation
    habits can lead to better and more readable input files.
    
    \item Everything that follows the character \kw{`\#'} is considered a
    remark, and is discarded until the end of the line. 
    This can occur everywhere in the file, even inside a math expression 
    (if any problems occur, please let me know, because chances are 
    it is a bug!)
    
    \item A new style for comments has been introduced, resembling the 
    C programming language style: everything comprised between the marks
    \kw{/*} and \kw{*/} is regarded as a remark:
\begin{verbatim}
    /*
     * useful comments make input files readable!
     */
\end{verbatim}
    This can happen (almost) everywhere in the text except in the middle 
    of a keyword.
    
    \item (UN*X systems) Whenever a file name contains a portion
    of the form \verb;$VARNAME; or \verb;${VARNAME};, appropriate
    expansion from environment is performed; \verb;VARNAME; is
\begin{verbatim}
    VARNAME ::= [_a-zA-Z][_a-zA-Z0-9]*
\end{verbatim}
    namely, it must begin with a letter or an underscore, and can be
    made of underscores, letters and digits.

    \item (UN*X systems) Whenever a file name is required, the shell-like
    syntax for home directories (i.e.\ \verb1~/filename1
    or \verb1~user/filename1 is automatically resolved if legal [user and]
    filename values are inserted.
    Home expansion occurs after environment variable expansion (see above).

    \item The \kw{license} and the \kw{warranty} statements
    respectively show on the standard output the license 
    and the warranty statement under which the code is released.
    They do not affect the simulation.
    
\end{itemize}
 
