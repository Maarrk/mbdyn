% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2009
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{General}\label{sec:GENERAL}
This chapter describes how data structures are read 
and how they participate, as building blocks, to the definition
of specific cards.
Consistency across the software and the input file has been 
a driving principle in designing the input of MBDyn.
As such, the very same elementary data structures are present
in very different contexts.



\section{Types}



\subsection{Keywords}
In MBDyn there are a lot of so-called ``keywords'':
they appear literarly in the input file, they are case-insensitive
and may have an arbitrary amount of space in between (for example,
\kw{control data} and \kw{controldata} are equivalent).

However, they mostly are context-dependent, so they are not illustrated
altogether in a dedicated section, but rather presented in relation
to the contexts they may appear in.




\subsection{Strings}
Strings are not so important in MBDyn; however, they may be used
in quite a few significant places, like when parsing file names,
so a few details on their syntax are provided.
Strings are typically delimited by double quotes (").
When a string is requested, the parser looks for the opening 
double quotes and eats up all the white space before it.
Then all characters are read as they are until the closing 
double quotes are encountered.
The escape character is the backslash ($\backslash$); it is used:
\begin{itemize}
	\item to escape the escape character itself ($\backslash$);
	\item to break a string on multiple lines by placing it
		before the newline character (\texttt{$\backslash$n}); in this case,
		the escape character and the newline are eaten up;
	\item to allow the use of non-printing characters,
		represented in the form \texttt{$\backslash$<hexpair>},
		so that the hexadecimal representation of the
		non-printing char is converted into its integer
		equivalent in the 0--255 range.
\end{itemize}



\subsection{Numeric Values}
Every time a numeric value is expected, the result of evaluating 
a mathematical expression can be used, including variable declaration 
and assignment (variable names and values are kept in memory throughout
the input phase and the simulation) and simple math functions.
Named variables and non-named constants are strongly typed; two types are
currently available, \kw{integer} and \kw{real}.
Operations account for the type and perform implicit cast when allowed.
For instance \kw{1+2.5} returns a \kw{real} whose value 
is \kw{3.5}, since one of the 
two addenda is \kw{real}, while \kw{1/3} returns \kw{0} because 
the integer division is used.
An empty field, delimited by a valid separator (a comma or a semicolon,
depending on whether other arguments are expected or not) returns the
(program supplied) default value for that field, if supplied by the caller, 
otherwise the parser automatically defaults to zero.
Multiple expressions can be used, provided they are enclosed in plain 
brackets and are separated by semicolons; the result 
of the last expression will be used as the expected numeric value,
but all the expressions (which may have persistent effects, 
like variable declarations and assignments) will be evaluated.

\paragraph{Example.} \
\begin{verbatim}
    1.
    (real r = 2.*pi; integer i = 1; sin(i*r*Time+.87))      
\end{verbatim}
the latter results in $ sin\plbr{2\pi{t}+.87} $; 
note that the constant \kw{pi} is always defined
as the machine $ \pi $, as well as the constants \kw{e},
\kw{MAX\_RAND} and more; use
\begin{verbatim}
    mbdyn -H
\end{verbatim}
for an up-to-date list of predefined variables; a typical output
is shown in Figure~\ref{fig:MBDYN-H}.
Of course values are stored with the maximum precision allowed
by the underlying real type (by default, double precision, 64 bit).

\begin{figure}
\label{fig:MBDYN-H}
\centering
\small
\begin{minipage}{120mm}
\begin{verbatim}
user@host:~> mbdyn -H

MBDyn - MultiBody Dynamics 1.2-Engineering
compiled on May 20 2004 at 10:42:24

Copyright 1997-2009 (C) Paolo Mantegazza and Pierangelo Masarati,
Dipartimento di Ingegneria Aerospaziale, Politecnico di Milano.

MBDyn is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Use 'mbdyn --license' to see the conditions.
There is absolutely no warranty for MBDyn.  Use "mbdyn --warranty" for details.

default symbol table:
  real mm2in = 0.0393701
  real lb2kg = 0.4535
  real m2in = 39.3701
  real m2ft = 3.28084
  real in2m = 0.0254
  real in2mm = 25.4
  real pi = 3.14159
  real deg2rad = 0.0174533
  real kg2lb = 2.20507
  real e = 2.71828
  real rad2deg = 57.2958
  int RAND_MAX = 2147483647
  real ft2m = 0.3048

MBDyn terminated normally
user@host:~>
\end{verbatim}
\end{minipage}
\caption{Predefined variables in math parser}
\end{figure}

The variable \kw{Time} is declared, defined and initialized\footnote{
    A variable is \kw{declared} when its name enters the namespace;
    it is \kw{defined} when it can be referenced;
    it is \kw{initialized} when it is first assigned a value
} from the beginning of the control data section, and during the solution 
phase it is assigned the value of the current time. 

Table~\ref{tab:MATHP-OPERATORS} shows the supported mathematical 
operators, while Table~\ref{tab:MATHP-FUNCTIONS} shows the built-in
mathematical functions.
The supported types are listed in Table~\ref{tab:MATHP-TYPES}.
Table~\ref{tab:MATHP-VARS} lists the predefined variables; notice
that they're treated exactly as user-defined variables, so they 
can be reassigned.

\begin{table}
	\begin{center}
	\caption{Built-in mathematical operators in math parser
	(from higher to lower precedence)}\label{tab:MATHP-OPERATORS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{Operator}} & 
		\multicolumn{1}{c}{\textbf{Type}} &
		\multicolumn{1}{c}{\textbf{Description}} \\
		\hline
		\kw{\^} & Binary, right & Power \\
		\kw{+} & Unary, left & Plus sign \\
		\kw{-} & Unary, left & Minus sign \\
		\kw{*} & Binary, left & Multiplication \\
		\kw{/} & Binary, left & Division \\
		\kw{+} & Binary, left & Addition \\
		\kw{-} & Binary, left & Subtraction \\
		\kw{>} & Binary, left & Greater than \\
		\kw{>=} & Binary, left & Greater than or equal to \\
		\kw{==} & Binary, left & Equal to \\
		\kw{<=} & Binary, left & Less than or equal to \\
		\kw{<} & Binary, left & Less than \\
		\kw{!=} & Binary, left & Not equal \\
		\kw{!} & Unary, right & NOT \\
		\kw{\&\&} & Binary, left & AND \\
		\kw{||} & Binary, left & OR \\
		\kw{\~{}|} & Binary, left & XOR (exclusive OR) \\
		\kw{=} & Binary, right & Assignment \\
		\hline
	\end{tabular}
	\end{center}
	\footnotesize
	Note: ``left'' and ``right'' refer to the associativity
	of the operators. \\
	Note: the \kw{String} type only supports the binary ``+'' operator.
\end{table}

\begin{table}
	\begin{center}
	\caption{Built-in mathematical functions 
		in math parser}\label{tab:MATHP-FUNCTIONS}
	\begin{tabular}{llll}
		\hline
		\multicolumn{1}{c}{\textbf{Name}} &
		\multicolumn{1}{c}{\textbf{Returns}} &
		\multicolumn{1}{c}{\textbf{Arg[s]}} &
		\multicolumn{1}{c}{\textbf{Description}} \\
		\hline
		\kw{asin}	& Real		& Real		& Arc sine \\
		\kw{acos}	& Real		& Real		& Arc cosine \\
		\kw{atan}	& Real		& Real		& Arc tangent \\
		\kw{actan}	& Real		& Real		& Arc co-tangent \\
		\kw{atan2}	& Real		& Real, Real	& (Robust) arc tangent \\
		\kw{actan2}	& Real		& Real, Real	& (Robust) arc co-tangent \\
		\kw{cos}	& Real		& Real		& Cosine \\
		\kw{sin}	& Real		& Real		& Sine \\
		\kw{tan}	& Real		& Real		& Tangent \\
		\kw{ctan}	& Real		& Real		& Co-tangent \\
		\kw{cosh}	& Real		& Real		& Hyperbolic cosine \\
		\kw{sinh}	& Real		& Real		& Hyperbolic sine \\
		\kw{tanh}	& Real		& Real		& Hyperbolic tangent \\
		\kw{ctanh}	& Real		& Real		& Hyperbolic co-tangent \\
		\kw{acosh}	& Real		& Real		& Hyperbolic arc cosine \\
		\kw{asinh}	& Real		& Real		& Hyperbolic arc sine \\
		\kw{atanh}	& Real		& Real		& Hyperbolic arc tangent \\
		\kw{actanh}	& Real		& Real		& Hyperbolic arc co-tangent \\
		\kw{exp}	& Real		& Real		& Exponential \\
		\kw{log}	& Real		& Real		& Natural logarithm \\
		\kw{log10}	& Real		& Real		& Base 10 logarithm \\
		\kw{sqrt}	& Real		& Real		& Square root \\
		\kw{abs}	& Real		& Real		& Absolute value \\
		\kw{sign}	& Real		& Real		& Sign \\
		\kw{copysign}	& Real		& Real, Real	& First arg with sign of second \\
		\kw{floor}	& Integer	& Real		& Closest integer from below \\
		\kw{ceil}	& Integer	& Real		& Closest integer from above \\
		\kw{round}	& Integer	& Real		& Closest integer \\
		\kw{rand}	& Integer	& Void		& random integer 
			$\sqbr{0,\mathrm{RAND\_MAX}}$ \\
		\kw{random}	& Real		& Void		& random real $\sqbr{-1.0,1.0}$ \\
		\kw{seed}	& Void		& Integer	& Seeds the random number generator \\
		\kw{step}	& Real		& Real		& Step function \\
		\kw{ramp}	& Real		& Real		& Ramp function \\
		\kw{sramp}	& Real		& Real, Real	& Saturated ramp function \\
		\kw{par}	& Real		& Real		& Parabolic function \\
		\kw{print}	& Void		& Real		& Prints a value to standard output \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Built-in types in math parser}\label{tab:MATHP-TYPES}
	\begin{tabular}{ll}
		\hline
		\multicolumn{1}{c}{\textbf{Name}} &
		\multicolumn{1}{c}{\textbf{Description}} \\
		\hline
		\kw{Bool} & Boolean number (promoted to \kw{Integer}, \kw{Real},
			or \kw{String} (0 or 1), whenever required) \\
		\kw{Integer} & Integer number (promoted to \kw{Real}, or \kw{String},
			whenever required) \\
		\kw{Real} & Real number (promoted to \kw{String}
			whenever required) \\
		\kw{String} & Text string \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Predefined variables in math parser}\label{tab:MATHP-VARS}
	\begin{tabular}{lll}
		\hline
		\multicolumn{1}{c}{\textbf{Name}} &
		\multicolumn{1}{c}{\textbf{Type}} &
		\multicolumn{1}{c}{\textbf{Value}} \\
		\hline
		\kw{Time} & Real & Current simulation time \\
		\kw{Var} & Real & Set by dof driver with DOF value \\
		\\
		\kw{e} & Real & Neper's number \\
		\kw{pi} & Real & $\pi$ \\
		\kw{RAND\_MAX} & Integer & Maximum random integer \\
		\\
		\kw{in2m} & Real & Inch to meter ratio (0.0254) \\
		\kw{m2in} & Real & Meter to inch ratio (1.0/0.0254) \\
		\kw{in2mm} & Real & Inch to meter ratio (25.4) \\
		\kw{mm2in} & Real & Meter to inch ratio (1.0/25.4) \\
		\kw{ft2m} & Real & Foot to meter ratio (0.3048) \\
		\kw{m2ft} & Real & Meter to foot ratio (1.0/0.3048) \\
		\kw{lb2kg} & Real & Pound to kilogram ratio (0.4535) \\
		\kw{kg2lb} & Real & Kilogram to pound ratio (1.0/0.4535) \\
		\kw{deg2rad} & Real & Degree to radian ratio ($\pi$/180) \\
		\kw{rad2deg} & Real & Radian to degree ratio (180/$\pi$) \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\subsection{Namespaces}
\label{sec:GENERAL:NAMESPACE}
The math parser uses the notion of \emph{namespace} to separate
functions.
The functions listed in Table~\ref{tab:MATHP-FUNCTIONS}
are implicitly defined in the \kw{default} namespace, 
i.e.\ they should be referenced by writing
\begin{verbatim}
    default::sqrt(2.)
\end{verbatim}
Other namespaces may be defined by the user, and loaded by means
of the \kw{module load} card described
in Section~\ref{sec:GENERAL:MODULE-LOAD}.
The namespace that refers to the current model is loaded by default.
Its name is \kw{model}, and contains the functions 
defined in Table~\ref{tab:MODEL-NS-FUNCS}.

\begin{table}
	\begin{center}
	\caption{Functions in \kw{model} namespace}
	\label{tab:MODEL-NS-FUNCS}
	\begin{tabular}{lllp{.6\textwidth}}
		\hline
		\multicolumn{1}{c}{\textbf{Name}} &
		\multicolumn{1}{c}{\textbf{Ret.}} &
		\multicolumn{1}{c}{\textbf{Arg[s]}} &
		\multicolumn{1}{c}{\textbf{Description}} \\
		\hline
		\kw{position}	& Real	& Integer		& norm of structural node position \\
		\kw{position2}	& Real	& Integer		& square norm of structural node position \\
		\kw{xposition}	& Real	& Integer		& $X$ component of structural node position \\
		\kw{yposition}	& Real	& Integer		& $Y$ component of structural node position \\
		\kw{zposition}	& Real	& Integer		& $Z$ component of structural node position \\
		\kw{distance}	& Real	& Integer, Integer	& distance between structural nodes \\
		\kw{distance2}	& Real	& Integer, Integer	& square distance between structural nodes \\
		\kw{xdistance}	& Real	& Integer, Integer	& $X$ component of distance between structural nodes \\
		\kw{ydistance}	& Real	& Integer, Integer	& $Y$ component of distance between structural nodes \\
		\kw{zdistance}	& Real	& Integer, Integer	& $Z$ component of distance between structural nodes \\
		\kw{xunitvec}	& Real	& Integer, Integer	& $X$ component of unit vector between structural nodes \\
		\kw{yunitvec}	& Real	& Integer, Integer	& $Y$ component of unit vector between structural nodes \\
		\kw{zunitvec}	& Real	& Integer, Integer	& $Z$ component of unit vector between structural nodes \\
		\kw{anglerel}	& Real	& Integer, Integer	& angle between structural nodes (norm of angular vector) \\
		\kw{xanglerel}	& Real	& Integer, Integer	& $X$ component of angular vector between structural nodes \\
		\kw{yanglerel}	& Real	& Integer, Integer	& $Y$ component of angular vector between structural nodes \\
		\kw{zanglerel}	& Real	& Integer, Integer	& $Z$ component of angular vector between structural nodes \\
		\kw{velocity}	& Real	& Integer		& norm of structural node velocity \\
		\kw{velocity2}	& Real	& Integer		& square norm of structural node velocity \\
		\kw{xvelocity}	& Real	& Integer		& $X$ component of structural node velocity \\
		\kw{yvelocity}	& Real	& Integer		& $Y$ component of structural node velocity \\
		\kw{zvelocity}	& Real	& Integer		& $Z$ component of structural node velocity \\
		\kw{vrel}	& Real	& Integer, Integer	& norm of relative velocity between structural nodes \\
		\kw{vrel2}	& Real	& Integer, Integer	&
				square norm of relative velocity between structural nodes \\
		\kw{xvrel}	& Real	& Integer, Integer	&
				$X$ component of relative velocity between structural nodes \\
		\kw{yvrel}	& Real	& Integer, Integer	&
				$Y$ component of relative velocity between structural nodes \\
		\kw{zvrel}	& Real	& Integer, Integer	&
				$Z$ component of relative velocity between structural nodes \\
		\kw{drive}	& Real	& Integer, Real		&
				evaluates the \htmlref{\kw{drive caller}}{sec:DRIVE-CALLER}
				indicated by its label (the first argument)
				for the input specified as second argument \\
		\kw{sf::<name>}	& Real	& Real			&
				evaluates the \htmlref{\kw{scalar function}}{sec:SCALARFUNCS}
				\kw{<name>} for the input specified as argument \\
		\hline
	\end{tabular}
	\end{center}
\end{table}


\subsection{Plugin Variables}
\label{sec:GENERAL:PLUGIN}
Plugin variables, or plugins, as the name states, are pluggable extensions
to the math parser that allow to register mechanisms to bind a variable
to some means to dynamically generate its value.
As a consequence, any time a variable declared as part of a plugin
is used, its value is dynamically evaluated executing the related code.

There are built-in plugins that allow to link variables to the value
of degrees of freedom and to special parameters computed by nodes
and elements.

The syntax of a plugin consists in specially defining a variable
so that it gets registered to the appropriate code:
\begin{verbatim}
    set: OSQBR <plugin> , <var> [ , <arglist> ] CSQBR ;
    <arglist> ::= <arg1> [ , ... ]
\end{verbatim}
where \kw{OSQBR} and \kw{CSQBR} stand for ``open'' and ``close''
square brackets, respectively, which shouldn't be confused with those
that indicate optional parameters.

In the following, the built-in plugins\footnote{Built-in and plug-in
may sound contradictory, and in fact they are.  However, consider
that the mathematical parser is essentially independent of MBDyn
(in fact, it has been turned into a command-line calculator
in \kw{cl(1)}), so, from this point of view, built-in plug-ins
are used to plug MBDyn information into an independent, lower-level
piece of code.} are illustrated.
For details on nodes, elements, their properties and the information
they can expose, see the related sections.

\subsubsection{Dof plugin}
\emph{Note: this plugin is now obsoleted by the \kw{node} plugin,
which allows to access more significant information about nodes,
including the value of the degrees of freedom.}

The \kw{dof} plugin allows to link a variable to a specific degree of freedom
of a node, or to its derivative, whenever defined.
The syntax is
\begin{verbatim}
    <plugin> ::= dof
    <arglist> ::= <label> , <type> [ , <index> ] , { algebraic | differential }
\end{verbatim}
where
\kw{label} is the label of the node,
\kw{type} is the node type,
\kw{index} is the index of the degree of freedom that is requested,
if the node has more than one, while
\kw{algebraic} and \kw{differential} refer to the value of the dof
and of its derivative, respectively.
The derivative can be requested only for those degrees of freedom
that have one.

\paragraph{Example.} \
The variable \kw{VARNAME} takes the value of the derivative
of \kw{abstract} node \kw{NODENAME}
\begin{verbatim}
    set: integer NODENAME = 1000;
    # the node must exist
    set: [dof,VARNAME,NODENAME,abstract,differential];
\end{verbatim}



\subsubsection{Node plugin}
The \kw{node} plugin allows to link a variable to any data a node
can expose, including the values of their degrees of freedom.
The syntax is
\begin{verbatim}
    <plugin> ::= node
    <arglist> ::= <label> , <type>
        [ , { [ index= ] <index> | string= <name> } ]
\end{verbatim}
where
\kw{label} is the label of the node,
\kw{type} is the node type,
and the mutually exclusive \kw{index} and \kw{name} represent the index
of the datum that is requested, where \kw{name} is a user-friendly
representation of the actual index.
The \kw{index} form is the default; however, the \kw{name} form is recommended.
Note that \kw{name} can be enclosed in double quotes,
although not strictly required.
In fact, some node types allow names that include square brackets.
In those cases, double-quote enclosing is needed to avoid parsing errors,
since closing square brackets indicate the end
of the plugin variable specification.

\paragraph{Example.} \
This implements the same variable defined in the \kw{dof} example,
where the variable \kw{VARNAME} takes the value of the derivative
of \kw{abstract} node \kw{NODENAME}
\begin{verbatim}
    set: integer NODENAME = 1000;
    # the node must exist
    set: [node,VARNAME,NODENAME,abstract,string,"xP"];
\end{verbatim}



\subsubsection{Element plugin}
The \kw{element} plugin allows to link a variable to any data an element
can expose, including the values of their degrees of freedom.
The syntax is
\begin{verbatim}
    <plugin> ::= element
    <arglist> ::= <label> , <type>
        [ , { [ index= ] <index> | string= <name> } ]
\end{verbatim}
where
\kw{label} is the label of the element,
\kw{type} is the element type,
and the mutually exclusive \kw{index} and \kw{name} represent the index
of the datum that is requested, where \kw{name} is a user-friendly
representation of the actual index.
The \kw{index} form is the default; however, the \kw{name} form is recommended.
Note that \kw{name} can be enclosed in double quotes,
although not strictly required.
In fact, some node types allow names that include square brackets.
In those cases, double-quote enclosing is needed to avoid parsing errors,
since closing square brackets indicate the end
of the plugin variable specification.

\paragraph{Example.} \
The variable \kw{VARNAME} takes the value of the $z$ component 
of the reaction force of \kw{joint} \kw{ELEMNAME}
\begin{verbatim}
    set: integer ELEMNAME = 1000;
    # the joint must exist
    set: [element,VARNAME,ELEMNAME,joint,string,"Fz"];
\end{verbatim}



\section{Higher-Order Math Structures}
Every time a higher-order mathematical structure is expected, it can be
preceded by a keyword that influences how the structure is read.
All of the available structures support the keyword \kw{null}
which causes the structure to be initialized with zeros.
When a non-null value is input, it can be followed by the keyword
\kw{scale} with a scale factor; the scale factor can be any
mathematical expression.
This is useful to rescale structure values by reassigning the value 
of the scale factor.
The main data structures are:
\subsection{\kw{3 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 3 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized
	with zeros.
\end{enumerate}
As an example, all the following lines define an empty \kw{3 x 1} vector:
\begin{verbatim}
    default
    null
    0.,0.,0.
    ,,
\end{verbatim}
the first case is correct if no default was actually available
for that specific vector, thus falling back to three zeros.
The following rescales an arbitrary vector
\begin{verbatim}
    cos(pi/3.),0.,sin(pi/3.), scale, 100.
\end{verbatim}

\subsection{\kw{6 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 6 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized 
    with zeros.	
\end{enumerate}
\subsection{\kw{3 x 3} matrices}
\begin{enumerate}
    \item general case: a sequence of 9 reals, comma-separated, which
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{32} $, $ a_{33} $.
    \emph{Note: the 9 coefficients can be preceded by the keyword
    \kw{matr} for consistency with other entities; its use is recommended
    whenever an ambiguity is possible.}
\begin{equation}
	\T{m} = \sqbr{\matr{ccc}{
		a_{11} & a_{12} & a_{13} \\
		a_{21} & a_{22} & a_{23} \\
		a_{31} & a_{32} & a_{33}
	}}
\end{equation}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 6 reals, comma-separated, that represents the upper triangle, 
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{13} $, $ a_{22} $, $ a_{23} $, $ a_{33} $.
\begin{equation}
	\T{m} = \sqbr{\matr{ccc}{
		a_{11} & a_{12} & a_{13} \\
		a_{12} & a_{22} & a_{23} \\
		a_{13} & a_{23} & a_{33}
	}}
\end{equation}
    \item skew symmetric matrix: keyword \kw{skew}, followed by a sequence
    of 3 reals, comma-separated, that are the components of the vector $\T{v}$
    that generates a skew symmetric matrix $\T{m}=\T{v}\times{}$:
\begin{equation}
	\T{m} = \sqbr{\matr{ccc}{
		0 & -v_3 & v_2 \\
		v_3 & 0 & -v_1 \\
		-v_2 & v_1 & 0
	}}
\end{equation}
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 3 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix, namely $a_{11}$, $a_{22}$, $a_{33}$
\begin{equation}
	\T{m} = \sqbr{\matr{ccc}{
		a_{11} & 0 & 0 \\
		0 & a_{22} & 0 \\
		0 & 0 & a_{33}
	}}
\end{equation}
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
For example, the identity matrix can be defined as:
\begin{verbatim}
    matr, 1.,0.,0.,  0.,1.,0.,  0.,0.,1.
    1.,0.,0.,  0.,1.,0.,  0.,0.,1.        # ``matr'' omitted
    sym, 1.,0.,0.,  1.,0.,  1.            # upper triangular part
    diag, 1.,1.,1.                        # diagonal
    eye                                   # a la matlab
\end{verbatim}
Although not required, for better readability it is recommended to format
the above data as
\begin{verbatim}
    matr,
        1.,0.,0.,
        0.,1.,0.,
        0.,0.,1.
    1.,0.,0.,
    0.,1.,0.,
    0.,0.,1.                              # ``matr'' omitted
    sym,
        1.,0.,0.,
           1.,0.,
              1.                          # upper triangular part
    diag, 1.,1.,1.                        # diagonal
    eye                                   # a la matlab
\end{verbatim}
\subsection{\kw{3 x 3} orientation matrices}
\begin{enumerate}
    \item general case: two vectors that define an orthonormal reference
    system, each of them preceded by its index in the final orientation 
    matrix. The first vector is normalized and assumed to represent the
    desired direction, while the second simply defines the plane the
    vector that is not given is normal to, e.g.:
    \begin{verbatim}
    1, 1.,0.,0., 2, 0.,1.,0.
    1, (real alpha=pi/6.; cos(alpha)), sin(alpha), 0.,
        3, 0.,0.,1.
    \end{verbatim}
    the first example represents the identity matrix, i.e.\ no rotation 
    occurs with respect to the global reference frame: direction 1
    in the local frame is parallel to \kw{1.,0.,0.}, which represents
    direction 1 in the global frame, while direction 2 in the local frame
    is parallel to \kw{0.,1.,0.}, which represents direction 2
    in the global frame.

    The second example describes a rotation of $ \pi/6 $ radian about
    global direction 3: direction 1 in the local frame results from 
    composing \kw{cos(pi/6.)} in global direction 1 and \kw{sin(pi/6.)}
    in global direction 2, while direction 3 in the local frame remains
    parallel to \kw{0.,0.,1.}, which represents direction 3 in the global
    frame.
    \item a variant of the above, which may be useful when only one
    direction really matters, is illustrated in the example below:
    \begin{verbatim}
    1, 1.,0.,0., 2, guess
    \end{verbatim}
    The keyword \kw{guess} tells the parser to generate a random vector
    that is orthogonal to the given one, which is used as the direction
    indicated by the index (2 in the example).
    The vector is computed based on a very simple algorithm: it contains
    \begin{itemize}
        \item 1.0 corresponding to the index with smallest module,
        $v_1\plbr{\mathrm{min}}$;
	\item $-v_1\plbr{\mathrm{min}}/v_1\plbr{\mathrm{max}}$
	corresponding to the index with the largest module,
	$v_1\plbr{\mathrm{max}}$;
	\item 0.0 on the remaining index.
    \end{itemize}
    \item identity matrix: keyword \kw{eye}; the identity matrix,
    which means there is no rotation with respect to the global reference
    frame.
    \item a complete orientation matrix: keyword \kw{matr}
    followed by the nine, row-oriented, coefficients, namely
    $ r_{11} $, $ r_{12} $, \ldots, $ r_{33} $.
    \emph{Note: no orthogonality check is performed; be sure an orthogonal
    matrix, within the desired tolerance, is input}.
    \item Euler angles: keyword \kw{euler}, followed by the three
    values, as output by structural nodes.
    \emph{Note: the definition of the three angles that are used 
    by the code to express orientations may vary between versions.
    Currently, Bryant-Cardano angles are used in place of Euler
    angles; see the note related to the output of the structural nodes
    in Section~\ref{sec:NODE:STRUCTURAL:OUTPUT}, and the Technical Manual.
    The code will remain consistent, i.e. the same angle
    definition will be used for input and output, but models
    over versions may become incompatible, so this syntax should 
    really be used only as a means to quickly reproduce in the input
    an orientation as resulting from a previous analysis.}
    \item Orientation vector: keyword \kw{vector}, followed by the three
    values, as output by structural nodes.
    The resulting matrix is computed as
\begin{equation}
	\T{R} = \exp\plbr{\T{v}\times{}}
\end{equation}
\end{enumerate}
\subsection{\kw{6 x 6} matrices}
\begin{enumerate}
    \item general case: a sequence of 36 reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{65} $, $ a_{66} $.
    \item ANBA format: keyword \kw{anba}, followed by 36 reals, 
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the beam section analysis code ANBA,
    namely the following transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \emph{Note: this format is mainly intended for backwards compatibility
    with older versions of that beam section analysis software,
    which used a different numbering convention for the reference frame
    that is local to the beam section.}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 21 reals, comma-separated, that represents the upper triangle,
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{16} $, $ a_{22} $,
    \ldots , $ a_{26} $, \ldots, $ a_{66} $.
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 6 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix.
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
\subsection{\kw{6 x N} matrices}
\begin{enumerate}
    \item general case: a sequence of \kw{6 x N} reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{6\plbr{N-1}} $, $ a_{6N} $.
    \item ANBA format: keyword \kw{anba}, followed by \kw{6 x N} reals,
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the code ANBA, namely the following
    transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}


\section{Input Related Cards} 
(Almost) everywhere in the input file the statement cards defined 
in the following can be used.
They are handled directly by the parsing object, and merely act as
an indirect reference to entities that are not explicitly enumerated.
They are:



\subsection{Constitutive Law}\label{sec:CONSTITUTIVE-LAW}
\begin{verbatim}
    <card> ::= constitutive law : <label>
        [ , name , " <name> " ]
        <dim> , (ConstitutiveLaw<dim>D) <constitutive_law> ;
\end{verbatim}
Constitutive laws are grouped by their dimensionality \kw{<dim>},
which (up to now) can be any of 1, 3 and 6;
the \kw{<constitutive\_law>} is parsed according to the rules
described in Section~\ref{sec:CONSTITUTIVE-LAWS}.



\subsection{C81 Data}\label{sec:C81-DATA}
This keyword allows to define and read the \kw{c81 data} 
airfoil tables that are used by aerodynamic elements.
\begin{verbatim}
    <card> ::= c81 data : <label> [ , name , " <name> " ]
        " <filename> "
        [ , tolerance , <tolerance> ]
        [ , { fc511 | free format } ]
        [ , echo , " <output_filename> " [ , free format ] ] ;
\end{verbatim}
Data is read from file \kw{filename} according to the format specified
in the following.
The traditional format is used unless a format is specified using either
of the keywords \kw{free format} or \kw{fc511}
(the latter is intentionally not documented).
The format can be inferred from the heading line of the input file.

The optional keyword \kw{tolerance} allows to specify the tolerance
that is used to determine the boundaries of the linear portion
of the lift curve slope.

The optional keyword \kw{echo} allows to specify the name of the file
that will be generated with the data just read, for cross-checking purposes.
If the following optional keyword is \kw{free format}, or if data was read
in free format, the echo will also be in free format.
Otherwise, it will be in the traditional format.

\subsubsection{Traditional Format}
The file is in textual form; the traditional format (the default) is:
\begin{itemize}
\item first line: \kw{"\%30s\%2d\%2d\%2d\%2d\%2d\%2d"} 
where the first 30 chars are a title string, currently ignored by MBDyn,
followed by 6 two-digit integers that indicate:
	\begin{itemize}
	\item the number \kw{ML} of \emph{Mach} points for $C_l$;
	\item the number \kw{NL} of angle of attack points for $C_l$;
	\item the number \kw{MD} of \emph{Mach} points for $C_d$;
	\item the number \kw{ND} of angle of attack points for $C_d$;
	\item the number \kw{MM} of \emph{Mach} points for $C_m$;
	\item the number \kw{NM} of angle of attack points for $C_m$.
	\end{itemize}
The example in \kw{var/naca0012.c81} contains:
{\small
\begin{verbatim}
PROFILO NACA 0012             11391165 947
\end{verbatim}
}
\item the format of each following line is up to 10 fields of 7 chars each;
records longer than 10 fields are broken on multiple lines,
with the first field filled with blanks;
\item a block containing the $C_l$ data, made of:
	\begin{itemize}
	\item a record with the first field blank, followed by
	the \kw{ML} \emph{Mach} values for the $C_l$;
	\item \kw{NL} records containing the angle of attack
	in the first field, followed by \kw{ML} values of $C_l$
	for each \emph{Mach} number; angles of attack wrap around 
	360 deg, starting from -180.
	\end{itemize}
The example in \kw{var/naca0012.c81} contains 11 \emph{Mach} points
and 39 angle of attack records for $C_l$:
{\small
\begin{verbatim}
       0.     .20    .30    .40    .50    .60    .70    .75    .80
       .90    1.
-180.  0.     0.     0.     0.     0.     0.     0.     0.     0.
       0.     0.
-172.5 .78    .78    .78    .78    .78    .78    .78    .78    .78
       .78    .78
...
\end{verbatim}
}
\item a block containing the $C_d$ data, same as for $C_l$,
with \kw{MD} \emph{Mach} points and \kw{ND} angle of attack records;
\item a block containing the $C_m$ data, same as for $C_l$,
with \kw{MM} \emph{Mach} points and \kw{NM} angle of attack records.
\end{itemize}

\subsubsection{Alternative Format}
An alternative format, required by some projects, can be used by supplying
the optional switch \kw{fc511}; it is intentionally not documented.

\subsubsection{Free Format}
Finally, to allow higher precision whenever available, a native format,
based on \kw{c81}, is available; it is called \kw{free format} and 
basically consists in the c81 format without continuation lines
and with arbitrary precision, with fields separated by blanks.
The header is made of an arbitrary string, terminated by a semicolon,
followed by the six numbers that define the dimensionality of the expected data.

\paragraph{Example.} \
\begin{verbatim}
# FREE FORMAT
this is the header; 2 8 2 2 2 2
        0.0   0.9
-180.0  0.0   0.0
-170.0  1.0   0.9
 -90.0  0.0   0.0
 -10.0 -1.0  -0.9
  10.0  1.0   0.9
  90.0  0.0   0.0
 170.0 -1.0  -0.9
 180.0  0.0   0.0
        0.0   0.9
-180.0  0.1   0.1
 180.0  0.1   0.1
        0.0   0.9
-180.0  0.0   0.0
 180.0  0.0   0.0
\end{verbatim}


\subsubsection{Miscellaneous}
A simple program that allows to read and plot the C81 tables
is available at \\
\htmladdnormallink{\kw{http://homepage.mac.com/jhuwaldt/java/Applications/TableReader/TableReader.html}}
        {http://homepage.mac.com/jhuwaldt/java/Applications/TableReader/TableReader.html} \\
(thanks to Marco Fossati for pointing it out).

A simple utility that parses the C81 file and computes 
the aerodynamic coefficients for a given pair of angle of attack 
and Mach number is \kw{c81test}, available in the MBDyn utils suite.
This routine uses exactly the same code internally used by MBDyn,
so it should be considered a check of the code rather than a real tool.


\subsection{Drive Caller}\label{sec:DRIVE-CALLER}
\begin{verbatim}
    <card> ::= drive caller : <label>
        [ , name , " <name> " ]
        (DriveCaller)<drive_caller> ;
\end{verbatim}
The keyword \kw{drive caller} allows to define
a \hyperref{\kw{drive caller}}{\kw{drive caller} (see Section~}{)}{sec:DRIVE}
that can be subsequently reused.
It is useful essentially in two cases:
\begin{enumerate}
	\renewcommand{\labelenumi}{\alph{enumi})}
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE}
	that will be used many times throughout a model;
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE} 
	that needs to be used in a later defined part of a model, 
	in order to make it parametric.
\end{enumerate}



\subsection{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID}
The \kw{hydraulic fluid} directive:
\begin{verbatim}
    <card> ::= hydraulic fluid : <unique_label> , 
        <fluid_type> , <fluid_properties> ;
\end{verbatim}
allows to define a hydraulic fluid to be later used in hydraulic elements,
see Section~\ref{sec:EL:HYDR}.
The fluid is identified by a numerical label. 
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are
described in \ref{sec:HYDRAULIC-FLUID-DATA}



\subsection{Include}
The \kw{include} directive:
\begin{verbatim}
    <card> ::= include : " <file_name> " ;
\end{verbatim}
where \kw{file\_name} is a valid filename for the operative system in
use, that must be enclosed in double quotes (").
The full (absolute or relative) path must be given if the included file 
is not in the directory of the including one.
There is no check for recursive \kw{include}s, so 
{\bf the user must take care of recursion}.
The \kw{include} directive forces the parser to scan the included file
\kw{file\_name} before continuing with the including one.
This is very useful if, for instance, a big model can be made of many
small models that are meaningful by themselves.
It can be used to replicate parts of the model, by simply using parametric 
labels for nodes, elements, reference systems, and setting a bias value 
before multiple-including the same bulk data file.
Examples of this usage are given in the tutorials
\htmladdnormallink{(\texttt{http://www.aero.polimi.it/\~{}mbdyn/documentation/tutorials/})}
	{http://www.aero.polimi.it/~mbdyn/documentation/tutorials/}.



\subsection{Module Load}
\label{sec:GENERAL:MODULE-LOAD}
The \kw{module load} directive:
\begin{verbatim}
    <card> ::= module load : " <file_name> "
        [ , <module_arglist> ] ;

    <module_arglist> ::= <arg> [ , ... ]
\end{verbatim}
where \kw{file\_name} is the name of a runtime loadable object,
causes the object to be opened, and a function \kw{module\_init},
with prototype
\begin{verbatim}
        extern "C" int
        module_init(const char *module_name,
                void *data_manager, void* mbdyn_parser);
\end{verbatim}
to be executed.

The function is assumed to perform the operations required to initialize
the module, eventually taking advantage of the parsing
and of the data manager; see the technical manual for details.

The function is also expected to take care of the \kw{module\_arglist}
arguments; in detail, module developers are encouraged to support
\kw{help} as the first optional argument.
The presence of this argument should result in printing to standard output
as much information as possible about the use of the module.

The typical use consists in registering some methods for later use.
A clear example is given in
\begin{verbatim}
        modules/module-wheel2/module-wheel2.cc
\end{verbatim}
where the function registers the loadable element in the set
of loadable element handlers which can later be retrieved by using
the syntax described in Section~\ref{sec:EL:BASE:LOADABLE}.
Note, however, that the execution of the \kw{module\_init} function 
may be used for any purpose; typically, to register any kind of handlers
for subsequent use.

Run-time module loading is taken care of by GNU's \kw{libltdl}.
Modules are compiled using \kw{libtool} for portability purposes.
The resulting modules assume the name
\kw{libmodule-<name>.la}.

Modules are installed by default in the directory
\kw{\$\{prefix\}/libexec}.
When loaded using only the module name, the default directory is searched.
The run-time loading path can be modified by the 
\kw{loadable path} statement described
in Section~\ref{sec:CONTROLDATA:LOADABLE_PATH}.

Although \kw{libltdl} is supposed to be portable on a wide variety
of platforms (that's what it is designed for, all in all),
run-time loading within MBDyn is mainly tested using Linux.
Users are encouraged to report problems they might encounter,
especially when building modules for different platforms,
as this would help making MBDyn more portable.



\subsection{Reference}
The \kw{reference} directive:
\begin{verbatim}
    <card> ::= reference : <unique_label> , 
        <absolute_position> ,
        <absolute_orientation_matrix> ,
        <absolute_velocity> ,
        <absolute_angular_velocity> ;
\end{verbatim}
A \kw{reference} system is declared and defined.
It must be given a unique identifier, scanned by the math parser
(which means that any regular expression is allowed, and the result is
rounded up to the nearest unsigned integer).
The entries \kw{absolute\_*} are parsed by routines that
compute absolute (i.e.\ referring to the global frame) entities
starting from a given entity in a given reference frame.
These routines are very general, and make intense use of the 
\kw{reference} entries themselves, which means that a reference 
can be recursively defined by means of previously defined 
\kw{reference} entries.

\subsubsection{Use of Reference Frames}
Every time an absolute or a relative geometric or physical entity is
required, it is processed by a set of routines that allow the entity to be
expressed in the desired reference frame.
The following cases are considered:
\begin{itemize}
    \item relative position (physical)
    \item absolute position (physical)
    \item relative orientation matrix (physical)
    \item absolute orientation matrix (physical)
    \item relative velocity (physical)
    \item absolute velocity (physical)
    \item relative angular velocity (physical)
    \item absolute angular velocity (physical)
    \item relative arbitrary vector (geometric)
    \item absolute arbitrary vector (geometric)    
\end{itemize}
The caller is responsible for the final interpretation of the input. 
The caller always supplies the routines a default reference structure
the input must be referred to.
So, depending on the caller, the entry can be in the following forms:
\begin{enumerate}
\item \kw{<entity>}: \\ 
	the data supplied in \kw{<entity>} is intended 
	in the default reference frame
\item \kw{reference , <reference\_type> , <entity>}: \\
	the data is in \kw{<reference\_type>} reference frame, where
\begin{verbatim}
        <reference_type> ::= { global | node | local }
\end{verbatim}
\item \kw{reference , <reference\_label> , <entity>}: \\
	the data is in \kw{reference\_label} reference frame. 
	This reference frame must be already defined. 
\end{enumerate}
In some cases, significantly in case of joints that connect two nodes,
$a$ and $b$, special reference types are allowed
when reading specific entities related to the second node.
These reference types compute the value of the entity with respect
to the reference frame associated to the first node, $a$:
\begin{enumerate}
\item \kw{other position}: \\
	a relative position $\tilde{\T{p}}$ is intended in the other node's
	reference frame, with respect to the relative position $\tilde{\T{f}}_a$
	already specified for the other node,
\begin{equation}
	\tilde{\T{f}}_b = \TT{R}_b^T\plbr{
		\T{x}_a + \TT{R}_a \plbr{
			\tilde{\T{f}}_a
			+ \tilde{\T{p}}
		}
		- \T{x}_b
	} ,
\end{equation}
	which is the solution of equation
\begin{equation}
	\T{x}_a + \TT{R}_a \plbr{\tilde{\T{f}}_a + \tilde{\T{p}}}
	= \T{x}_b + \TT{R}_b \tilde{\T{f}}_b ;
\end{equation}

\item \kw{other orientation}: \\
	a relative orientation $\tilde{\TT{R}} $ is intended in the other node's
	reference frame, with respect to the relative orientation
	$\tilde{\TT{R}}_{ha}$ already specified for the other node,
\begin{equation}
	\tilde{\TT{R}}_{hb} = \TT{R}_b^T \TT{R}_a \tilde{\TT{R}}_{ha} \tilde{\TT{R}} ,
\end{equation}
	which is the solution of equation
\begin{equation}
	\TT{R}_a \tilde{\TT{R}}_{ha} \tilde{\TT{R}}
	= \TT{R}_b \tilde{\TT{R}}_{hb} ;
\end{equation}

\item \kw{other node}: \\
	a relative position $\tilde{\T{p}}$
	or a relative orientation $\tilde{\TT{R}}$
	are intended in the other node's reference frame,
\begin{subequations}
\begin{align}
	\tilde{\T{f}}_b &= \TT{R}_b^T\plbr{
		\T{x}_a + \TT{R}_a \tilde{\T{p}}
		- \T{x}_b
	} \\
	\tilde{\TT{R}}_{hb} &= \TT{R}_b^T \TT{R}_a \tilde{\TT{R}} ,
\end{align}
\end{subequations}
	which are the solutions of equations
\begin{subequations}
\begin{align}
	\T{x}_a + \TT{R}_a \tilde{\T{p}}
	&= \T{x}_b + \TT{R}_b \tilde{\T{f}}_b \\
	\TT{R}_a \tilde{\TT{R}}
	&= \TT{R}_b \tilde{\TT{R}}_{hb} .
\end{align}
\end{subequations}
\end{enumerate}

\paragraph{Example.} \
\begin{itemize}
    \item absolute position:
    \begin{verbatim}
    null
    reference, global, null
    reference, 8, 1., sin(.3*pi), log(3.)
    \end{verbatim}
    \item relative orientation matrix (e.g.\ as required by many constraints and
    thus referred to a node):
    \begin{verbatim}
    eye
    reference, node, eye
    reference, 8,
        3, 0., 1., 0., 
        1, .5, sqrt(3)/2., 0.
    \end{verbatim}
\end{itemize}
Notes: 
\begin{itemize}
    \item the global reference frame has position $ \cubr{0, 0, 0} $,
    orientation matrix \kw{eye}, velocity $ \cubr{0, 0, 0} $ and angular
    velocity $ \cubr{0, 0, 0} $.
    \item if the caller is not related to a node, the reference type
    \kw{node} should not be defined. 
    In this case it is considered equivalent to \kw{local}.
    \item when processing a velocity or an angular velocity, the resulting
    value always accounts for the velocity and angular velocity of the frame
    the entry is referred to. 

    As an example, if a node is defined in a reference frame $\T{R}_R$
    that has non-null angular velocity $ \T{\Omega}_R $, and the position 
    $ \T{x}_{\text{input}} $ of the node is not coincident
    with the origin $ \T{X}_R $ of the reference frame
    it is attached to, its global velocity and angular velocity result
    as the composition of the input values and of those of the reference 
    frame:
    \begin{eqnarray*}    
        \T{w} & = & \T{R}_R \T{\omega}_{\text{input}} + \T{\Omega}_R \\
	\T{v} & = & \T{R}_R \T{v}_{\text{input}} + \T{V}_R
		+\T{\Omega}_R\times\plbr{\T{R}_R \T{x}_{\text{input}}}
    \end{eqnarray*}
    This, for instance, eases the input of all the parts of a complex system
    that is moving as a rigid body, by defining a reference frame with the
    proper initial velocities, and then referring all the entities, e.g.\ the 
    nodes, to that frame, with null local velocity.
\end{itemize}  
{\em
    Recalling the declaration and the definition of reference frames,
    a simple reference frame definition, with all the entries referring 
    by default to the global system, would be:
    \begin{verbatim}
    reference: 1000,
        null,
        eye,
        null,
        null;
    \end{verbatim}
    which represents a redefinition of the global system.
    A more verbose, and self-explanatory definition would be:
    \begin{verbatim}
    reference: 1000,
        reference, global, null,
        reference, global, eye,
        reference, global, null,
        reference, global, null;			 
    \end{verbatim}
    the reference frame one is referring to must be repeated for all the entries
    since they must be allowed to refer to whatever frame is preferred 
    by the user.
    A fancier definition would be:
    \begin{verbatim}
    reference: Rotating_structure, 
        reference, Fixed_structure, null,
        reference, Spindle_1,
            1, 0.,0.,1., 
            3, 0.,1.,0.,
        reference, Fixed_structure, null,
        reference, Spindle_1, 0.,0.,Omega_1;
    \end{verbatim}
}

\subsubsection{Output}
The reference frames are used only during the input phase, 
where they help referring entities either absolute 
or relative to other entities depending on their internal representation
during the analysis.
As such, reference frames cannot be ``used'' or ``visualized'' neither 
directly nor indirectly at any time during the analysis or by interpreting
the output, because they do not ``evolve'' nor are attached
to any state-dependent entity.
To allow their debugging, however, they can be output in the global
reference frame according to the representation of structural nodes,
as described in Section~\ref{sec:NODE:STRUCTURAL:OUTPUT}, 
by using the \kw{default output} directive 
with the value \kw{reference frames}, as detailed
in Section~\ref{sec:CONTROLDATA:DEFAULTOUTPUT}.



\subsection{Print symbol table}
The \kw{print symbol table} directive:
\begin{verbatim}
    <card> ::= print symbol table ;
\end{verbatim}
allows to print to standard output the contents of the parser's symbol
table at any stage of the input phase.
This may be useful for model debugging purposes.



\subsection{Remark}
The \kw{remark} directive:
\begin{verbatim}
    <card> ::= remark : " <remark_string > "
        [ , <math_expression> [ , ... ] ] ;
\end{verbatim}
This directive simply prints to stdout the string \kw{remark\_string} and
optionally evaluates and prints any subsequent expression \kw{math\_expression}
according to the \kw{set} directive.
It is used to allow rough input debugging, where the file name and line 
is logged, followed by a message and by the evaluation of any expression. 

\paragraph{Example.} \
A file ``remarks'', containing only the statements
\begin{verbatim}
    remark: "square root of 2", sqrt(2);
    set: (
        real EA = 1e6; # N, axial stiffness
        real GA = 1e6; # N, shear stiffness
        real EJ = 1e3; # Nm^2, bending stiffness
        real GJ = 1e3; # Nm^2, torsional stiffness
    0);
    remark: "Stiffness properties", EA, GA, EJ, GJ;
\end{verbatim}
results in
\begin{verbatim}
user@host:~>$ mbdyn -f remarks

MBDyn - Multi-Body Dynamics 1.2.5
compiled on Nov 18 2005 at 15:15:39

Copyright 1996-2009 (C) Paolo Mantegazza and Pierangelo Masarati,
Dipartimento di Ingegneria Aerospaziale <http://www.aero.polimi.it/>
Politecnico di Milano                   <http://www.polimi.it/>

MBDyn is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it
under certain conditions.  Use 'mbdyn --license' to see the conditions.
There is absolutely no warranty for MBDyn.  Use "mbdyn --warranty"
for details.

reading from file "remarks"
line 1, file <remarks>: square root of 2, 1.41421
line 8, file <remarks>: Stiffness properties, 1e+06, 1e+06, 1000, 1000
MBDyn terminated normally
user@host:~>$
\end{verbatim}


\subsection{Set}
The \kw{set} directive:
\begin{verbatim}
    <card> ::= set : <math_expression> ;
\end{verbatim}
This directive simply invokes the math parser to evaluate the expression
\kw{math\_expression} and then discards the result. It can be used
to declare new variables, or to set the values of existing ones.



\subsection{Setenv}
The \kw{setenv} directive:
\begin{verbatim}
    <card> ::= setenv : [ overwrite , ] " <varname> [ = <value> ] " ;
\end{verbatim}
This directive sets the environment variable \kw{<varname>} 
to the value \kw{<value>}, if given; otherwise, the variable
is unset.
If the keyword \kw{overwrite} is set, the variable is overwritten, 
if already set.
\begin{verbatim}
    # set FILE to "test", if it does not exist
    setenv: "FILE=test";
    # set FILE to "test", even if it exists
    setenv: override, "FILE=test";
    # unset FILE
    setenv: "FILE";
    # set FILE to the empty string, if it does not exist
    setenv: "FILE=";
\end{verbatim}
See \kw{setenv(3)} and \kw{unsetenv(3)} man pages for details.



\section{Node Degrees of Freedom}\label{sec:NODEDOF}
A node in MBDyn is nothing but an entity that owns degrees of freedom and
can lend them to other entities. 
Usually elements access nodal degrees of freedom through well-defined
interfaces, at a high level. 
But in a few cases, nodal degrees of freedom must be accessed
at a very low level, with the bare knowledge of the node label,
the node type,
the internal number of the degree of freedom, and the order 
(algebraic or differential, if any).
The data that allows an entity to track a nodal degree of freedom
is read as follows:
\begin{verbatim}
    <node_dof> :: = <node_label> , 
        <node_type> 
        [ , <dof_number> ]
        [ , { algebraic | differential } ]
\end{verbatim}
The label (\kw{node\_label}) and the type (\kw{node\_type})
of the node are used to track the pointer to the desired node. 

If \kw{node\_type} refers to a non-scalar node type,
the \kw{dof\_number} field is required to indicate the requested
degree of freedom.

Finally, the order of the degree of freedom is read, if required.
It must be one of \kw{algebraic} or \kw{differential}.
If the \kw{dof\_number} degree of freedom is differential, both
orders can be addressed, while in case of a node referring
to an algebraic degree of freedom there is no choice,
only the \kw{algebraic} order can be addressed and thus this field
is not required.

The \kw{dof\_number} must be between 1 and the number of \emph{dof}s that
belong to the node.
Not all numbers might be valid for specific nodes; for example,
\kw{dof\_number} values 4, 5, and 6 are not valid for a
\hyperref{\kw{structural node}}{\kw{structural node}, Section~}{}{sec:NODE:STRUCTURAL}, when the order is \kw{algebraic}.

When the node degree of freedom input syntax is used to address
an equation (as in
\hyperref{\kw{abstract} force elements}{\kw{abstract} force elements, Section~}{}{sec:EL:FORCE:ABSTRACT},
or in
\hyperref{\kw{discrete control} elements}{\kw{discrete control} elements, Section~}{}{sec:EL:DISCCTRL}),
the distinction between \kw{algebraic} and \kw{differential} is meaningless,
and thus this field is not required.




\section{Drives and Drive Callers}\label{sec:DRIVE}
Every time some entity can be ``driven'', i.e.\ a value can be
expressed as dependent on some ``external'' input, an object of the class 
\kw{DriveCaller} is used. 
The \kw{drive} essentially represents a scalar function, whose
value can change over time or, through some more sophisticated
means, based on the state of the analysis.
Usually, the dependence over time is implicitly assumed, unless
otherwise specified.
For example, the amplitude of the force applied by a 
\hyperref{\kw{force} element}{\kw{force} element (see Section~}{)}{sec:EL:FORCE}
is defined by means of a \kw{drive}; as such, the value of the \kw{drive} 
is implicitly calculated as a function of the time.
However, a 
\hyperref{\kw{dof drive}}{\kw{dof drive} (see Section~}{)}{sec:DRIVE-DOF}
uses a subordinate \kw{drive} to compute its value based on the value
of a degree of freedom of the analysis; as a consequence,
the value of the \kw{dof drive} is represented by the
value of the subordinate \kw{drive} when evaluated as a function
of that specific degree of freedom at the desired time.

The family of the \kw{DriveCaller} object is very large, 
and should require a dedicated chapter.
The type of the \kw{DriveCaller} is declared as follows:
\begin{verbatim}
    <drive_caller> ::=
        { <drive_caller_type> [ , <arglist> ]
            | reference , <label> }
\end{verbatim}    
where \kw{arglist}, if any, is a comma-separated list of arguments
that depends on \kw{drive\_caller\_type}.
As an exception, a constant \kw{DriveCaller} (that behaves exactly as a
numerical constant with little or no overhead depending on the optimizing
capability of the compiler) is assumed when a numeric value is used instead
of a keyword.
If the alternative format is used, the keyword \kw{reference} 
must be followed by the label of an already defined, valid drive caller
(See Section~\ref{sec:DRIVE-CALLER}).

\subsection{Null drive}
\begin{verbatim}
    <drive_caller> ::= null
\end{verbatim}
Zero valued; the \kw{arglist} is empty.

\subsection{Unit drive}
\begin{verbatim}
    <drive_caller> ::= unit
\end{verbatim}
Always 1; the \kw{arglist} is empty.

\subsection{Constant drive}
\begin{verbatim}
    <drive_caller> ::= [ const , ] <const_coef>                    
\end{verbatim}
The keyword \kw{const} can be omitted, thus highlighting the real nature
of this driver, that is completely equivalent to a constant, static real
value.

\subsection{Time drive}
\begin{verbatim}
    <drive_caller> ::= time
\end{verbatim}
Yields the current time; the arglist is empty.
  
\subsection{Linear drive}\label{sec:DRIVES:LINEAR}
\begin{verbatim}
    <drive_caller> ::= linear ,
        <const_coef> ,
        <slope_coef>
\end{verbatim}
The function
\begin{align}
	f\plbr{t} &= \mathtt{const\_coef} \nonumber \\
		&+ \mathtt{slope\_coef} * t
\end{align}

\subsection{Parabolic drive}
\begin{verbatim}
    <drive_caller> ::= parabolic ,
        <const_coef> , 
        <linear_coef> , 
        <parabolic_coef>
\end{verbatim}
The function
\begin{align}
	f\plbr{t} &= \mathtt{const\_coef} \nonumber \\
		&+ \mathtt{linear\_coef} * t \nonumber \\
		&+ \mathtt{parabolic\_coef} * t^2
\end{align}

\subsection{Cubic drive}
\begin{verbatim}
    <drive_caller> ::= cubic ,
        <const_coef> , 
        <linear_coef> ,
        <parabolic_coef>, 
        <cubic_coef>
\end{verbatim}
The function
\begin{align}
	f\plbr{t} &= \mathtt{const\_coef} \nonumber \\
		&+ \mathtt{linear\_coef} * t \nonumber \\
		&+ \mathtt{parabolic\_coef} * t^2 \nonumber \\
		&+ \mathtt{cubic\_coef} * t^3
\end{align}

\subsection{Step drive}
\begin{verbatim}
    <drive_caller> ::= step ,
        <initial_time> , 
        <step_value> ,
        <initial_value>
\end{verbatim}    
The function
\begin{align}
	f\plbr{t} &= \mathtt{initial\_value} \nonumber \\
	&+ \lcubr{\matr{ll}{
		0 
			& t < \mathtt{initial\_time} \\
		\\
		\mathtt{step\_value}
			& \mathtt{initial\_time} \le t
	}}
\end{align}

\subsection{Double step drive}
\begin{verbatim}
    <drive_caller> ::= double step ,
        <initial_time> , 
        <final_time> ,
        <step_value> , 
        <initial_value>
\end{verbatim}
The function
\begin{align}
	f\plbr{t} &= \mathtt{initial\_value} \nonumber \\
	&+ \lcubr{\matr{ll}{
		0
			& t < \mathtt{initial\_time} \\
		\\
		\mathtt{step\_value}
			& \mathtt{initial\_time} \le t \le \mathtt{final\_value} \\
		\\
		0 
			& \mathtt{final\_time} < t
	}}
\end{align}

\subsection{Ramp drive}
\begin{verbatim}
    <drive_caller> ::= ramp ,
        <slope> , 
        <initial_time> ,
        { forever | <final_time> } ,
        <initial_value>
\end{verbatim}
The function
\begin{align}
	f\plbr{t} &= \mathtt{initial\_value} \nonumber \\
	&+ \lcubr{\matr{ll}{
		0
			& t < \mathtt{initial\_time} \\
		\\
		\mathtt{slope} * \plbr{t - \mathtt{initial\_time}}
			& \mathtt{initial\_time} \le t \le \mathtt{final\_value} \\
		\\
		\mathtt{slope} * \plbr{\mathtt{final\_time} - \mathtt{initial\_time}}
			& \mathtt{final\_time} < t
	}}
\end{align}

\subsection{Double ramp drive}
\begin{verbatim}
    <drive_caller> ::= double ramp ,
        <a_slope> , 
        <a_initial_time> , 
        <a_final_time> , 
        <d_slope> , 
        <d_initial_time> , 
        { forever | <d_final_time> } , 
        <initial_value>
\end{verbatim}
The function
\begin{align}
	\mathtt{f\_a} &= \mathtt{a\_slope} * \plbr{\mathtt{a\_final\_time} - \mathtt{a\_initial\_time}}
		\nonumber \\
	\mathtt{f\_d} &= \mathtt{d\_slope} * \plbr{\mathtt{d\_final\_time} - \mathtt{d\_initial\_time}}
		\nonumber \\
	f\plbr{t} &= \mathtt{initial\_value} \\
	&+ \lcubr{\matr{ll}{
		0
			& t < \mathtt{a\_initial\_time} \\
		\\
		\multicolumn{2}{l}{
		\mathtt{a\_slope} * \plbr{t - \mathtt{a\_initial\_time}}
		} \\
			& \mathtt{a\_initial\_time} \le t \le \mathtt{a\_final\_value} \\
		\\
		\mathtt{f\_a}
			& \mathtt{a\_final\_time} < t < \mathtt{d\_initial\_time} \\
		\\
		\multicolumn{2}{l}{
		\mathtt{f\_a}
		+ \mathtt{d\_slope} * \plbr{t - \mathtt{d\_initial\_time}}
		} \\
			& \mathtt{d\_initial\_time} \le t \le \mathtt{d\_final\_value} \\
		\\
		\mathtt{f\_a} + \mathtt{f\_d}
			& \mathtt{d\_final\_time} < t
	}} \nonumber
\end{align}

\subsection{Piecewise linear drive}
\begin{verbatim}
    <drive_caller> ::= piecewise linear ,
        <num_points> ,
            <point> , <value> 
            [ , ... ]
\end{verbatim}
Piecewise linear function; the first and the last point/value pairs are
extrapolated in case a value beyond the extremes is required.
Linear interpolation between pairs is used.

\subsection{Sine drive}
\begin{verbatim}
    <drive_caller> ::= sine ,
        <initial_time> ,
        <angular_velocity> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
where \kw{angular\_velocity} is $2\pi/T$.
The value of \kw{number\_of\_cycles} determines the behavior of the drive. 
If it is positive, \kw{number\_of\_cycles}$-1/2$ oscillations are performed. 
If it is negative, the oscillations end after 
\kw{number\_of\_cycles}$-3/4$ cycles at the top of the sine, with null
tangent.
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly half period is performed;
	\item \kw{half}, which means exactly a quarter of period is performed,
	so the function stops at
\begin{align}
	f\plbr{t} &= \mathtt{initial\_value} \\
	&+ \lcubr{\matr{ll}{
		0 & t < \mathtt{initial\_time} \\
		\\
		\multicolumn{2}{l}{
		\mathtt{amplitude} * \sin\plbr{\mathtt{angular\_velocity} * \plbr{
			t - \mathtt{initial\_time}
		}}
		} \\
			& \mathtt{initial\_time} \le t
				\le \mathtt{initial\_time} + \cfrac{\pi}{2 * \mathtt{angular\_velocity}} \\
		\\
		\mathtt{amplitude}
			& \mathtt{initial\_time} + \cfrac{\pi}{2 * \mathtt{angular\_velocity}} \le t
	}} \nonumber .
\end{align}
\end{itemize}

\subsection{Cosine drive}
\begin{verbatim}
    <drive_caller> ::= cosine ,
        <initial_time> ,
        <angular_velocity> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
where \kw{angular\_velocity} is $2\pi/T$.
This drive actually computes a function of the type
\begin{displaymath}
	f\plbr{t} = \mathtt{initial\_value} + \mathtt{amplitude} * \plbr{
		1 - \llk{cos}\plbr{
			\mathtt{angular\_velocity} * \plbr{
				t - \mathtt{initial\_time}
			}
		}
	} .
\end{displaymath}
The value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles} oscillations are performed.
If it is negative, the oscillations end after
\kw{number\_of\_cycles}$-1/2$ cycles at the top of the cosine, with null
tangent.   
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
	\item \kw{half}, which means exactly half cycle is performed,
	so the function stops at
	\begin{displaymath}
		t = \mathtt{initial\_time} + \frac{\pi}{\mathtt{angular\_velocity}} ,
	\end{displaymath}
	with a value of
	\begin{displaymath}
		f = 2 * \mathtt{amplitude} + \mathtt{initial\_value} ,
	\end{displaymath}
	starting and ending with continuous derivative.
	In this case, it may be convenient to indicate the \kw{angular\_velocity}
	as $\pi/\mathtt{duration}$, where \kw{duration} is the time
	required to complete the half-wave.
\end{itemize}

%%% TODO: add a plot that exemplifies the three cases

\subsection{Tanh drive}
\begin{verbatim}
    <drive_caller> ::= tanh,
        <initial_time> ,
        <amplitude> ,
        <slope> ,
        <initial_value>
\end{verbatim}
This drive computes a function of the type
\begin{displaymath}
	f\plbr{t} = \mathtt{initial\_value} + \mathtt{amplitude} *\llk{tanh}\plbr{
			\mathtt{slope} * \plbr{
				t - \mathtt{initial\_time}
			}
		} .
\end{displaymath}
It is differentiable.

%%% TODO: add a plot that exemplifies the three cases

\subsection{Fourier series drive}
\begin{verbatim}
    <drive_caller> ::= fourier series ,
        <initial_time> ,
        <angular_velocity> ,
        <number_of_terms> ,
            a_0 ,
            a_1 , b_1 ,
            [ ... , ]
        { <number_of_cycles> | one | forever } , 
        <initial_value>
\end{verbatim}
This drive corresponds to a Fourier series of fundamental angular velocity $\omega$,
truncated after $n$ terms, over a given number of cycles $P$ and starting 
at a given initial time $t_0$ as
\begin{displaymath}
	f\plbr{t} = \frac{a_0}{2} + \sum_{k=1}^n \plbr{
		a_k \cos\plbr{k\omega\plbr{t - t_0}}
		+ b_k \sin\plbr{k\omega\plbr{t - t_0}}
	}
\end{displaymath}
for
\begin{displaymath}
	t_0 \le t \le t_0 + P \frac{2 \pi}{\omega}
\end{displaymath}
The value of $f\plbr{t}$, if defined, is added to \kw{initial\_value}.
The value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles} oscillations are
performed.
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
\end{itemize}
the \kw{number\_of\_terms} must be at least 1.

\subsection{Frequency sweep drive}
\begin{verbatim}
    <drive_caller> ::= frequency sweep ,
        <initial_time> ,
        <angular_velocity_drive> ,
        <amplitude_drive> ,
        <initial_value> ,
        { forever | <final_time> } ,
        <final_value>
\end{verbatim}
this drive recursively calls two other drives that supply the angular velocity 
and the amplitude of the oscillation. Any drive can be used.

\subsection{Exponential drive}
\begin{verbatim}
    <drive_caller> ::= exponential ,
        <amplitude_value> ,
        <time_constant_value> ,
        <initial_time> ,
        <initial_value>
\end{verbatim}

\subsection{Random drive}
\begin{verbatim}
    <drive_caller> ::= random ,
        <amplitude_value> ,
        <mean_value> ,
        <initial_time> ,
        { forever | <final_time> }
        [ , steps , <steps_to_hold_value>]
        [ , seed , { time | <seed_value>} ]
\end{verbatim}
the first optional entry, preceded by the keyword \kw{steps}, sets the
number of steps a random value must be held before generating a new
random number. The second optional entry, preceded by the keyword
\kw{seed}, sets the new seed for the random number generator. A numeric
value can be used, or the keyword \kw{time} uses the current time from
the internal clock. A given seed can be used to ensure that two
simulations use exactly the same random sequence (concurrent settings 
are not managed, so it is not very reliable).

\subsection{Meter drive}
The \kw{meter} drive has value zero except for every \kw{steps} steps,
where it assumes unit value.
\begin{verbatim}
    <drive_caller> ::= meter ,
        <initial_time> ,
        { forever | <final_time> }
        [ , steps , <steps_between_spikes>]
\end{verbatim}
the first optional entry, preceded by the keyword \kw{steps}, sets the
number of steps between spikes.

\paragraph{Example.} \
\begin{verbatim}
    ..., meter, 0., forever, steps, 10, ...
\end{verbatim}
defines a drive whose value is zero except at time step 0. 
and every 10 time steps from that, where it assumes unit value.

\subsection{File drive}\label{sec:FILE-DRIVE}
The \kw{DriveCaller} is attached to a file drive object that must be declared
and defined in the \htmlref{\kw{drivers}}{sec:DRIVERS} section 
of the input file (see Section~\ref{sec:DRIVERS}).
As a consequence, \kw{file} drive callers can only be instantiated
after the \htmlref{\kw{drivers}}{sec:DRIVERS} section
of the input file.
\begin{verbatim}
    <drive_caller> ::= file ,
        <drive_label>
        [ , <column_number> ]
        [ , amplitude , <amplitude> ]
\end{verbatim}
\kw{drive\_label} is the label of the \htmlref{\kw{drive}}{sec:DRIVE} 
the \kw{DriveCaller} is attached to, while
\kw{column\_number} is the number of the column the \kw{DriveCaller}
refers to (defaults to 1).
An additional scaling factor \kw{amplitude} can be used to rescale
the drive value (defaults to 1.0).

\subsection{String drive}
\begin{verbatim}
    <drive_caller> ::= string ,
        " <expression_string> "
\end{verbatim}
\kw{expression\_string} is a string, delimited by double quotes.
It is parsed by the math parser every time 
the \htmlref{\kw{drive}}{sec:DRIVE} is invoked.
The variable \kw{Time} is kept up to date and can be used in the 
string to compute the return value.
Another variable, \kw{Var}, is set to the value provided by the caller
in case the drive is called with an explicit argument as, for instance,
in the \hyperref{dof drive}{dof drive (see Section~}{)}{sec:DRIVE-DOF};
e.g.:
\begin{verbatim}
    ..., string, "e^(-Time)*cos(2.*pi*Time)" ...
\end{verbatim}
generates a cosine modulated by an exponential.

\emph{Note: currently, the expression is parsed each time it is evaluated;
this is not very efficient.
A future version should build a tree-like form of the
parsed expression, where non-symbolic branches are evaluated once for all,
to speed up evaluation.}


\subsection{Dof drive}\label{sec:DRIVE-DOF}
\begin{verbatim}
    <drive_caller> ::= dof ,
        (node_dof) <driving_dof> ,
        (drive_caller) <func_drive>
\end{verbatim}
a \hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}, 
namely the reference to a degree of freedom of a node, is read. 
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
\htmlref{\kw{node\_dof}}{sec:NODEDOF} as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the displacement
of the node it is applied to) or an active control system; e.g.:
\begin{verbatim}
    ..., dof, 1000, structural, 3, algebraic, 
        linear, 0., 1. ...
\end{verbatim}
uses the value of the third component (z) of structural node 1000 
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    ..., dof, 1000, abstract, differential, 
        string, "2.*exp(-100.*Var)" ...
\end{verbatim}
uses the value of the derivative of abstract node 1000 in computing 
a string expression.
Refer to the description of a 
\hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}
entry for further details.

The same effect can be obtained using the \kw{dof} plugin as follows:
\begin{verbatim}
    set: [dof,x,1000,structural,1,algebraic];
    # ...
        ..., string, "2.*exp(-100.*x)" ...
\end{verbatim}
which applies a couple whose amplitude is computed by evaluating
a \kw{string} drive which depends on variable $x$; this, in turn,
is defined as a \kw{dof} plugin, which causes its evaluation
in terms of the selected degree of freedom of the node at each invocation.

\subsection{Node drive}\label{sec:DRIVE-NODE}
\begin{verbatim}
    <drive_caller> ::= node ,
        <label> ,
        <type> ,
        [ { string, "<name>" | index , <index> } , ]
        (drive_caller) <func_drive>
\end{verbatim}
a reference to the private data of a node is read.
This is made of: the node's \kw{label}, the node's \kw{type}
and a specification of which private data is being referred;
the \kw{index} can be directly given, prepended by the keyword
\kw{index}, or the symbolic name can be used, prepended by 
the keyword \kw{string}.
If that node allows only one private data, the specification 
can be omitted.
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
node's private data as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the rotation
of a joint) or an active control system; e.g.:
\begin{verbatim}
    ..., node, 1000, structural, string, "X[3]",
        linear, 0., 1. ...
\end{verbatim}
uses the value of the displacement in direction $z$ (3) of a
\hyperref{\kw{structural node}}{\kw{structural node}, Section~}{}{sec:NODE:STRUCTURAL:PRIV},
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, see the 
\hyperref{\kw{linear} drive}{\kw{linear} drive, Section~}{}{sec:DRIVES:LINEAR}),
while
\begin{verbatim}
    ..., node, 1000, structural, index, 3,
        string, "2.*exp(-100.*Var)" ...
\end{verbatim}
uses the same value, addressed in an alternative manner, in computing
a string expression.

\subsection{Element drive}\label{sec:DRIVE-ELEMENT}
\begin{verbatim}
    <drive_caller> ::= element ,
        <label> ,
        <type> ,
        [ { string, "<name>" | index , <index> } , ]
        (drive_caller) <func_drive>
\end{verbatim}
a reference to the private data of an element is read.
This is made of: the element's \kw{label}, the element's \kw{type}
and a specification of which private data is being referred;
the \kw{index} can be directly given, prepended by the keyword
\kw{index}, or the symbolic name can be used, prepended by 
the keyword \kw{string}.
If that element allows only one private data, the specification 
can be omitted.
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
element's private data as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the rotation
of a joint) or an active control system; e.g.:
\begin{verbatim}
    element, 1000, joint, string, "rz",
        linear, 0., 1.
\end{verbatim}
uses the value of the rotation about axis $z$ of a revolute hinge
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    element, 1000, joint, index, 1
        string, "2.*exp(-100.*Var)"
\end{verbatim}
uses the same value, addressed in an alternative manner, in computing
a string expression.

The same effect can be obtained using the \kw{element} plugin as follows:
\begin{verbatim}
    set: [element,x,1000,joint,string=rz];
    # ...
    couple: 1, conservative, 1, 0.,0.,1.,
        string, "2.*exp(-100.*x)";
\end{verbatim}
which applies a couple whose amplitude is computed by evaluating
a \kw{string} drive which depends on variable $x$; this, in turn,
is defined as an \kw{element} plugin, which causes its evaluation
in terms of the element's private data at each invocation.

\subsection{Scalar function drive}
\begin{verbatim}
    <drive_caller> ::= scalar function, " <scalar_function_name> "
        [ , <scalar_function_definition> ]
\end{verbatim}
The scalar function called \kw{scalar\_function\_name} must exist;
alternatively, it must be defined inline.

\paragraph{Example.} \
\begin{verbatim}
    scalar function: "this_is_a_test",
        multilinear,
            -20., 1.,
            -10., 0.1,
              0., 0.,
             10., 0.1,
             20., 1.;
     set: integer MY_DRIVE = 1000;
     drive: MY_DRIVE, scalar function, "this_is_a_test";
\end{verbatim}
Alternative syntax example:
\begin{verbatim}
     set: integer MY_DRIVE = 1000;
     drive: MY_DRIVE, scalar function, "this_is_a_test",
        multilinear,
            -20., 1.,
            -10., 0.1,
              0., 0.,
             10., 0.1,
             20., 1.;
\end{verbatim}


\subsection{Drive drive}
\begin{verbatim}
    <drive_caller> ::=
            <drive_caller1> , 
            <drive_caller2>
\end{verbatim}
This is simply a ``function of function'' drive: the output 
of \kw{drive\_caller2} is fed to \kw{drive\_caller1}
and the result is returned.
So the value of \kw{drive\_caller2} becomes the input argument
to \kw{drive\_caller1}.
Note that the very same thing occurs, for instance, in the
\kw{dof} and in the \kw{element} drives, where the value of the dof
or of the element's private datum, respectively, are fed 
into the given drive.

\paragraph{Example.}
\begin{verbatim}
    force: 1, abstract,
        1, abstract,
        drive,
            string, "Var*(Var>0.)",
            sine, 0., 2*pi/.2, 10., forever, 0.;
\end{verbatim}
is equivalent to
\begin{verbatim}
    set: real v;
    force: 1, abstract,
        1, abstract,
        string, "v=sin(5.*2*pi*Time); 10.*v*(v>0)";
\end{verbatim}


\subsection{Array drive}
\begin{verbatim}
    <drive_caller> ::= array ,
        <num_drives> ,
            <drive_caller> 
            [ , <drive_caller> [ , ... ] ]
\end{verbatim}
this is simply a front-end for the linear combination of \kw{num\_drives} 
normal drives; \kw{num\_drives} must be at least 1, in which case 
a simple drive caller is created, otherwise an array of drive callers 
is created and at every call their value is added to give 
the final value of the array drive.


\subsection{Hints}\label{sec:GENERAL:DRIVE:HINT}
\emph{Hints have been sponsored
by \htmladdnormallink{Hutchinson}{http://www.hutchinson.fr} CdR.}
\bigskip

In some cases, during the analysis, different entities can be reinitialized
as a consequence of some event, typically triggered by the waking up 
of a so-called \kw{driven} element (See Section~\ref{sec:EL:BASE:DRIVEN}).
The \kw{drive caller} is re-parsed when the entity that owns it is sent
a \kw{hint} of the form
\begin{verbatim}
    "drive{ <drive_caller> }"
\end{verbatim}
is used, where \kw{<drive\_caller} is an arbitrary drive caller specification,
enclosed in double quotes.
Typically, the use of a \kw{hint} is necessary when the specification of the
drive caller parameters depends on the configuration of the system when the
entity that uses it is waken up.
For example, a \kw{distance joint}, an element that enforces the distance
between two nodes, may be waken up by some event.
In the case detailed below, the initial value of the \kw{cosine} drive caller
is computed by extracting the current distance between the nodes at the time
the element is waken up:
\begin{verbatim}
    driven: 1, string, "Time > 10.",
        hint, "drive{cosine, 10., 2., .25, half, model::distance(10, 20)}",
    joint: 1, distance,
        10,
        20,
        const, 1;
\end{verbatim}



\subsection{Template drive}\label{sec:TPL-DRIVE}
A particular \kw{DriveCaller} is the template drive caller.
It basically consists in a drive with a dimensionality other than scalar.
Typically, it is made of a constant entity, with the desired dimensionality,
that multiplies a conventional 
\hyperref{\kw{drive}}{\kw{drive} (see Section~}{)}{sec:DRIVE}
to give a drive entity of dimensionality different from that 
of a simple scalar \kw{drive}.

There are four types of template drive callers:
\begin{itemize}
\item the \kw{null} template drive caller, a shortcut for nothing;
\item the \kw{single} template drive caller;
\item the \kw{component} template drive caller;
\item the \kw{array} template drive caller,
which linearly combines a set of template drive callers.
\end{itemize}
They are entered as follows:
\begin{verbatim}
    <tpl_drive_caller> ::= null

    <tpl_drive_caller> ::= single ,
        <entity> , <drive_caller> 

    <tpl_drive_caller> ::= component ,
        <component_drive_caller> [ , ... ]

    <component_drive_caller> ::= { inactive | <drive_caller> }

    <tpl_drive_caller> ::= array ,
        <num_template_drive_callers> ,
        <entity> , <drive_caller>
        [ , <entity> , <drive_caller> [ , ... ] ]
\end{verbatim}
where \kw{entity} is a constant of the expected type (scalar, \kw{3 x 1} 
vector, \kw{6 x 1} vector are the types currently defined, but, since 
a C++ template has been used, the implementation of other ones 
is straightforward).

In case of scalar values, the template reverts by default to a normal 
drive caller, so no overhead is added.

In the case of the \kw{component} template drive caller,
as many drive callers as the dimensionality of the template drive caller
are expected.

At least 1 drive caller is expected if the case of the \kw{array}
template drive caller. 
If \kw{num\_template\_drive\_callers} is exactly 1, only a single
template drive caller is actually constructed, thus avoiding the overhead 
related to the handling of the drive caller array.    

Also the \kw{template drive} can be re-parsed; in this case, the syntax
of the \kw{hint} is:
\begin{verbatim}
    "drive<n>{ <entity> , <drive_caller> }"
\end{verbatim}
For example, a \kw{Vec3} drive hint is:
\begin{verbatim}
    "drive3{ 1., 0., 0. , sine, 0., 2*pi, 1., forever, 0.}"
\end{verbatim}



\input{scalarfunctions.tex}


\section{Friction}
Any friction-enabled joint need the definition of
at least a \kw{friction model} and of a \kw{shape function}.
\subsection{Friction models}
The \kw{friction model} input format is:
\begin{verbatim}
    <friction_model> ::= <friction_type> ,
        <friction_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{modlugre}\\
    This friction model is based on 
    Pierre Dupont, Vincent Hayward, Brian Armstrong and
    Friedhelm Altpeter, Single State Elasto-Plastic Friction Models,
    IEEE Transactions on Automatic Control, June 2002. The input format is:
    \begin{verbatim}
    <friction_model> ::= modlugre
    <friction_arglist> ::=
        <sigma0>,
        <sigma1>,
        <sigma2>,
        <kappa>,
        <friction_function>
    <sigma0> ::= <const_value>
    <sigma1> ::= <const_value>
    <sigma2> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    \item \kw{discrete coulomb}\\
    This is a Coulomb model with viscous friction and
    internal states to resolve stick/slip conditions.
    \begin{verbatim}
    <friction_model> ::= discrete coulomb
    <friction_arglist> ::=
        [ sigma2 , <sigma2> , ]
        [ velocity ratio , <vel_ratio> , ]
        <friction_function>
    <sigma2> ::= <const_value>
    <vel_ratio> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    where \kw{sigma2} gives the viscous friction;
    \kw{velocity ratio} defaults to 0.8, and is used
    to discriminate stick/slip conditions
\end{enumerate}
where \kw{friction\_function} give the static friction
as a function of sliding velocity.
\subsection{Shape functions}
A \kw{shape function} input format is:
\begin{verbatim}
    <shape_function> ::= <shape_function_type> ,
        <shape_function_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{simple}\\
    This shape function is equal to one. It does not need arguments.
    \begin{verbatim}
    <shape_function> ::= simple
    <shape_function_arglist> ::=
    \end{verbatim}
    \item \kw{simple plane hinge}
    \begin{verbatim}
    <shape_function> ::= simple plane hinge
    <shape_function_arglist> ::= <radius>
    <radius> ::= <const_value>
    \end{verbatim}
    This is the shape function of a \kw{revolute hinge} with radius equal to 
    \kw{radius} and subject to small loads.
\end{enumerate}
\section{Shapes}
The \kw{shape} entities are objects that return a value depending on one
(or two, for 2D shapes) dimensionless abscissa, ranging $ \sqbr{-1,1} $.
At present, only 1D shapes are used, by aerodynamic elements.
A \kw{shape} input format is:
\begin{verbatim}
    <shape_1D> ::= <shape_type> ,
        <shape_arglist>
\end{verbatim}
The shapes currently available are:
\begin{enumerate}
    \item \kw{const}
    \begin{verbatim}
    <shape_type> ::= const
    <shape_arglist> ::= <const_value>
    \end{verbatim}
    \item \kw{linear}
    \begin{verbatim}
    <shape_type> ::= linear
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_1>
    \end{verbatim}
    \item \kw{piecewise linear}
    \begin{verbatim}
    <shape_type> ::= piecewise linear
    <shape_arglist> ::=
        <number_of_points> , 
            <abscissa> , <value>
            [ , ... ]
    \end{verbatim}
    \item \kw{parabolic}
    \begin{verbatim}
    <shape_type> ::= parabolic
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_0> , 
        <value_at_1>
    \end{verbatim}
\end{enumerate}
This form of input has been chosen since, being the shapes mainly used to
interpolate values, it looks more ``natural'' to insert the mapping values
at characteristic points.
For \kw{piecewise linear} shapes, there must be 
\kw{number\_of\_points} pairs of absciss\ae\ and values; absciss\ae\
must be in the range $\sqbr{-1,1}$, in strict ascending order.


\section{Constitutive Laws}\label{sec:CONSTITUTIVE-LAWS}
Every time a ``deformable'' entity requires a constitutive law, a template
constitutive law is read. This has been implemented by means of C++
templates in order to allow the definition of a general constitutive law
when possible.
The ``deformable'' elements at present are:
\begin{itemize}
\item \htmlref{\kw{rod}}{sec:EL:STRUCT:JOINT:ROD}
	element (1D);
\item \htmlref{\kw{deformable hinge}}{sec:EL:JOINT:DEFORMABLEHINGE}
	and \htmlref{\kw{deformable displacement joint}}{sec:EL:JOINT:DEFORMABLEDISP}
	elements (3D);
\item \htmlref{\kw{deformable joint}}{sec:EL:JOINT:DEFORMABLEJOINT}
	and \htmlref{\kw{beam}}{sec:EL:BEAM}
	elements (6D).
\end{itemize}

Constitutive laws are also used in non-structural components,
to allow some degree of generality in defining input/output relationships.
Some constitutive laws are meaningful only when related to some precise
dimensionality. 
In some special cases, general purpose (\htmlref{\kw{genel}}{sec:EL:GENEL})
elements use 1D constitutive laws to express an arbitrary dependence
of some value on a scalar state of the system.
Table~\ref{tab:CONST-LAW-DIM} shows the availability of each constitutive law.

The meaning of the input and output parameters of a constitutive law
is dictated by the entity that uses it.
In general, the user should refer to the element the constitutive law
is being instantiated for in order to understand what the input
and the output parameters are supposed to be.

Usually, constitutive laws can be directly defined when required,
according to the definition of an element.
However, the special card described in Section~\ref{sec:CONSTITUTIVE-LAW}
allows to define constitutive laws stand-alone, and attach them
to the elements by means of the following mechanism:
\begin{verbatim}
    <constitutive_law> ::=
        { <constitutive_law_definition>
            | <constitutive_law_reference> }

    <constitutive_law_reference> ::= reference , <label>
\end{verbatim}
where \kw{<constitutive\_law\_definition>} is described in the following,
while \kw{<label>} is the label of a previously defined constitutive law
of the appropriate dimensionality, as described
in Section~\ref{sec:CONSTITUTIVE-LAW}.



\begin{table}[h]
    \newlength{\constlawwidth}
    \setlength{\constlawwidth}{70mm}
    \centering
    \caption{Constitutive laws dimensionality}\label{tab:CONST-LAW-DIM}
    \begin{tabular}{l|c|c|c} 
        \hline
        \multicolumn{1}{c}{\textbf{Constitutive Law}} &
	\multicolumn{1}{c}{\textbf{1D}} &
	\multicolumn{1}{c}{\textbf{3D}} &
	\multicolumn{1}{c}{\textbf{6D}} \\ 
	\hline
	linear elastic, linear elastic isotropic			& $\surd$ & $\surd$ & $\surd$ \\
	linear elastic generic						& $\surd$ & $\surd$ & $\surd$ \\
	linear elastic generic axial torsion coupling			&         &         & $\surd$ \\
	cubic elastic generic						& $\surd$ & $\surd$ &         \\
	log elastic							& $\surd$ &         &         \\
	linear elastic generic bi-stop					& $\surd$ & $\surd$ & $\surd$ \\
	double linear elastic						& $\surd$ & $\surd$ &         \\
	isotropic hardening elastic					& $\surd$ & $\surd$ & $\surd$ \\
	scalar function elastic, scalar function elastic isotropic	& $\surd$ & $\surd$ & $\surd$ \\
	scalar function elastic orthotropic				& $\surd$ & $\surd$ & $\surd$ \\
	linear viscous, linear viscous isotropic			& $\surd$ & $\surd$ & $\surd$ \\
	linear viscous generic						& $\surd$ & $\surd$ & $\surd$ \\
	linear viscoelastic, linear viscoelastic isotropic		& $\surd$ & $\surd$ & $\surd$ \\
	linear viscoelastic generic					& $\surd$ & $\surd$ & $\surd$ \\
	linear viscoelastic generic axial torsion coupling		&         &         & $\surd$ \\
	cubic viscoelastic generic					& $\surd$ & $\surd$ &         \\
	double linear viscoelastic					& $\surd$ & $\surd$ &         \\
	turbulent viscoelastic						& $\surd$ &         &         \\
	linear viscoelastic generic bi-stop				& $\surd$ & $\surd$ & $\surd$ \\
	shock absorber							& $\surd$ &         &         \\
	symbolic elastic						& $\surd$ & $\surd$ & $\surd$ \\
	symbolic viscous						& $\surd$ & $\surd$ & $\surd$ \\
	symbolic viscoelastic						& $\surd$ & $\surd$ & $\surd$ \\
	ann elastic							& $\surd$ & $\surd$ & $\surd$ \\
	ann viscoelastic						& $\surd$ & $\surd$ & $\surd$ \\
	nlsf elastic							& $\surd$ & $\surd$ & $\surd$ \\
	nlsf viscous							& $\surd$ & $\surd$ & $\surd$ \\
	nlsf viscoelastic						& $\surd$ & $\surd$ & $\surd$ \\
	nlp elastic							& $\surd$ & $\surd$ & $\surd$ \\
	nlp viscous							& $\surd$ & $\surd$ & $\surd$ \\
	nlp viscoelastic						& $\surd$ & $\surd$ & $\surd$ \\
	\hline
	invariant angular (wrapper)					&         & $\surd$ &         \\
	\hline
    \end{tabular}
\end{table}

The constitutive laws are entered as follows:
\begin{verbatim}
    <constitutive_law_definition> ::= <specific_const_law>
        [ , prestress, (entity) <prestress> ]
        [ , prestrain, (entity_tpl_driver) <prestrain> ]
    <specific_const_law> ::= <const_law_name> ,
        <const_law_data>
\end{verbatim}
where \kw{const\_law\_name} is the name of the constitutive law and
\kw{const\_law\_data} depends on the specific constitutive law. 
The latter fields, whose type depends on the dimensionality of the
constitutive law, are optional, under the assumption that the
constitutive law is the last portion of a card, or that any ambiguity 
can be avoided.
The data specific to the currently available constitutive laws must be
entered as follows:


\subsection{Linear elastic, linear elastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic [ isotropic ] , 
        (scalar) <stiffness>
\end{verbatim}
the isotropic stiffness coefficient; the word \kw{isotropic}
can be omitted, essentially because it has no meaning
for scalar constitutive laws.

\paragraph{Example.} \
\begin{verbatim}
    constitutive law: 1, name, "scalar isotropic law",
        1, linear elastic, 1.e9;
    constitutive law: 2, name, "3D isotropic law",
        3, linear elastic isotropic, 1.e9;
    constitutive law: 3, name, "6D isotropic law",
        6, linear elastic isotropic, 1.e9;
\end{verbatim}
  
  
\subsection{Linear elastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic generic ,  
        (derivative_of_entity) <stiffness>
\end{verbatim}
the stiffness matrix. In case of 1D, the type is scalar, 
and there is no distinction between \kw{generic} and \kw{isotropic}, 
while, in case of \kw{n x 1} vectors, the type is the corresponding 
\kw{n x n} matrix.

\paragraph{Example.} \
\begin{verbatim}
    constitutive law: 1, name, "scalar isotropic law",
        1, linear elastic generic, 1.e9;
    constitutive law: 2, name, "3D isotropic law",
        3, linear elastic generic,
            sym, 1.e9,  0.,    0.,
                        1.e6, -1.e5,
                               1.e6;
    constitutive law: 3, name, "6D isotropic law",
        6, linear elastic generic,
            diag, 1.e9, 1.e9, 1.e9, 1.e6, 1.e6, 1.e6;
\end{verbatim}
  

\subsection{Linear elastic generic axial torsion coupling}
\label{sec:CONSTITUTIVE-LAWS:LINEAR-ELASTIC-GENERIC-AXIAL-TORSION-COUPLING}
\begin{verbatim}
    <specific_const_law> ::= 
        linear elastic generic axial torsion coupling ,  
            (derivative_of_entity) <stiffness> ,
            (scalar) <coupling_coefficient>
\end{verbatim}
this is defined only for \kw{6 x 1} vectors, where the torsion stiffness,
coefficient $ a_{44} $ in the stiffness matrix, depends linearly on 
the axial strain, $ \varepsilon_1 $, by means of 
\kw{coupling\_coefficient}, i.e.\ the run-time torsion stiffness is 
\begin{displaymath}
	a_{44} = GJ + \mathtt{coupling\_coefficient} \cdot \varepsilon_1 .
\end{displaymath}
This \kw{<coupling\_coefficient>}, in the classical nonlinear beam theory,
is estimated according to some geometric property \cite{HOUBOLT-BROOKS-1957};
a general approach to the computation of prestressed beam properties
is presented in \cite{BORRI-MERLINI}, which is implemented in some versions
of the ANBA software.

\subsection{Cubic elastic generic}
\begin{verbatim}
    <specific_const_law> ::= 
        cubic elastic generic
            (entity) <stiffness1> ,
            (entity) <stiffness2> ,
            (entity) <stiffness3>
\end{verbatim}
this is defined only for scalar and \kw{3 x 1} vectors; the constitutive
law is written according to the formula
\begin{displaymath}
	F = \mathtt{stiffness1} \cdot \varepsilon
	+ \mathtt{stiffness2} \cdot \shbr{\varepsilon}\varepsilon
	+ \mathtt{stiffness3} \cdot \varepsilon^3
\end{displaymath}
and it is mainly intended for use with human body models 
where the stiffness of the joints is typically given in this form.

\subsection{Log elastic}
\begin{verbatim}
    <specific_const_law> ::= log elastic ,
        (derivative_of_entity) <stiffness>      
\end{verbatim}
this is defined only for scalars. The force is defined as:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \llk{log}\plbr{1+\varepsilon}
\end{displaymath}
  
\subsection{Linear elastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic bistop,
        (derivative_of_entity) <stiffness> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{Double linear elastic}
\begin{verbatim}
    <specific_const_law> ::= double linear elastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2>
\end{verbatim}
this is defined for scalar and \kw{3 x 1} vectors. In the scalar case the
meaning of the entries is straightforward, while in case of \kw{3 x 1} vectors,
the constitutive law is isotropic but in the local direction 3, where, in
case of strain out of the upper or lower bound, the \kw{stiffness\_2} is
used.

\subsection{Isotropic hardening elastic}
\begin{verbatim}
    <specific_const_law> ::= isotropic hardening elastic ,
        (scalar) <stiffness> ,
        (scalar) <reference_strain>
        [ , linear stiffness , <linear_stiffness> ]
\end{verbatim}
this constitutive law is defined as follows:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \frac{
        \beta + \alpha\shbr{\T{\varepsilon}}^2
    }{
        1 + \alpha\shbr{\T{\varepsilon}}^2
    }\varepsilon
\end{displaymath}
where $\alpha=3/\shbr{\kw{reference\_strain}}^2$,
and $\beta=\kw{linear\_stiffness}/\kw{stiffness}$.
The resulting constitutive law, in the scalar case,
is somewhat soft/hard when $\beta$ is lower/greater than 1
and $\shbr{\varepsilon}$ is smaller than \kw{reference\_strain},
approaching \kw{linear\_stiffness} when $\varepsilon\rightarrow{0}$,
while it grows to quasi-linear for larger $\shbr{\varepsilon}$, 
with slope $\kw{stiffness}$.

\subsection{Scalar function elastic, scalar function elastic isotropic}
This constitutive law is based on a 
\htmlref{\kw{scalar function} (Section~\ref{sec:SCALARFUNCS})}
	{sec:SCALARFUNCS}
to represent an analytical force-displacement curve 
of a single variable that is automatically differentiated 
to compute the slope of the curve, namely the local stiffness.
\begin{verbatim}
    <specific_const_law> ::= scalar function elastic isotropic ,
        (DifferentiableScalarFunction)<function>
\end{verbatim}
this constitutive law is defined as follows:
\begin{displaymath}
	f_i = \mathtt{<function>}\plbr{\T{\varepsilon}_i}
\end{displaymath}
the force is computed for each direction as a function of the respective
strain component using the same function.
When used for 1D elements, the word \kw{isotropic} can be omitted.

\subsection{Scalar function elastic orthotropic}
\begin{verbatim}
    <specific_const_law> ::= scalar function elastic orthotropic ,
        { (DifferentiableScalarFunction)<function> | null }
        [ , ... ]
\end{verbatim}
this constitutive law is defined as follows:
\begin{displaymath}
	f_i = \mathtt{<function>}_i\plbr{\T{\varepsilon}_i}
\end{displaymath}
the force is computed for each direction as a function of the respective
strain component using a specific function for each component.
If no force ought to be used for a direction, for example because 
that direction is constrained by a kinematic joint, the keyword \kw{null}
can be used to indicate that no function is expected for that component.
When used for 1D elements, the word \kw{orthotropic} can be omitted;
note that in this case a \kw{scalar function elastic isotropic}
constitutive law is actually instantiated.

\paragraph{Example.} \
\begin{verbatim}
    scalar function: "myfunc", multilinear,
        -1., -100.,
        -.5, -70.,
        0., 0.,
        .5, 70.,
        1., 100.;
    constitutive law: 1000, 3,
        scalar function elastic orthotropic,
            null,
            null,
            "myfunc";
\end{verbatim}
indicates that the constitutive law is only defined in direction 3 
as a multilinear function.

\subsection{Linear viscous, linear viscous isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous [ isotropic ] , 
        (scalar) <viscosity_coefficient>
\end{verbatim}
the linear viscous coefficient. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscous generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous generic , 
        (derivative_of_entity) <viscosity_matrix>
\end{verbatim}
the linear viscous matrix. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscoelastic, linear viscoelastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic [ isotropic ] ,
        (scalar) <stiffness> ,
        { (scalar) <viscosity_coefficient>
        | proportional, (scalar) <factor> }
\end{verbatim}
the isotropic stiffness and viscosity coefficients.
  
\subsection{Linear viscoelastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic generic ,  
        (derivative_of_entity) <stiffness> ,
        { (derivative_of_entity) <viscosity_matrix> 
        | proportional, (scalar) <factor> }
\end{verbatim}
the linear stiffness and viscosity matrices.
  
\subsection{Linear viscoelastic generic axial torsion coupling}
\begin{verbatim}
    <specific_const_law> ::= 
        linear viscoelastic generic axial torsion coupling ,  
            (derivative_of_entity) <stiffness> ,
            { (derivative_of_entity) <viscosity_matrix> 
            | proportional, (scalar) <factor> }
            (scalar) <coupling_coefficient>
\end{verbatim}
this is defined only for \kw{6 x 1} vectors; it is the viscoelastic 
extension of the 
\hyperref{\kw{linear elastic generic axial torsion coupling} constitutive law}{\kw{linear elastic generic axial torsion coupling} constitutive law (see Section~}{)}{sec:CONSTITUTIVE-LAWS:LINEAR-ELASTIC-GENERIC-AXIAL-TORSION-COUPLING}.


\subsection{Cubic viscoelastic generic}
\begin{verbatim}
    <specific_const_law> ::= 
        cubic elastic generic
            (entity) <stiffness1> ,
            (entity) <stiffness2> ,
            (entity) <stiffness3> ,
            (derivative_of_entity) <viscosity_matrix> 
\end{verbatim}
this is defined only for scalar and \kw{3 x 1} vectors; the constitutive
law is written according to the formula
\begin{displaymath}
	F = \mathtt{stiffness1} \cdot \varepsilon
	+ \mathtt{stiffness2} \cdot \shbr{\varepsilon}\varepsilon
	+ \mathtt{stiffness3} \cdot \varepsilon^3
	+ \mathtt{viscosity\_matrix} \cdot \dot{\varepsilon}
\end{displaymath}
and it is mainly intended for use with human body models 
where the stiffness of the joints is typically given in this form.

\subsection{Double linear viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= double linear viscoelastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2> ,
        (scalar) <viscosity_coefficient>
        [ , second damping , (scalar) <viscosity_coefficient_2> ]
\end{verbatim}
this is analogous to the \kw{double linear elastic} constitutive law,
except for the isotropic viscosity term.
The second viscosity value is used when the strain is outside the
\kw{lower\_strain}-\kw{upper\_strain} range.

When this constitutive law is used with \kw{3 x 1} vectors, 
the double linear elastic and viscous term only applies to component 3.
  
\subsection{Turbulent viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= turbulent viscoelastic ,
        (scalar) <stiffness> ,
        (scalar) <parabolic_viscous_coefficient>
        [ , (scalar) <threshold> 
            [ , (scalar) <linear_viscous_coefficient> ] ]
\end{verbatim}
the constitutive law has the form:
\begin{displaymath}
    \T{f} \ = \ \kw{stiffness} \ \T{\varepsilon} + k \ \dot{\T{\varepsilon}}
\end{displaymath}
where:
\begin{displaymath}
    k = \lcubr{\matr{lcr}{
        \kw{linear\_viscous\_coefficient} & & 
            \shbr{\dot{\T{\varepsilon}}} \leq \kw{threshold} \\
        \kw{parabolic\_viscous\_coefficient} & &
            \shbr{\T{\dot{\varepsilon}}} > \kw{threshold}
    }}
\end{displaymath}
if \kw{threshold} is null, or not defined, the constitutive law is always
parabolic. If the \kw{linear\_viscous\_coefficient} is not defined, it is
computed based on \kw{parabolic\_viscous\_coefficient} and on 
\kw{threshold} to give a continuous force curve (with discontinuous slope).
Otherwise, it can be set by the user to give a discontinuous force curve,
as observed in some fluids at intermediate Reynolds number.

\subsection{Linear viscoelastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic bistop ,
        (derivative_of_entity) <stiffness> ,
        (derivative_of_entity) <viscosity_coefficient> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{GRAALL damper}
This is a very experimental constitutive law, based on a nonlinear model
for a hydraulic damper to be used in landing gear modeling.
Basically, it requires the user to supply the name of the GRAALL-style 
input file with damper data.
It will be documented as soon as it reaches an appreciable level of
stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL:SHOCK-ABSORBER}
constitutive law.


\subsection{shock absorber}\label{sec:CL:SHOCK-ABSORBER}
This constitutive law implements a landing gear hydraulic shock absorber:
\begin{verbatim}
    <specific_const_law> ::= shock absorber ,
        [ prestrain , <value> , ]
        <reference pressure> ,
        <reference area for force computation> ,
        <interaction coefficient> ,
        <polytropic exponent> ,
        [ epsilon max , <upper strain bound> , ]
        [ epsilon min , <lower strain bound> , ]
        [ penalty , <penalty factor for strain> , 
            <penalty factor for strain rate> , ]
        [ metering , <metering area> ,
            [ negative , <metering area for negative strain rate> , ]
        [ orifice , <orifice area> , ]
        <fluid area> ,
        <fluid density> ,
        <drag coefficient / reference length
                (scales strain rate to velocity)>
        [ , friction, <reference epsilon prime> ,
                 <friction amplitude coefficient> ]
\end{verbatim}
where
\begin{itemize}
\item the \kw{interaction coefficient} is represented by
\begin{displaymath}
	\kw{kinematic scale} \frac{L A}{V_0}
\end{displaymath}
where \kw{kinematic scale} is the ratio between the stroke
of the shock absorber and that of the gas;
\item \kw{epsilon max} is the upper strain bound; it must be
at least larger than the prestrain, and defaults to 0,
i.e.\ the shock absorber, at rest, is assumed to be fully
extended;
\item \kw{epsilon min} is the lower strain bound; it must be
at least smaller than the prestrain, and defaults to -0.5, 
i.e.\ the shock absorber is assumed to allow a contraction
equal to half its full length;
\item the \kw{penalty factor for strain} defaults to 1e+9;
it is active only when strain bounds are violated;
\item the \kw{penalty factor for strain rate} defaults to 0;
it is active only when strain bounds are violated;
\item the \kw{metering area} is given by a \kw{drive} 
and is strain dependent; if the keyword \kw{negative} is used, 
then the \kw{metering area for negative strain rate} is used
when the strain rate is negative, i.e.\ the shock absorber
is being compressed, while the \kw{metering area} is used only
when the shock absorber is extending;
\item the \kw{<orifice>} drive determines the area of an
additional orifice, which essentially depends on the sign
of the strain rate; it is used to implement relief valves;
\item ...
\end{itemize}
This constitutive law adds the entities described
in Table~\ref{tab:CL:SHOCK-ABSORBER-OUTPUT} to the output of the
element it is used for.
The table also indicates the names that can be used to reference
the entities as element private data.

\begin{table}
\centering
\caption{Shock absorber output data}\label{tab:CL:SHOCK-ABSORBER-OUTPUT}
\begin{tabular}{ll}
\hline
\multicolumn{1}{c}{\textbf{entity}} &
\multicolumn{1}{c}{\textbf{name}} \\
\hline
gas pressure	& \kw{p} \\
metering area	& \kw{A} \\
elastic force	& \kw{Fe} \\
viscous force	& \kw{Fv} \\
\hline
\end{tabular}
\end{table}

\subsection{symbolic elastic}\label{sec:CL:SYMBOLIC-ELASTIC}
The implementation  of the family of \kw{symbolic} constitutive laws
is based on GiNaC 
(\htmladdnormallink{\kw{http://www.ginac.de/}}{http://www.ginac.de/}),
a free software package for symbolic algebra manipulation.
It is essentially used to automatically differentiate
the user-supplied expression that describes the relationship
between the output and the input.

The syntax is
\begin{verbatim}
    <specific_const_law> ::= symbolic elastic ,
        epsilon , " <epsilon> " ,
        expression , " <expression> "
\end{verbatim}
where \kw{epsilon} is the symbol describing the input
parameter as it will be used in \kw{expression}.

For constitutive laws with more than one dimension,
a string for each \kw{epsilon} and one for each \kw{expression}
are expected.  For example:
\begin{verbatim}
    # 1D symbolic constitutive law
    constitutive law: 1001, 1, symbolic elastic,
        epsilon, "eps",
        expression, "1000.*eps + 5.*eps^3";
    # 3D symbolic constitutive law
    constitutive law: 1003, 3, symbolic elastic,
        epsilon, "eps1", "eps2", "eps3",
        expression,
            "1000.*eps1 + 5.*eps1^3 - 10.*eps2*eps3",
            "1000.*eps2 + 5.*eps2^3 - 10.*eps3*eps1",
            "1000.*eps3 + 5.*eps3^3 - 10.*eps1*eps2";
\end{verbatim}

\emph{Note: right now, the symbols defined within the mathematical parser
are not available within symbolic consitutive laws.}

\subsection{symbolic viscous}\label{sec:CL:SYMBOLIC-VISCOUS}
The syntax is
\begin{verbatim}
    <specific_const_law> ::= symbolic viscous ,
        epsilon prime , " <epsilon_prime> " ,
        expression , " <expression> "
\end{verbatim}
where \kw{epsilon\_prime} is the symbol describing the derivative
of the input parameter as it will be used in \kw{expression}.

For constitutive laws with more than one dimension,
a string for each \kw{epsilon\_prime} and one for each \kw{expression}
are expected.

\subsection{symbolic viscoelastic}\label{sec:CL:SYMBOLIC-VISCOELASTIC}
The syntax is
\begin{verbatim}
    <specific_const_law> ::= symbolic viscoelastic,
        epsilon , " <epsilon> " ,
        epsilon prime , " <epsilon_prime> " ,
        expression , " <expression> "
\end{verbatim}
where \k{epsilon} and \kw{epsilon\_prime} are the symbols describing 
the input parameter and its derivative as they will be used
in \kw{expression}.

For constitutive laws with more than one dimension,
a string for each \kw{epsilon}, one for each \kw{epsilon\_prime},
and one for each \kw{expression} are expected.

\subsection{ann elastic}\label{sec:CL:ANN-ELASTIC}
The implementation  of the family of \kw{ann} constitutive laws
is based on an Artifical Neural Network library that is embedded in MBDyn.

The syntax is
\begin{verbatim}
    <specific_const_law> ::= ann elastic ,
        " <file_name> "
\end{verbatim}
where the file \kw{file\_name} contains the parameters of the network.
What is mainly significant to users is the need to scale inputs and outputs
to match the amplitudes and possibly the offsets used in the training.
For this purpose, the last two rows of the input files contain coefficients
\begin{verbatim}
    b1 b0
    a1 a0
\end{verbatim}
which are used to scale the input $u$ and the output $y$ according
to the transformation
\begin{align}
	\overline{u} &= b_1 u + b_0 \\
	\overline{y} &= a_1 y + a_0
\end{align}
so that the actual output is
\begin{equation}
	y = \frac{f\plbr{b_1 u + b_0} - a_0}{a_1}
\end{equation}

\subsection{ann viscoelastic}\label{sec:CL:ANN-VISCOELASTIC}
The syntax is
\begin{verbatim}
    <specific_const_law> ::= ann viscoelastic ,
        " <file_name> "
\end{verbatim}
where the file \kw{file\_name} contains the parameters of the network.

\subsection{nlsf viscoelastic}
\emph{This constitutive law was sponsored
by \htmladdnormallink{Hutchinson}{http://www.hutchinson.fr} CdR.}
\bigskip

For an $n$-dimensional constitutive law, it implements the formula
\begin{equation}
        f_i
        = \sum_{j=1,n} k'_{0ij} \varepsilon_j
        + f'_i\plbr{\varepsilon_i}
        + \sum_{j=1,n} k''_{0ij} \dot{\varepsilon}_j
        + f''_i\plbr{\dot{\varepsilon_i}}
        \label{eq:nlsf-cl}
\end{equation}
where $f'_i$ and $f''_i$ are arbitrary instances
of the \htmlref{\kw{scalar functions}}{sec:SCALARFUNCS} primitive,
which includes piecewise linear and spline regularization
of given data, while $k'_{0ij}$ and $k''_{0ij}$ are the constant
coefficients of a linear viscoelastic model, that account
for the cross-couplings between the stresses 
and the strains and strain rates.

Elastic and viscous variants are defined.
They differ from the viscoelastic one by only allowing
the specific fraction of the input data.

\paragraph{Syntax.}
\label{sec:CL:nlsf-syntax}
The syntax is
\begin{verbatim}
    <specific_const_law> ::= nlsf viscoelastic ,
        (derivative_of_entity) <kappa_0'> ,
        { null | (scalar_function) <diag_force'> }
        [ , ... ] ,
        { (derivative_of_entity) <kappa_0''> | proportional , <coef> } ,
        { null | (scalar_function) <diag_force''> }
        [ , ... ]

    <specific_const_law> ::= nlsf elastic ,
        (derivative_of_entity) <kappa_0'> ,
        { null | (scalar_function) <diag_force'> }
        [ , ... ]

    <specific_const_law> ::= nlsf viscous ,
        (derivative_of_entity) <kappa_0''> ,
        { null | (scalar_function) <diag_force''> }
        [ , ... ]
\end{verbatim}
The terms \texttt{kappa\_0'} and \verb1kappa_0''1 are indicated as
``derivative of entity'' because in the generic case they are the result
of a differential operator that computes the derivative of the force vector
as function of the strain or strain rate vectors.
So, for a 3D constitutive law, the force, the strain and the strain rate
are $3\times 1$ vectors, while \texttt{kappa\_0'} and \verb1kappa_0''1
are $3\times 3$ matrices.
Matrix input, in MBDyn, requires to write the whole set of coefficients,
row-wise; however, it can be described in many synthetic manners if
matrices have some special properties, as typical linear constitutive laws do.

For example, symmetric, diagonal and empty matrices have specific
short forms; in the $3\times 3$ case they are
\begin{verbatim}
        # generic 3x3 matrix:
        10., -2., -2.,
        -2., 20., -8.,
        -2., -8., 20.

        # symmetric 3x3 matrix (same as above matrix):
        sym,
        10., -2., -2.,
             20., -8.,
                  20.

        # diagonal 3x3 matrix (diagonal of above matrix):
        diag,
        10., 20., 20.

        # empty 3x3 matrix:
        null
\end{verbatim}
The terms \texttt{diag\_force'} and \verb1diag_force''1 refer
to the names of the scalar functions that are defined for each component
of the force vector.
There must be as many terms as the dimensions of the constitutive law.
These terms can either be \texttt{null}, if no non-linear contribution
is defined for that component, or contain a string, enclosed in double quotes,
which must refer to an already defined scalar function.
The same scalar function can be used multiple times.


\paragraph{Example.} \
A 1D and a 3D constitutive law using the same exponential scalar function:
\begin{verbatim}
    # define a scalar function
    scalar function: "exponential", exp, coefficient, -2., 5.;

    # define a 1D constitutive law
    constitutive law: 1000, 1,
        nlsf viscoelastic,
            10.,
                null,               # stiffness is just linear
            0.,
                "exponential";      # damping is exponential

    # define a 3D constitutive law
    constitutive law: 3000, 3,
        nlsf viscoelastic,
            sym,
                10., -2., -2.,
                     10., -2.,
                          10.,
                null,               # stiffness is just linear
                null,               # stiffness is just linear
                null,               # stiffness is just linear
            null,
                "exponential",      # damping is exponential...
                null,               # ...but in direction 1 only!
                null;
\end{verbatim}
The first constitutive law corresponds to
\begin{equation}
        f = 10.0 \cdot \varepsilon
        + 5.0 \cdot \mathrm{e}^{-2 \dot{\varepsilon}}
\end{equation}
while the second one corresponds to
\begin{equation}
        \T{f} = \sqbr{\matr{ccc}{
                10.0 & -2.0 & -2.0 \\
                -2.0 & 10.0 & -2.0 \\
                -2.0 & -2.0 & 10.0
        }} \cubr{\cvvect{
                \varepsilon_1 \\
                \varepsilon_2 \\
                \varepsilon_3
        }} + \cubr{\cvvect{
                5.0 \cdot \mathrm{e}^{-2 \dot{\varepsilon}_1} \\
                0.0 \\
                0.0
        }}
\end{equation}



\subsection{nlp viscoelastic}
\emph{This constitutive law was sponsored
by \htmladdnormallink{Hutchinson}{http://www.hutchinson.fr} CdR.}
\bigskip

This constitutive law consists in the linear combination
of nonlinear elastic and viscous effects whose coefficients
are arbitrary nonlinear functions of the strain $\varepsilon$:
\begin{equation}
	f_i = \sum_{j=1,3} \plbr{
		k'_{0ij} + \delta_{ij} k_i'\plbr{\varepsilon_i}
	} \varepsilon_j
	+ \sum_{j=1,3} \plbr{
		k''_{0ij} + \delta_{ij} k''_i\plbr{\varepsilon_i}
	} \dot{\varepsilon}_j ,
	\label{eq:nlp-cl}
\end{equation}
where $\delta_{ij}$ is Kronecker's operator;
$k'_i$ and $k''_i$ are implemented as arbitrary
\htmlref{\kw{scalar functions}}{sec:SCALARFUNCS},
which includes piecewise linear and spline regularization
of given data.

Elastic and viscous variants are defined.
They differ from the viscoelastic one by only allowing
the specific fraction of the input data.

\paragraph{Syntax.}
The syntax is
\begin{verbatim}
    <specific_const_law> ::= nlp viscoelastic ,
        (derivative_of_entity) <kappa_0'> ,
        { null | (scalar_function) <diag_stiffness> }
        [ , ... ] ,
        { (derivative_of_entity) <kappa_0''> | proportional , <coef> } ,
        { null | (scalar_function) <diag_damping> }
        [ , ... ]

    <specific_const_law> ::= nlp elastic ,
        (derivative_of_entity) <kappa_0'> ,
        { null | (scalar_function) <diag_stiffness> }
        [ , ... ]

    <specific_const_law> ::= nlp viscous ,
        (derivative_of_entity) <kappa_0''> ,
        { null | (scalar_function) <diag_damping> }
        [ , ... ]
\end{verbatim}

\paragraph{Example.} \
A 1D and a 3D constitutive law using the same exponential scalar function:
\begin{verbatim}
    # define a scalar function
    scalar function: "exponential", exp, coefficient, -2., 5.;

    # define a 1D constitutive law
    constitutive law: 1000, 1,
        nlp viscoelastic,
            10.,
                null,               # stiffness is just linear
            0.,
                "exponential";      # damping slope is exp.

    # define a 3D constitutive law
    constitutive law: 3000, 3,
        nlp viscoelastic,
            sym,
                10., -2., -2.,
                     10., -2.,
                          10.,
                null,               # stiffness is just linear
                null,               # stiffness is just linear
                null,               # stiffness is just linear
            null,
                "exponential",      # damping slope is exp...
                null,               # ...but in direction 1 only!
                null;
\end{verbatim}
The first constitutive law corresponds to
\begin{equation}
        f = 10.0 \cdot \varepsilon
        + 5.0 \cdot \mathrm{e}^{-2 \varepsilon} \cdot \dot{\varepsilon}
\end{equation}
while the second one corresponds to
\begin{equation}
        \T{f} = \sqbr{\matr{ccc}{
                10.0 & -2.0 & -2.0 \\
                -2.0 & 10.0 & -2.0 \\
                -2.0 & -2.0 & 10.0
        }} \cubr{\cvvect{
                \varepsilon_1 \\
                \varepsilon_2 \\
                \varepsilon_3
        }} + \sqbr{\matr{ccc}{
                5.0 \cdot \mathrm{e}^{-2 \varepsilon_1} & 0.0 & 0.0 \\
                0.0 & 0.0 & 0.0 \\
                0.0 & 0.0 & 0.0
        }} \cubr{\cvvect{
                \dot{\varepsilon}_1 \\
                \dot{\varepsilon}_2 \\
                \dot{\varepsilon}_3
        }}
\end{equation}
Note: although the syntax of this constitutive law
and that of the \texttt{nlsf viscoelastic} one
(Section~\ref{sec:CL:nlsf-syntax})
is essentially identical, their behavior may be quite different,
as indicated by Equations~(\ref{eq:nlsf-cl}) and~(\ref{eq:nlp-cl}).


\subsection{invariant angular}
This is not exactly a constitutive law, but rather a wrapper
for constitutive laws used within the ``attached'' variant
of the \htmlref{\kw{deformable hinge}}{sec:EL:JOINT:DEFORMABLEHINGE} joint.
As such, it can only be used with the 3D dimensionality,
and it basically allows to refer an ancillary 3D constitutive law
to an orientation that is intermediate with respect to the orientations
of the two connected nodes.
\begin{verbatim}
    <specific_const_law> ::= invariant angular ,
        <xi> , <ancillary_const_law>
\end{verbatim}
\kw{xi} is the fraction of relative orientation the ancillary
constitutive law will be referred to, with respect
to the first node of the joint.
Its value should be comprised between 0 (attached to the first node)
and 1 (attached to the second node); a value of 1/2 yields
the \htmlref{\kw{invariant deformable hinge}}{sec:EL:JOINT:INVDEFORMABLEHINGE}
joint, but any value is allowed.

Note: the contribution to the Jacobian matrix will be incomplete
when the underlying constitutive law has a viscous contribution.
This may slow down convergence, or even prevent it.
If this is an issue,
the \htmlref{\kw{invariant deformable hinge}}{sec:EL:JOINT:INVDEFORMABLEHINGE}
should be used, since it does not suffer from this limitation.




\section{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID-DATA}
Hydraulic fluid data defines the constitutive properties
of hydraulic fluids, which are generally required by hydraulic elements.
Hydraulic fluid data can be defined in two ways, according to the BNF:
\begin{verbatim}
    <hydraulic_fluid> ::=
        { <fluid_type> , <fluid_properties>
            | reference, <label> }
\end{verbatim}
The latter references a previously defined hydraulic fluid dataset,
described in Section~\ref{sec:HYDRAULIC-FLUID}.
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are:

\subsection{Incompressible}
\begin{verbatim}
    <fluid_type> ::= incompressible
    <fluid_properties> ::=
        [ density , <density> ]
        [ , viscosity , <viscosity> ]
        [ , pressure , <pressure > ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible}
\begin{verbatim}
    <fluid_type> ::= linear compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ]
        [ , viscosity , <viscosity> ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible, with thermal dependency}
\begin{verbatim}
    <fluid_type> ::= linear thermal compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}

\subsection{Super (linearly compressible, with thermal dependency)}
\begin{verbatim}
    <fluid_type> ::= super
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}
according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 + \rho_{ref}\cfrac{1}{2}\plbr{
			1 + \llk{tanh}\plbr{a\plbr{p-p_{ref}}}
		} & p < p_{ref} \\
		+= \ \cfrac{p-p_{ref}}{\beta} & p > p_{ref}
	}
\end{displaymath}
\emph{Note: highly experimental}

\subsection{Exponential compressible fluid, with saturation}
\begin{verbatim}
    <fluid_type> ::= exponential
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> , ]
        [ viscosity , <viscosity> , ]
        <psat>
\end{verbatim}
where \kw{psat} is the saturation pressure, according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 \e{\cfrac{p-p_0}{\beta}} &
		p > p_{sat} \\
		\rho \ = \ \rho_0 \e{1000\cfrac{p-p_0}{\beta}} &
		p < p_{sat}
	}
\end{displaymath}
\emph{Note: this fluid constitutive law is loosely inspired by AMESim's
simply corrected compressible fluid.}



\section{Authentication Methods}
Some authentication methods are defined and made available to specific
program modules; they are used to authenticate before accessing some
resources of the program while it is running.
The syntax is:
\begin{verbatim}
    <authentication_method> ::= <method> [ , <specific_data> ]
\end{verbatim}
Authentication methods in general expect some authentication tokens to be
input.
Usually a user name and a password are required.

\subsection{Note on security and confidentiality}
No encryption is used in communications, unless provided
by the underlying mechanism (e.g. some SASL mechs), 
so the authentication methods are very rough
and should be considered as insecure.
Secure Socket connection or other SSL-like communication protocol
may be considered in the future.
If confidentiality is required, SASL with at least DIGEST-MD5 
is strongly recommended; otherwise no authentication should be used.
As alternatives, a SSH tunnel may be established between the client
and the server machine, and simple authentication can be used.
Otherwise, if the user has direct access to the server where
the computation is being run, sockets with \kw{local} namespace
can be used, and security can be enforced by means of the access
privileges of the socket file.
Since some of the UN*X systems do not honor socket permissions,
a portable way to exploit filesystem access permissions is to put
the socket in a dedicated directory, and use the permissions
of the directory to control access to the socket.

Available methods are:
\subsection{No authentication}
\begin{verbatim}
    <authentication_method> ::= no auth
\end{verbatim}

\subsection{Password}
\begin{verbatim}
    <authentication_method> ::= password ,
        user , " <user_name> " ,
        credentials , { prompt | " <user_cred> " }
        [ , salt format , <salt_format> ]
\end{verbatim}
In case the keyword \kw{prompt} is given as credentials, the user is
prompted for a password.
The optional parameter \kw{salt\_format} allows to specify different
formats for the \kw{salt}, for those \kw{crypt(3)} extensions 
that support more sophisticated encryption mechanisms (e.g.\ MD5).
See \kw{crypt(3)} for details.
If the credentials are preceded by the string \kw{\{CRYPT\}},
they are assumed to be already encrypted, and the remaining portion is used.

\subsection{PAM (Pluggable Authentication Modules)}
\begin{verbatim}
    <authentication_method> ::= pam 
        [ , user , " <user_name> " ]
\end{verbatim}
The {\em Linux-PAM} Pluggable Authentication Modules can be used to
authenticate a user. 
If no user name is provided, the effective user id, as provided by the 
\kw{geteuid()} system function, is used to retrieve the username of the
owner of mbdyn process.
the \kw{user} must be valid. 
The authentication is performed through a system-dependent \kw{pam}
configuration file.
No checks on the validity of the account or on the permission of opening a
session are made; account, session and password changes should be explicitly
denied to \kw{mbdyn} to avoid possible security breaks (see the following
example).
The interested reader should consult the documentation that comes with the
package, try for instance
\htmladdnormallink{\kw{http://www.kernel.org/pub/linux/libs/pam/\ }}\
for details.

An example is provided with the package, in  \kw{/etc/pam.d/mbdyn}:
\begin{verbatim}
    ### use either of the following:
    auth       required     /lib/security/pam_unix_auth.so
    # auth       required     /lib/security/pam_pwdb.so
    #
    ### no account, session or password allowed
    account    required     /lib/security/pam_deny.so
    session    required     /lib/security/pam_deny.so
    password   required     /lib/security/pam_deny.so
\end{verbatim}
which allows authentication by using standard Un*x or \kw{libpwdb} based
authentication.



\subsection{SASL (Simple Authentication and Security Layer)}
\begin{verbatim}
    <authentication_method> ::= sasl
        [ , user , " <user_name> " ]
        [ , mechanism , " <preferred_mechanism> " ]
\end{verbatim}
This is the preferred authentication method because 
it is mechanism-independent, it can be reasonably secure
and automatically selects the most appropriate mechanism available
on both the client and the server machine.
It requires Cyrus SASL 2 (See 
\htmladdnormallink{\kw{http://asg.web.cmu.edu/sasl/\ }}\
for details, and follow the documentation to obtain a working setup).



\section{Miscellaneous}
Finally there are some miscellaneous points:
\begin{itemize}
    \item (UN*X systems) Environment variables whose name starts with MBDYN may
    be defined and passed to an execution of the mbdyn command.
    The following are recognized at present:
  
    \begin{enumerate}
  
        \item \kw{MBDYNVARS=<expr\_list>}
	where \kw{expr\_list} is a series of mathematical expressions
	separated by semicolons. 
	They are parsed and evaluated; if variables are declared, they are
	added to the symbol table to be used during the whole execution 
	of the program.
    
        \item \kw{MBDYN\_<type>\_<name>=<value>},
	where \kw{type} is a legal mbdyn type (\kw{integer} or \kw{real};
	see Table~\ref{tab:MATHP-TYPES} for details),
	\kw{name} is a legal symbol name and \kw{value} is a legal
	mathematical expression.
    
    \end{enumerate}
    
    \item Newlines and indentations are not meaningful. But good indentation
    habits can lead to better and more readable input files.
    
    \item Everything that follows the character \kw{`\#'} is considered a
    remark, and is discarded until the end of the line. 
    This can occur everywhere in the file, even inside a math expression 
    (if any problems occur, please let me know, because chances are 
    it is a bug!)
    
    \item A new style for comments has been introduced, resembling the 
    C programming language style: everything comprised between the marks
    \kw{/*} and \kw{*/} is regarded as a remark:
\begin{verbatim}
    /*
     * useful comments make input files readable!
     */
\end{verbatim}
    This can happen (almost) everywhere in the text except in the middle 
    of a keyword.
    
    \item (UN*X systems) Whenever a file name contains a portion
    of the form \verb;$VARNAME; or \verb;${VARNAME};, appropriate
    expansion from environment is performed; \verb;VARNAME; is
\begin{verbatim}
    VARNAME ::= [_a-zA-Z][_a-zA-Z0-9]*
\end{verbatim}
    namely, it must begin with a letter or an underscore, and can be
    made of underscores, letters and digits.

    \item (UN*X systems) Whenever a file name is required, the shell-like
    syntax for home directories (i.e.\ \verb1~/filename1
    or \verb1~user/filename1 is automatically resolved if legal [user and]
    filename values are inserted.
    Home expansion occurs after environment variable expansion (see above).

    \item The \kw{license} and the \kw{warranty} statements
    respectively show on the standard output the license 
    and the warranty statement under which the code is released.
    They do not affect the simulation.
    
\end{itemize}
 
