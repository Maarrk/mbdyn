% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2004
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{General}
The input is divided in blocks. 
This is a consequence of the fact that almost every module of the code 
needs data and each module is responsible for its data input. 
So it is natural to make each module read and interpret its data starting 
from the input phase.
Every command (or card) has the following ``grammar'':
\begin{verbatim}
    <card> ::= <description> [ : <arglist> ] ;
\end{verbatim}
\kw{arglist} is a(n optional) list of arguments, that is driven by the 
\kw{description} that identifies the card. 
The keyword can be made of multiple words separated by spaces or tabs; 
the extra spaces are skipped\footnote{
	Anything that makes the C function \kw{isspace()} 
	return \kw{true}
}, and the match is case insensitive. 
The arguments are usually separated by commas\footnote{
	A few exceptions require a colon to separate blocks of arguments;
	wherever it is feasible, those exceptions will be eliminated 
	in future versions.
	Those cards will be marked as deprecated.
}.
A semicolon ends the card. 
Many cards allow extra arguments that assume default values 
if not supplied by the user. 
Usually these arguments are at the end of the card
and must follow some rules. 
A check for the existence of extra args is made,
and they are usually read in a fixed sequence.
When structured arguments like matrices, vectors, or drive callers are
expected, they are parsed by dedicated functions.
Anyway, the structured data always follows the rules of the general data. 
Few exceptions are present, and will be eliminated soon.
Every data block is surrounded by the control statements \kw{begin} and
\kw{end}:
\begin{verbatim}
    begin: <block_name> ;
        ...
    end: <block_name> ;
\end{verbatim}
The general rules follow.



\section{Output}
The program outputs data to a set of files for each simulation.
The contents of each file is related to the file extension,
which is appended to the input file if no output file name 
is explicitly supplied.
If also no input file is explicitly supplied, and input is obtained from 
\kw{stdin}, the output file name defaults to ``MBDyn''; otherwise, 
unless the output file name is explicitly set, the name 
of the input file is used.
The contents of the output files are described accordingly 
to the items (nodes or elements) that generate them.
Only a general information file, with extension \kw{.out}, 
is described here. 
The file contains general information about the simulation; 
it is not formatted. 
In detail, for each step the current time, time step, the number of
iterations and the error are supplied.
There is also a supplementary file, with \kw{.log} extension,
that may contain extra (logging) information.
Its contents are not documented since they are very experimental
and may be subject to changes.



\section{Numeric Values}
Every time a numeric value is expected, the result of evaluating 
a mathematical expression can be used, including variable declaration 
and assignment (variable names and values are kept in memory throughout
the input phase and the simulation) and simple math functions.
Named variables and non-named constants are strongly typed; two types are
currently available, \kw{integer} and \kw{real}.
Operations account for the type and perform implicit cast when allowed.
For instance \kw{1+2.5} returns a \kw{real} whose value 
is \kw{3.5}, since one of the 
two addenda is \kw{real}, while \kw{1/3} returns \kw{0} because 
the integer division is used.
An empty field, delimited by a valid separator (a comma or a semicolon,
depending on whether other arguments are expected or not) returns the
(program supplied) default value for that field, if supplied by the caller, 
otherwise the parser automatically defaults to zero.
Multiple expressions can be used, provided they are enclosed in plain 
brackets and are separated by semicolons; the result 
of the last expression will be used as the expected numeric value,
but all the expressions (which may have persistent effects, 
like variable declarations and assignments) will be evaluated.
Example:
\begin{verbatim}
    1.
    (real r = 2.*pi; integer i = 1; sin(i*r*Time+.87))      
\end{verbatim}
the latter results in $ sin\plbr{2\pi{t}+.87} $; 
note that the constant \kw{pi} is always defined
as the machine $ \pi $, as well as the constants \kw{e},
\kw{MAX\_RAND} and more; use
\begin{verbatim}
    mbdyn -H
\end{verbatim}
for an up-to-date list of predefined variables; a typical output
is shown in Figure~\ref{fig:MBDYN-H}.
Of course values are stored with the maximum precision allowed
by the underlying real type (by default, double precision, 64 bit).

\begin{figure}
\label{fig:MBDYN-H}
\centering
\small
\begin{minipage}{120mm}
\begin{verbatim}
user@host:~> mbdyn -H

MBDyn - MultiBody Dynamics 1.2-Engineering
compiled on May 20 2004 at 10:42:24

Copyright 1997-2004 (C) Paolo Mantegazza and Pierangelo Masarati,
Dipartimento di Ingegneria Aerospaziale, Politecnico di Milano.

MBDyn is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Use 'mbdyn --license' to see the conditions.
There is absolutely no warranty for MBDyn.  Use "mbdyn --warranty" for details.

default symbol table:
  real mm2in = 0.0393701
  real lb2kg = 0.4535
  real m2in = 39.3701
  real m2ft = 3.28084
  real in2m = 0.0254
  real in2mm = 25.4
  real pi = 3.14159
  real deg2rad = 0.0174533
  real kg2lb = 2.20507
  real e = 2.71828
  real rad2deg = 57.2958
  int RAND_MAX = 2147483647
  real ft2m = 0.3048

MBDyn terminated normally
user@host:~>
\end{verbatim}
\end{minipage}
\caption{Predefined variables in mathematical parser}
\end{figure}

\noindent
The variable \kw{Time} is declared, defined and initialized\footnote{
    A variable is \kw{declared} when its name enters the namespace;
    it is \kw{defined} when it can be referenced;
    it is \kw{initialized} when it is first assigned a value
} from the beginning of the control data section, and during the solution 
phase it is assigned the value of the current time. 

\noindent
Table~\ref{tab:MATHP-OPERATORS} shows the supported mathematical 
operators, while Table~\ref{tab:MATHP-FUNCTIONS} shows the built-in
mathematical functions.
The supported types are listed in Table~\ref{tab:MATHP-TYPES}.
Table~\ref{tab:MATHP-VARS} lists the predefined variables; notice
that they're treated exactly as user-defined variables, so they 
can be reassigned.

\begin{table}
	\begin{center}
	\caption{Mathematical Operators 
	(from higher to lower precedence)}\label{tab:MATHP-OPERATORS}
	\begin{tabular}{lll}
		\hline
		\emph{Operator} & \emph{Type} & \emph{Description} \\
		\hline
		\kw{\^} & Binary, right & Power \\
		\kw{+} & Unary, left & Plus sign \\
		\kw{-} & Unary, left & Minus sign \\
		\kw{*} & Binary, left & Multiplication \\
		\kw{/} & Binary, left & Division \\
		\kw{+} & Binary, left & Addition \\
		\kw{-} & Binary, left & Subtraction \\
		\kw{>} & Binary, left & Greater than \\
		\kw{>=} & Binary, left & Greater than or equal to \\
		\kw{==} & Binary, left & Equal to \\
		\kw{<=} & Binary, left & Less than or equal to \\
		\kw{<} & Binary, left & Less than \\
		\kw{!=} & Binary, left & Not equal \\
		\kw{!} & Unary, right & NOT \\
		\kw{\&\&} & Binary, left & AND \\
		\kw{||} & Binary, left & OR \\
		\kw{{~}|} & Binary, left & XOR (exclusive OR) \\
		\kw{=} & Binary, right & Assignment \\
		\hline
	\end{tabular}
	\end{center}
	\small
	Note: left and right refer to the associativity of the operators
\end{table}

\begin{table}
	\begin{center}
	\caption{Mathematical Functions}\label{tab:MATHP-FUNCTIONS}
	\begin{tabular}{lll}
		\hline
		\emph{Function Name} & \emph{Arg[s]} & \emph{Description} \\
		\hline
		\kw{asin} & Real & Arc sine \\
		\kw{acos} & Real & Arc cosine \\
		\kw{atan} & Real & Arc tangent \\
		\kw{actan} & Real & Arc co-tangent \\
		\kw{atan2} & Real, Real & Arc tangent 2 (robust) \\
		\kw{actan2} & Real, Real & Arc co-tangent 2 (robust) \\
		\kw{cos} & Real & Cosine \\
		\kw{sin} & Real & Sine \\
		\kw{tan} & Real & Tangent \\
		\kw{ctan} & Real & Co-tangent \\
		\kw{cosh} & Real & Hyperbolic cosine \\
		\kw{sinh} & Real & Hyperbolic sine \\
		\kw{tanh} & Real & Hyperbolic tangent \\
		\kw{ctanh} & Real & Hyperbolic co-tangent \\
		\kw{acosh} & Real & Hyperbolic arc cosine \\
		\kw{asinh} & Real & Hyperbolic arc sine \\
		\kw{atanh} & Real & Hyperbolic arc tangent \\
		\kw{actanh} & Real & Hyperbolic arc co-tangent \\
		\kw{exp} & Real & Exponential \\
		\kw{log} & Real & Natural logarithm \\
		\kw{log10} & Real & Base 10 logarithm \\
		\kw{sqrt} & Real & Square root \\
		\kw{abs} & Real & Absolute value \\
		\kw{sign} & Real & Sign \\
		\kw{copysign} & Real, Real & First arg with sign of second \\
		\kw{floor} & Real & Closest integer from below \\
		\kw{ceil} & Real & Closest integer from above \\
		\kw{round} & Real & Closest integer \\
		\kw{rand} & & random integer 
			$\sqbr{0,\mathrm{RAND\_MAX}}$ \\
		\kw{random} & & random real $\sqbr{-1.0,1.0}$ \\
		\kw{seed} & Integer & Seeds the random number generator \\
		\kw{step} & Real & Step function \\
		\kw{ramp} & Real & Ramp function \\
		\kw{sramp} & Real, Real & Saturated ramp function \\
		\kw{par} & Real & Parabolic function \\
		\kw{print} & Real & Prints a value to standard output \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Mathematical Types}\label{tab:MATHP-TYPES}
	\begin{tabular}{ll}
		\hline
		\emph{Type Name} & \emph{Description} \\
		\hline
		\kw{Real} & Real number \\
		\kw{Integer} & Integer number (promoted to \kw{Real} 
			whenever required) \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

\begin{table}
	\begin{center}
	\caption{Predefined Variables}\label{tab:MATHP-VARS}
	\begin{tabular}{lll}
		\hline
		\emph{Variable Name} & \emph{Type} & \emph{Value} \\
		\hline
		\kw{Time} & Real & Current simulation time \\
		\kw{Val} & Real & Set by dof driver with DOF value \\
		\\
		\kw{e} & Real & Neper's number \\
		\kw{pi} & Real & $\pi$ \\
		\kw{RAND\_MAX} & Integer & Maximum random integer \\
		\\
		\kw{in2m} & Real & Inch to meter ratio (0.0254) \\
		\kw{m2in} & Real & Meter to inch ratio (1.0/0.0254) \\
		\kw{in2mm} & Real & Inch to meter ratio (25.4) \\
		\kw{mm2in} & Real & Meter to inch ratio (1.0/25.4) \\
		\kw{ft2m} & Real & Foot to meter ratio (0.3048) \\
		\kw{m2ft} & Real & Meter to foot ratio (1.0/0.3048) \\
		\kw{lb2kg} & Real & Pound to kilogram ratio (0.4535) \\
		\kw{kg2lb} & Real & Kilogram to pound ratio (1.0/0.4535) \\
		\kw{deg2rad} & Real & Degree to radian ratio ($\pi$/180) \\
		\kw{rad2deg} & Real & Radian to degree ratio (180/$\pi$) \\
		\hline
	\end{tabular}
	\end{center}
\end{table}



\section{Higher Level Structures}
Every time a higher level structure is expected, it can be
preceeded by a keyword that influences how the structure is read.
All of the available structures support the keyword \kw{null}
which causes the structure to be initialized with zeros.
When a non-null value is input, it can be followed by the keyword
\kw{scale} and by a scale factor; the scale factor can be any
mathematical expression.
This is useful to rescale structure values by reassigning the value 
of the scale factor.
The main data structures are:
\subsection{\kw{3 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 3 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized
	with zeros.
\end{enumerate}
As an example, all the following lines define an empty \kw{3 x 1} vector:
\begin{verbatim}
    default
    null
    0.,0.,0.
    ,,
\end{verbatim}
the first case is correct if no default was actually available
for that specific vector, thus falling back to three zeros.
The following rescales an arbitrary vector
\begin{verbatim}
    cos(pi/3.),0.,sin(pi/3.), scale, 100.
\end{verbatim}

\subsection{\kw{6 x 1} vectors}
\begin{enumerate}
    \item general case: a sequence of 6 reals, comma-separated.
    \item null vector: keyword \kw{null}; the vector is initialized 
    with zeros.	
\end{enumerate}
\subsection{\kw{3 x 3} matrices}
\begin{enumerate}
    \item general case: a sequence of 9 reals, comma-separated, which
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{32} $, $ a_{33} $.
    \emph{Note: the 9 coefficients can pre preceded by the keyword
    \kw{matr} for consistency with other entities; its use is recommended
    whenever an ambiguity is possible.}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 6 reals, comma-separated, that represents the upper triangle, 
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{13} $, $ a_{22} $, $ a_{23} $, $ a_{33} $.
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 3 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix.
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
For example, the identity matrix can be defined as:
\begin{verbatim}
    matr, 1.,0.,0., 0.,1.,0., 0.,0.,1.
    1.,0.,0., 0.,1.,0., 0.,0.,1.
    sym, 1.,0.,0., 1.,0., 1.
    diag, 1.,1.,1.
    eye
\end{verbatim}
\subsection{\kw{3 x 3} orientation matrices}
\begin{enumerate}
    \item general case: two vectors that define an orthonormal reference
    system, each of them preceded by its index in the final orientation 
    matrix. The first vector is normalized and assumed to represent the
    desired direction, while the second simply defines the plane the
    vector that is not given is normal to, e.g.:
    \begin{verbatim}
    1, 1.,0.,0., 2, 0.,1.,0.
    1, (real alpha=pi/6.; 
       cos(alpha)), sin(alpha), 0., 3, 0.,0.,1.
    \end{verbatim}
    the first example represents the identity matrix i.e.\ no rotation 
    occurs with respect to the global reference frame: direction 1
    in the local frame is parallel to \kw{1.,0.,0.} which represents
    direction 1 in the global frame, while direction 2 in the local frame
    is parallel to \kw{0.,1.,0.} which represents direction 2
    in the global frame.

    \noindent
    The second example describes a rotation of $ \pi/6 $ rad.\ about
    global direction 3: direction 1 in the local frame results from 
    composing \kw{cos(pi/6.)} in global direction 1 and \kw{sin(pi/6.)}
    in global direction 2, while direction 3 in the local frame remains
    parallel to \kw{0.,0.,1.} which represents direction 3 in the global
    frame.
    \item identity matrix: keyword \kw{eye}; the identity matrix,
    which means there is no rotation with respect to the global reference
    frame.
    \item a complete orientation matrix: keyword \kw{matr}
    followed by the nine, row-oriented, coefficients, namely
    $ r_{11} $, $ r_{12} $, \ldots, $ r_{33} $.
    \emph{Note: no orthogonality check is performed; be sure an orthogonal
    matrix, within the desired tolerance, is input}.
    \item Euler angles: keyword \kw{euler}, followed by the three
    values, as output by structural nodes.
    \emph{Note: the definition of the three angles that are used 
    by the code to express orientations may vary between versions.
    Currently, Bryant-Cardano angles are used in place of Euler
    angles.  The code will remain consistent, i.e. the same angle
    definition will be used for input and output, but models
    over versions may become incompatible, so this syntax should 
    really be used only as a means to quickly reproduce in the input
    an orientation as resulting from a previous analysis.}
\end{enumerate}
\subsection{\kw{6 x 6} matrices}
\begin{enumerate}
    \item general case: a sequence of 36 reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{65} $, $ a_{66} $.
    \item ANBA format: keyword \kw{anba}, followed by 36 reals, 
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the code ANBA, namely the following
    transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \item symmetric matrix: keyword \kw{sym}, followed by a sequence
    of 21 reals, comma-separated, that represents the upper triangle,
    row-oriented coefficients of a symmetric matrix, 
    e.g. $ a_{11} $, \ldots , $ a_{16} $, $ a_{22} $,
    \ldots , $ a_{26} $, \ldots, $ a_{66} $.
    \item diagonal matrix: keyword \kw{diag}, followed by a sequence
    of 6 reals, comma-separated, that represent the diagonal coefficients 
    of a diagonal matrix.
    \item identity matrix: keyword \kw{eye}; the matrix is initialized
    as the identity matrix, that is a null matrix except for the diagonal 
    coefficients that are 1.
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}
\subsection{\kw{6 x N} matrices}
\begin{enumerate}
    \item general case: a sequence of \kw{6 x N} reals, comma-separated, that
    represent the row-oriented coefficients $ a_{11} $, $ a_{12}$ ,
    \ldots, $ a_{6\plbr{N-1}} $, $ a_{6N} $.
    \item ANBA format: keyword \kw{anba}, followed by \kw{6 x N} reals,
    comma-separated, that represent the coefficients of the beam stiffness
    matrix as generated by the code ANBA, namely the following
    transformation is performed:
    \begin{itemize}
        \item axis $ x $, in the section plane in ANBA notation, 
	becomes axis 2 in MBDyn notation;    
	\item axis $ y $, in the section plane in ANBA notation, 
	becomes axis 3 in MBDyn notation;    
	\item axis $ z $, the beam axis in ANBA notation, 
	becomes axis 1 in MBDyn notation;    
    \end{itemize}
    \item null matrix: keyword \kw{null}; the matrix is initialized 
    with zeros.
\end{enumerate}


\section{Input Related Cards} 
Everywhere in the input file the statement cards defined in the following 
can be used.
They are handled directly by the parsing object, and merely act as
an indirect reference to entities that are not explicitly enumerated.
They are:



\subsection{Set}
The \kw{set} directive:
\begin{verbatim}
    <card> ::= set : <math_expression> ;
\end{verbatim}
This directive simply invokes the math parser to evaluate the expression
\kw{math\_expression} and then discards the result. It can be useful
to declare new variables, or to set the values of existing ones.



\subsection{Setenv}
The \kw{setenv} directive:
\begin{verbatim}
    <card> ::= setenv : [ overwrite , ] " <varname> [ = <value> ] " ;
\end{verbatim}
This directive sets the environment variable \kw{<varname>} 
to the value \kw{<value>}, if given; otherwise, the variable
is unset.
If the keyword \kw{overwrite} is set, the variable is overwritten, 
if already set.
See \kw{setenv(3)} and \kw{unsetenv(3)} man pages for details.



\subsection{Remark}
The \kw{remark} directive:
\begin{verbatim}
    <card> ::= remark : " <remark_string >
        [ , <math_expression> [ , ... ] ] ;
\end{verbatim}
This directive simply prints to stdout the string \kw{remark\_string} and
optionally evaluates any subsequent expression \kw{math\_expression}
according to the \kw{set} directive.
It is used to allow rough input debugging, where the file name and line 
is logged, followed by a message, possibly followed by the evaluation 
of expressions. 
Example:
\begin{verbatim}
    remark: "square root of 2", sqrt(2);
    set: (
        real EA = 1e6; # N, axial stiffness
        real GA = 1e6; # N, shear stiffness
        real EJ = 1e3; # Nm^2, bending stiffness
        real GJ = 1e3; # Nm^2, torsional stiffness
    0);
    remark: "Stiffness properties", EA, GA, EJ, GJ;
\end{verbatim}



\subsection{Include}
The \kw{include} directive:
\begin{verbatim}
    <card> ::= include : " <file_name> " ;
\end{verbatim}
where \kw{file\_name} is a valid filename for the operative system in
use, that must be enclosed in double quotes (").
The full (absolute or relative) path must be given if the included file 
is not in the directory of the including one.
There is no check for recursive \kw{include}s, so 
{\bf the user must take care of recursion}.
The \kw{include} directive forces the parser to scan the included file
\kw{file\_name} before continuing with the including one.
This is very useful if, for instance, a big model can be made of many
small models that are meaningful by themselves.
It can be used to replicate parts of the model, by simply using parametric 
labels for nodes, elements, reference systems, and setting a bias value 
before multiple-including the same bulk data file.
Examples of this usage are given in the tutorials
\htmladdnormallink{(\texttt{http://www.aero.polimi.it/\~{}mbdyn/documentation/tutorials/})}
	{http://www.aero.polimi.it/~mbdyn/documentation/tutorials/}.



\subsection{Drive Caller}\label{sec:DRIVE-CALLER}
\begin{verbatim}
    <card> ::= drive caller : <label>
        [ , name , " <name> " ]
        (DriveCaller)<drive_caller> ;
\end{verbatim}
The keyword \kw{drive caller} allows to define
a \hyperref{\kw{drive caller}}{\kw{drive caller} (see Section~}{)}{sec:DRIVE}
that can be subsequently reused.
It is useful essentially in two cases:
\begin{enumerate}
	\renewcommand{\labelenumi}{\alph{enumi})}
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE}
	that will be used many times throughout a model;
	\item to define a \htmlref{\kw{drive}}{sec:DRIVE} 
	that needs to be used in a later defined part of a model, 
	to make it parametric.
\end{enumerate}



\subsection{Constitutive Law}\label{sec:CONSTITUTIVE-LAW}
\begin{verbatim}
    <card> ::= constitutive law : <label>
        [ , name , " <name> " ]
        <dim> , (ConstitutiveLaw<dim>D) <constitutive_law> ;
\end{verbatim}
Constitutive laws are grouped by their dimensionality \kw{<dim>},
which can be any of 1, 3 and 6; the \kw{<constitutive\_law>}
is parsed according to the rules described
in Section~\ref{sec:CONSTITUTIVE-LAWS}.



\subsection{Reference}
The \kw{reference} directive:
\begin{verbatim}
    <card> ::= reference : <unique_label> , 
        <absolute_position> ,
        <absolute_orientation_matrix> ,
        <absolute_velocity> ,
        <absolute_angular_velocity> ;
\end{verbatim}
A \kw{reference} system is declared and defined.
It must be given a unique identifier, scanned by the math parser
(which means that any regular expression is allowed, and the result is
rounded up to the nearest unsigned integer).
The entries \kw{absolute\_*} are parsed by routines that
compute absolute (i.e.\ referring to the global frame) entities
starting from a given entity in a given reference frame.
These routines are very general, and make intense use of the 
\kw{reference} entries themselves, which means that a reference 
can be recursively defined by means of previously defined 
\kw{reference} entries.

\subsubsection{Use of Reference Frames}
Every time an absolute or a relative geometric or physical entity is
required, it is processed by a set of routines that allow the entity to be
expressed in the desired reference frame.
The following cases are considered:
\begin{itemize}
    \item relative position (physical)
    \item absolute position (physical)
    \item relative orientation matrix (physical)
    \item absolute orientation matrix (physical)
    \item relative velocity (physical)
    \item absolute velocity (physical)
    \item relative angular velocity (physical)
    \item absolute angular velocity (physical)
    \item relative arbitrary vector (geometric)
    \item absolute arbitrary vector (geometric)    
\end{itemize}
The caller is responsible for the final interpretation of the input. 
The caller always supplies the routines a default reference structure
the input must be referred to.
So, depending on the caller, the entry can be in the following forms:
\begin{enumerate}
    \item \kw{entity}: \\ 
    the entry is in the default reference frame
    \item \kw{reference , <reference\_type> , <entity>}: \\
    the entry is in \kw{reference\_type} reference frame, 
    that is one of \kw{global}, 
    \kw{node} or \kw{local}.
    \item \kw{reference , <reference\_number> , <entity>}: \\
    the entry is in \kw{reference reference\_number} reference frame. 
    This reference frame must be already defined. 
    % By default, the global reference frame has number 1, so it can't be redefined.    
\end{enumerate}
Examples:
\begin{itemize}
    \item absolute position:
    \begin{verbatim}
    null
    reference, global, null
    reference, 8, 1., sin(.3*pi), log(3.)
    \end{verbatim}
    \item relative orientation matrix (e.g.\ as required by many constraints and
    thus referred to a node):
    \begin{verbatim}
    eye
    reference, node, eye
    reference, 8,
        3, 0., 1., 0., 
        1, .5, sqrt(3)/2., 0.
    \end{verbatim}
\end{itemize}
Notes: 
\begin{itemize}
    \item the global reference frame has position $ \cubr{0, 0, 0} $,
    orientation matrix \kw{eye}, velocity $ \cubr{0, 0, 0} $ and angular
    velocity $ \cubr{0, 0, 0} $.
    \item if the caller is not related to a node, the reference type
    \kw{node} shouldn't be defined. 
    In this case it is considered equivalent to \kw{local}.
    \item when processing a velocity or an angular velocity, the resulting
    value always accounts for the velocity and angular velocity of the frame
    the entry is referred to. 
    As an example, if a node is defined on a reference frame that has
    non-null angular velocity $ \Omega_R $, and its position 
    $ x_{input} $ is not in the origin $ X_R $ of the reference frame
    it is attached to, its global velocity and angular velocity result
    as the composition of the input values and of those of the reference 
    frame:
    \begin{eqnarray*}    
        w & = & R_R\omega_{input}+\Omega_R \\
	v & = & R_Rv_{input}+V_R+\Omega_R\times\plbr{R_Rx_{input}}
    \end{eqnarray*}
    This, for instance, eases the input of all the parts of a complex system
    that is moving as a rigid body, by defining a reference frame with the
    proper initial velocities, and then referring all the entities, e.g.\ the 
    nodes, to that frame, with null local velocity.
\end{itemize}  
{\em
    Recalling the declaration and the definition of reference frames,
    a simple reference frame definition, with all the entries referring 
    by default to the global system, would be:
    \begin{verbatim}
    reference: 1000,
        null,
        eye,
        null,
        null;			 
    \end{verbatim}
    which represents a redefinition of the global system.
    A more verbose, and self-explanatory definition would be:
    \begin{verbatim}
    reference: 1000,
        reference, global, null,
        reference, global, eye,
        reference, global, null,
        reference, global, null;			 
    \end{verbatim}
    the reference frame one is referring to must be repeated for all the entries
    since they must be allowed to refer to whatever frame is preferred 
    by the user.
    A fancier definition would be:
    \begin{verbatim}
    reference: Rotating_structure, 
        reference, Fixed_structure, null,
        reference, Spindle_1,
            1, 0.,0.,1., 
            3, 0.,1.,0.,
        reference, Fixed_structure, null,
        reference, Spindle_1, 0.,0.,Omega_1;
    \end{verbatim}
}



\subsection{C81 Data}\label{sec:C81-DATA}
This keyword allows to define and read the \kw{c81 data} 
airfoil tables that are used by aerodynamic elements.
\begin{verbatim}
    <card> ::= c81 data : <label> [ , name , " <name> " ]
        " <filename> " ;
\end{verbatim}



\subsection{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID}
The \kw{hydraulic fluid} directive:
\begin{verbatim}
    <card> ::= hydraulic fluid : <unique_label> , 
        <fluid_type> , <fluid_properties> ;
\end{verbatim}
allows to define a hydraulic fluid to be later used in hydraulic elements,
see Section~\ref{sec:EL-HYDR}.
The fluid is identified by a numerical label. 
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are
described in \ref{sec:HYDRAULIC-FLUID-DATA}



\section{Node Degrees of Freedom}\label{sec:NODEDOF}
A node in MBDyn is nothing but an entity that owns degrees of freedom and
can lend them to other entities. 
Usually elements access nodal degrees of freedom through well-defined
interfaces, at a high level. 
But in a few cases, nodal degrees of freedom must be accessed
at a very low level, with the bare knowledge of the node label,
the internal number of the degree of freedom, and the order 
(algebraic or differential, if any).
The data that allows an entity to track a nodal degree of freedom
is read as follows:
\begin{verbatim}
    <node_dof> :: = <node_label> , 
        <node_type> 
        [ , <dof_number> ]
        [ , { algebraic | differential } ]
\end{verbatim}
The label and the type of the node are used to track the pointer to the
desired node. 
If the node is not scalar, the \kw{dof\_number} field is required
to address the appropriate degree of freedom.
Finally, the order of the degree of freedom is checked, if required.
It must be one of \kw{algebraic} or \kw{differential}.
If the \kw{dof\_number} degree of freedom is differential, both
of them can be addressed, while in case of an algebraic node there is no
choice, only the \kw{algebraic} order can be addressed and thus this field
is not required.
The \kw{dof\_number} must range between 1 and the number of \emph{dof}s that
belong to the node.
When the node is used to address an equation (abstract forces, 
discrete control elements), the distinction between \kw{algebraic} 
and \kw{differential} is meaningless, and thus this filed is not required.




\section{Drives and Drive Callers}\label{sec:DRIVE}
Every time some entity can be ``driven'', i.e.\ a value can be
expressed as dependent on some ``external'' input, an object of the class 
\kw{DriveCaller} is used. 
The \kw{drive} essentially represents a scalar function, whose
value can change over time or, through some more sophisticated
means, based on the state of the analysis.
Usually, the dependence over time is implicitly assumed, unless
otherwise specified.
For example, the amplitude of the force applied by a 
\hyperref{\kw{force} element}{\kw{force} element (see Section~}{)}{sec:EL-FORCE}
is defined by means of a \kw{drive}; as such, the value of the \kw{drive} 
is implicitly calculated as a function of the time.
However, a 
\hyperref{\kw{dof drive}}{\kw{dof drive} (see Section~}{)}{sec:DRIVE-DOF}
uses a subordinate \kw{drive} to compute its value based on the value
of a degree of freedom of the analysis; as a consequence,
the value of the \kw{dof drive} is represented by the
value of the subordinate \kw{drive} when evaluated as a function
of that specific degree of freedom at the desired time.

\noindent
The family of the \kw{DriveCaller} object is very large, 
and should require a dedicated chapter.
The type of the \kw{DriveCaller} is declared as follows:
\begin{verbatim}
    <drive_caller> ::=
        { <drive_caller_type> [ , <arglist> ]
            | reference , <label> }
\end{verbatim}    
where \kw{arglist}, if any, is a comma-separated list of arguments
that depends on \kw{drive\_caller\_type}.
As an exception, a constant \kw{DriveCaller} (that behaves exactly as a
numerical constant with little or no overhead depending on the optimizing
capability of the compiler) is assumed when a numeric value is used instead
of a keyword.
If the alternative format is used, the keyword \kw{reference} 
must be followed by the label of an already defined, valid drive caller
(See Section~\ref{sec:DRIVE-CALLER}).

\subsection{Null drive}
\begin{verbatim}
    <drive_caller> ::= null
\end{verbatim}
Zero valued; the \kw{arglist} is empty.

\subsection{Unit drive}
\begin{verbatim}
    <drive_caller> ::= unit
\end{verbatim}
Always 1; the \kw{arglist} is empty.

\subsection{Constant drive}
\begin{verbatim}
    <drive_caller> ::= [ const , ] <const_coef>                    
\end{verbatim}
The keyword \kw{const} can be omitted thus highlighting the real nature
of this driver, that is completely equivalent to a constant, static real
value.

\subsection{Time drive}
\begin{verbatim}
    <drive_caller> ::= time
\end{verbatim}
Yields the current time; the arglist is empty.
  
\subsection{Linear drive}
\begin{verbatim}
    <drive_caller> ::= linear ,
        <const_coef> ,
        <slope_coef>
\end{verbatim}

\subsection{Parabolic drive}
\begin{verbatim}
    <drive_caller> ::= parabolic ,
        <const_coef> , 
        <linear_coef> , 
        <parabolic_coef>
\end{verbatim}

\subsection{Cubic drive}
\begin{verbatim}
    <drive_caller> ::= cubic ,
        <const_coef> , 
        <linear_coef> ,
        <parabolic_coef>, 
        <cubic_coef>
\end{verbatim}

\subsection{Step drive}
\begin{verbatim}
    <drive_caller> ::= step ,
        <initial_time> , 
        <step_value> ,
        <initial_value>
\end{verbatim}    

\subsection{Double step drive}
\begin{verbatim}
    <drive_caller> ::= double step ,
        <initial_time> , 
        <final_time> ,
        <step_value> , 
        <initial_value>
\end{verbatim}

\subsection{Ramp drive}
\begin{verbatim}
    <drive_caller> ::= ramp ,
        <slope> , 
        <initial_time> ,
        <final_time> , 
        <initial_value>
\end{verbatim}
  
\subsection{Double ramp drive}
\begin{verbatim}
    <drive_caller> ::= double ramp ,
        <asc_slope> , 
        <asc_initial_time> , 
        <asc_final_time> , 
        <desc_slope> , 
        <desc_initial_time> , 
        <desc_final_time> , 
        <initial_value>
\end{verbatim}

\subsection{Piecewise linear drive}
\begin{verbatim}
    <drive_caller> ::= piecewise linear ,
        <num_points> ,
            <point> , <value> 
            [ , ... ]
\end{verbatim}
Piecewise linear function; the first and the last point/value pairs are
extrapolated in case a value beyond the extremes is required.
Linear interpolation between pairs is used.

\subsection{Sine drive}
\begin{verbatim}
    <drive_caller> ::= sine ,
        <initial_time> ,
        <pulsation> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
the value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles}$-1/2$ oscillations are
performed. 
If it is negative, the oscillations end after 
\kw{number\_of\_cycles}$-3/4$ cycles at the top of the sine, with null
tangent.
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
	\item \kw{half}, which means exactly half cycle is performed,
	so the function stops at \kw{amplitude} + \kw{initial\_value}.
\end{itemize}

\subsection{Cosine drive}
\begin{verbatim}
    <drive_caller> ::= cosine ,
        <initial_time> ,
        <pulsation> ,
        <amplitude> ,
        { [ - ] <number_of_cycles> | half | one | forever } , 
        <initial_value>
\end{verbatim}
this drive actually computes a function of the type $ 1-\llk{cos}\plbr{x} $.
The value of \kw{number\_of\_cycles} determines the behavior of the
drive. 
If it is positive, \kw{number\_of\_cycles} oscillations are
performed.
If it is negative, the oscillations end after
\kw{number\_of\_cycles}$-1/2$ cycles at the top of the cosine, with null
tangent.   
Special keywords can be used for \kw{number\_of\_cycles}:
\begin{itemize}
	\item \kw{forever}, which means the oscillation never stops;
	\item \kw{one}, which means exactly one cycle is performed;
	\item \kw{half}, which means exactly half cycle is performed,
	so the function stops at \kw{amplitude} + \kw{initial\_value}.
\end{itemize}

\subsection{Frequency sweep drive}
\begin{verbatim}
    <drive_caller> ::= frequency sweep ,
        <initial_time> ,
        <pulsation_drive> ,
        <amplitude_drive> ,
        <initial_value> ,
        <final_time> ,
        <final_value>
\end{verbatim}
this drive recursively calls two other drives that supply the pulsation 
and the amplitude of the oscillation. Any drive can be used.

\subsection{Exponential drive}
\begin{verbatim}
    <drive_caller> ::= exponential ,
        <amplitude_value> ,
        <time_constant_value> ,
        <initial_time> ,
        <initial_value>
\end{verbatim}

\subsection{Random drive}
\begin{verbatim}
    <drive_caller> ::= random ,
        <amplitude_value> ,
        <mean_value> ,
        <initial_time> ,
        <final_time> 
        [ , steps , <steps_to_hold_value>]
        [ , seed , { time | <seed_value>} ]
\end{verbatim}
the first optional entry, preceeded by the keyword \kw{steps}, sets the
number of steps a random value must be held before generating a new
random number. The second optional entry, preceeded by the keyword
\kw{seed}, sets the new seed for the random number generator. A numeric
value can be used, or the keyword \kw{time} uses the current time from
the internal clock. A given seed can be used to ensure that two
simulations use exactly the same random sequence (concurrent settings 
are not managed, so it is not very reliable).

\subsection{File drive}\label{sec:FILE-DRIVE}
A family of file drivers is being planned.
At present only a multiple-valued, constant time-step file drive is
implemented.
The \kw{DriveCaller} is attached to a file drive object that must be declared
and defined in the \htmlref{\kw{drivers}}{sec:DRIVERS} section 
of the input file (see Section~\ref{sec:DRIVERS}).
\begin{verbatim}
    <drive_caller> ::= file ,
        <drive_label>
        [ , <column_number> ]
        [ , amplitude , <amplitude> ]
\end{verbatim}
\kw{drive\_label} is the label of the \htmlref{\kw{drive}}{sec:DRIVE} 
the \kw{DriveCaller} is attached to, while
\kw{column\_number} is the number of the column the \kw{DriveCaller}
refers to (defaults to 1).
An additional scaling factor \kw{amplitude} can be used to rescale
the drive value (defaults to 1.0).

\subsection{String drive}
\begin{verbatim}
    <drive_caller> ::= string ,
        " <expression_string> "
\end{verbatim}
\kw{expression\_string} is a string, delimited by double quotes.
It is parsed by the math parser every time 
the \htmlref{\kw{drive}}{sec:DRIVE} is invoked.
The variable \kw{Time} is kept up to date and can be used in the 
string to compute the return value.
Another variable, \kw{Var}, is set to the value provided by the caller
in case the drive is called with an explicit argument as, for instance,
in the \hyperref{dof drive}{dof drive (see Section~}{)}{sec:DRIVE-DOF};
e.g.:
\begin{verbatim}
    string, "e^(-Time)*cos(2.*pi*Time)"
\end{verbatim}
generates a cosine modulated by an exponential.


\subsection{Dof drive}\label{sec:DRIVE-DOF}
\begin{verbatim}
    <drive_caller> ::= dof ,
        (node_dof) <driving_dof> ,
        (drive_caller) <func_drive>
\end{verbatim}
a \hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}, 
namely the reference to a degree of freedom of a node, is read. 
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
\htmlref{\kw{node\_dof}}{sec:NODEDOF} as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the displacement
of the node it is applied to) or an active control system; e.g.:
\begin{verbatim}
    dof, 1000, structural, 3, algebraic, 
        linear, 0., 1.
\end{verbatim}
uses the value of the third component (z) of structural node 1000 
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    dof, 1000, abstract, differential, 
        string, "2.*exp(-100.*Var)"
\end{verbatim}
uses the value of the derivative of abstract node 1000 in computing 
a string expression.
Refer to the description of a 
\hyperref{\kw{node\_dof}}{\kw{node\_dof} (see Section~}{)}{sec:NODEDOF}
entry for further details.

\subsection{Element drive}\label{sec:DRIVE-ELEMENT}
\begin{verbatim}
    <drive_caller> ::= element ,
        <label> ,
        <type>
        [ , { name , "<name>" | index , <index> } ]
        (drive_caller) <func_drive>
\end{verbatim}
a reference to the private data of an element is read.
This is made of: the element's \kw{label}, the element's \kw{type}
and a specification of which private data is being referred;
the \kw{index} can be directly given, prepended by the keyword
\kw{index}, or the symbolic name can be used, prepended by 
the keyword \kw{index}.
If that element allows only one private data, the specification 
can be omitted.
Then a recursive call to a drive data is read. 
The driver returns the value of the \kw{func\_drive} 
\htmlref{\kw{drive}}{sec:DRIVE} using the value of the 
element's private data as input instead of the time. 
This can be used as a sort of explicit feedback, to implement fancy
springs (where a force is driven through a function by the rotation
of a joint) or an active control system; e.g.:
\begin{verbatim}
    element, 1000, joint, name, "rz",
        linear, 0., 1.
\end{verbatim}
uses the value of the rotation about axis $z$ of a revolute hinge
as is (that is, in a linear expression with null constant coefficient 
and unit linear coefficient, while
\begin{verbatim}
    element, 1000, joint, index, 1
        string, "2.*exp(-100.*Var)"
\end{verbatim}
uses the same value, addressed in an alternative manner, in computing
a string expression.
The same effect can be obtained by using the element plugin as follows:
\begin{verbatim}
    set: [elem,x,1000,joint,name=rz];
    # ...
    couple: 1, conservative, 1, 0.,0.,1.,
        string, "2.*exp(-100.*x)";
\end{verbatim}
which applies a couple whose amplitude is computed by evaluating
a \kw{string} drive which depends on variable $x$; this, on turn,
is defined as an \kw{element} plugin, which causes its evaluation
in terms of the element's private data at each invocation.

\subsection{Array drive}
\begin{verbatim}
    <drive_caller> ::= array ,
        <num_drives> ,
            <drive_caller> 
            [ , <drive_caller> [ , ... ] ]
\end{verbatim}
this is simply a front-end for the linear combination of \kw{num\_drives} 
normal drives; \kw{num\_drives} must be at least 1, in which case 
a simple drive caller is created, otherwise an array of drive callers 
is created and at every call their value is added to give 
the final value of the array drive.


\subsection{Template drive}\label{sec:TPL-DRIVE}
A particular \kw{DriveCaller} is the template drive caller. This is made
of a constant entity that multiplies a conventional 
\hyperref{\kw{drive}}{\kw{drive} (see Section~}{)}{sec:DRIVE} to give a drive
entity of dimensionality different from that of a simple scalar \kw{drive}.
there are two types of template drive callers, the \kw{single} template 
drive caller and the \kw{array} template drive caller, 
that is nothing but the sum of an array of \kw{single}
template drive callers. 
They are entered as follows:
\begin{verbatim}
    <tpl_drive_caller> ::= single ,
        <entity> , <drive_caller> 

    <tpl_drive_caller> ::= array ,
        <num_template_drive_callers> ,
        <entity> , <drive_caller>
        [ , <entity> , <drive_caller> [ , ... ] ]
\end{verbatim}
where \kw{entity} is a constant of the expected type (scalar, \kw{3 x 1} 
vector, \kw{6 x 1} vector are the types currently defined, but, since 
a C++ template has been used, the implementation of other ones 
is straightforward).
In case of scalar values, the template reverts by default to a normal 
drive caller, such that no overhead is added.
At least 1 drive caller is expected. 
If \kw{num\_template\_drive\_callers} is exactly 1, only a single
template drive caller is actually constructed, thus avoiding the overhead 
related to the handling of the drive caller array.    





\section{Friction}
Any friction-enabled joint need the definition of
at least a \kw{friction model} and of a \kw{shape function}.
\subsection{Friction models}
The \kw{friction model} input format is:
\begin{verbatim}
    <friction_model> ::= <friction_type> ,
        <friction_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{modlugre}\\
    This friction model is based on 
    Pierre Dupont, Vincent Hayward, Brian Armstrong and
    Friedhelm Altpeter, Single State Elasto-Plastic Friction Models,
    IEEE Transactions on Automatic Control, June 2002. The input format is:
    \begin{verbatim}
    <friction_model> ::= modlugre
    <friction_arglist> ::=
        <sigma0>,
        <sigma1>,
        <sigma2>,
        <kappa>,
        <friction_function>
    <sigma0> ::= <const_value>
    <sigma1> ::= <const_value>
    <sigma2> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    \item \kw{discrete coulomb}\\
    This is a Coulomb model with viscous friction and
    internal states to resolve stick/slip conditions.
    \begin{verbatim}
    <friction_model> ::= discrete coulomb
    <friction_arglist> ::=
        [ sigma2 , <sigma2> , ]
        [ velocity ratio , <vel_ratio> , ]
        <friction_function>
    <sigma2> ::= <const_value>
    <vel_ratio> ::= <const_value>
    <friction_function> ::= <ScalarFunction>
    \end{verbatim}
    where \kw{sigma2} gives the viscous friction;
    \kw{velocity ratio} defaults to 0.8, and is used
    to discriminate stick/slip conditions
\end{enumerate}
where \kw{friction\_function} give the static friction
as a function of sliding velocity.
\subsection{Shape functions}
A \kw{shape function} input format is:
\begin{verbatim}
    <shape_function> ::= <shape_function_type> ,
        <shape_function_arglist>
\end{verbatim}
Currently implemented friction models are:
\begin{enumerate}
    \item \kw{simple}\\
    This shape function is equal to one. It does not need arguments.
    \begin{verbatim}
    <shape_function> ::= simple
    <shape_function_arglist> ::=
    \end{verbatim}
    \item \kw{simple plane hinge}
    \begin{verbatim}
    <shape_function> ::= simple plane hinge
    <shape_function_arglist> ::= <radius>
    <radius> ::= <const_value>
    \end{verbatim}
    This is the shape function of a \kw{revolute hinge} with radius equal to 
    \kw{radius} and subject to small loads.
\end{enumerate}
\section{Shapes}
The \kw{shape} entities are objects that return a value depending on one
(or two, for 2D shapes) dimensionless abscissa, ranging $ \sqbr{-1,1} $.
At present, only 1D shapes are used, by aerodynamic elements.
A \kw{shape} input format is:
\begin{verbatim}
    <shape_1D> ::= <shape_type> ,
        <shape_arglist>
\end{verbatim}
The shapes currently available are:
\begin{enumerate}
    \item \kw{const}
    \begin{verbatim}
    <shape_type> ::= const
    <shape_arglist> ::= <const_value>
    \end{verbatim}
    \item \kw{linear}
    \begin{verbatim}
    <shape_type> ::= linear
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_1>
    \end{verbatim}
    \item \kw{piecewise linear}
    \begin{verbatim}
    <shape_type> ::= piecewise linear
    <shape_arglist> ::=
        <number_of_points> , 
            <abscissa> , <value>
            [ , ... ]
    \end{verbatim}
    \item \kw{parabolic}
    \begin{verbatim}
    <shape_type> ::= parabolic
    <shape_arglist> ::=
        <value_at_-1> , 
        <value_at_0> , 
        <value_at_1>
    \end{verbatim}
\end{enumerate}
This form of input has been chosen since, being the shapes mainly used to
interpolate values, it looks more ``natural'' to insert the mapping values
at characteristic points.
For \kw{piecewise linear} shapes, there must be 
\kw{number\_of\_points} pairs of absciss\ae\ and values; absciss\ae\
must be in the range $\sqbr{-1,1}$, in strict ascending order.


\section{Constitutive Laws}\label{sec:CONSTITUTIVE-LAWS}
Every time a ``deformable'' entity requires a constitutive law, a template
constitutive law is read. This has been implemented by means of the C++
templates in order to allow the definition of a general constitutive law
when possible. The ``deformable elements at present are \kw{rod}s, 1D,
\kw{deformable hinge}s and \kw{deformable displacement hinge}s, 3D,  
and \kw{beam}s, 6D.
The \kw{beam} element that uses the 6D template constitutive law has not been
implemented yet.
Some constitutive laws are meaningful only when related to some precise
dimension. 
Table~\ref{tab:CONST-LAW-DIM} shows the availability of each constitutive law.

\noindent
Usually, constitutive laws can be directly defined when required,
according to the definition of an element.
However, the special card described in Section~\ref{sec:CONSTITUTIVE-LAW}
allows to define constitutive laws stand-alone, and attach them
to the elements by means of the following mechanism:
\begin{verbatim}
    <constitutive_law> ::=
        { <constitutive_law_definition>
            | <constitutive_law_reference> }

    <constitutive_law_reference> ::= reference , <label>
\end{verbatim}
where \kw{<constitutive\_law\_definition>} is described in the following,
while \kw{<label>} is the label of a previously defined constitutive law
of the appropriate dimensionality, as described
in Section~\ref{sec:CONSTITUTIVE-LAW}.



\begin{table}[h]
    \newlength{\constlawwidth}
    \setlength{\constlawwidth}{70mm}
    \centering
    \caption{\em Constitutive Laws Availability}\label{tab:CONST-LAW-DIM}
    \begin{tabular}{l|c|c|c} 
        \hline
        Constitutive Law & 1D & 3D & 6D \\ 
	\hline
	linear elastic, linear elastic isotropic               & x & x & x \\
	linear elastic generic                                 & x & x & x \\
	linear elastic generic axial torsion coupling          &   &   & x \\
	log elastic                                            & x &   &   \\
	linear elastic generic bi-stop                         & x & x & x \\
	double linear elastic                                  & x & x &   \\
	isotropic hardening elastic                            & x & x & x \\
	linear viscous, linear viscous isotropic               & x & x & x \\
	linear viscous generic                                 & x & x & x \\
	linear viscoelastic, linear viscoelastic isotropic     & x & x & x \\
	linear viscoelastic generic                            & x & x & x \\
	double linear viscoelastic                             & x & x &   \\
	turbulent viscoelastic                                 & x &   &   \\
	linear viscoelastic generic bi-stop                    & x & x & x \\
	shock absorber                                         & x &   &   \\
	\hline
    \end{tabular}
\end{table}

\noindent 
The constitutive laws are entered as follows:
\begin{verbatim}
    <const_law> ::= <specific_const_law>                        
        [ , prestress, (entity) <prestress> ]
        [ , prestrain, (entity_tpl_driver) <prestrain> ]
    <specific_const_law> ::= <const_law_name> ,
        <const_law_data>
\end{verbatim}
where \kw{const\_law\_name} is the name of the constitutive law and
\kw{const\_law\_data} depends on the specific constitutive law. 
The latter fields, whose type depends on the dimension of the
constitutive law, are optional, under the assumption that the
constitutive law is the last portion of a card, or that any ambiguity 
can be avoided.
The data specific to the currently available constitutive laws must be
entered as follows:


\subsection{Linear elastic, linear elastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic [ isotropic ] , 
        (scalar) <stiffness>
\end{verbatim}
the isotropic stiffness coefficient
  
  
\subsection{Linear elastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic generic ,  
        (derivative_of_entity) <stiffness>
\end{verbatim}
the stiffness matrix. In case of 1D, the type is scalar, 
and there is no distinction between \kw{generic} and \kw{isotropic}, 
while, in case of \kw{n x 1} vectors, the type is the corresponding 
\kw{n x n} matrix.

\subsection{Linear elastic generic axial torsion coupling}
\begin{verbatim}
    <specific_const_law> ::= 
        linear elastic generic axial torsion coupling ,  
            (derivative_of_entity) <stiffness> ,
            (scalar) <coupling_coefficient>
\end{verbatim}
this is defined only for \kw{6 x 1} vectors, where the torsion stiffness,
coefficient $ a_{44} $ in the stiffness matrix, depends linearly on 
the axial strain, $ \varepsilon_1 $, by means of 
\kw{coupling\_coefficient}.
  
\subsection{Log elastic}
\begin{verbatim}
    <specific_const_law> ::= log elastic ,
        (derivative_of_entity) <stiffness>      
\end{verbatim}
this is defined only for scalars. The force is defined as:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \llk{log}\plbr{1+\varepsilon}
\end{displaymath}
  
\subsection{Linear elastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear elastic bistop,
        (derivative_of_entity) <stiffness> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{Double linear elastic}
\begin{verbatim}
    <specific_const_law> ::= double linear elastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2>
\end{verbatim}
this is defined for scalar and \kw{3 x 1} vectors. In the scalar case the
meaning of the entries is straightforward, while in case of \kw{3 x 1} vectors,
the constitutive law is isotropic but in the local direction 3, where, in
case of strain out of the upper or lower bound, the \kw{stiffness\_2} is
used.

\subsection{Isotropic hardening elastic}
\begin{verbatim}
    <specific_const_law> ::= isotropic hardening elastic ,
        (scalar) <stiffness> ,
        (scalar) <reference_strain>
\end{verbatim}
this constitutive law is defined as follows:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \frac{
        \alpha\shbr{\varepsilon}^2
    }{
        1+\alpha\shbr{\varepsilon}^2
    }\varepsilon
\end{displaymath}
where $ \alpha=3/\shbr{\kw{reference\_strain}}^2 $. The resulting
constitutive law, in the scalar case, is somewhat soft when
$ \varepsilon $ is smaller than \kw{reference\_strain}, while it grows to
quasi-linear for higher $ \varepsilon$s

\subsection{Linear viscous, linear viscous isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous [ isotropic ] , 
        (scalar) <viscosity_coefficient>
\end{verbatim}
the linear viscous coefficient. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscous generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscous generic , 
        (derivative_of_entity) <viscosity_matrix>
\end{verbatim}
the linear viscous matrix. \\
{\em 
    Note: this constitutive law does not require any prestrain template
    drive caller.
}
  
\subsection{Linear viscoelastic, linear viscoelastic isotropic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic [ isotropic ] ,
        (scalar) <stiffness> ,
        { (scalar) <viscosity_coefficient>
        | proportional, (scalar) <factor> }
\end{verbatim}
the isotropic stiffness and viscosity coefficients
  
\subsection{Linear viscoelastic generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic generic ,  
        (derivative_of_entity) <stiffness> ,
        { (derivative_of_entity) <viscosity_matrix> 
        | proportional, (scalar) <factor> }
\end{verbatim}
the linear stiffness and viscosity matrices
  
\subsection{Double linear viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= double linear viscoelastic ,
        (scalar) <stiffness_1> ,
        (scalar) <upper_strain> ,
        (scalar) <lower_strain> ,
        (scalar) <stiffness_2> ,
        (scalar) <viscosity_coefficient>
\end{verbatim}
this is analogous to the \kw{double linear elastic} constitutive law,
except for the isotropic viscosity term.
  
\subsection{Turbulent viscoelastic}
\begin{verbatim}
    <specific_const_law> ::= turbulent viscoelastic ,
        (scalar) <stiffness> ,
        (scalar) <parabolic_viscous_coefficient>
        [ , (scalar) <threshold> 
            [ , (scalar) <linear_viscous_coefficient> ] ]
\end{verbatim}
the constitutive law has the form:
\begin{displaymath}
    f \ = \ \kw{stiffness} \ \varepsilon + k \ \dot{\varepsilon}
\end{displaymath}
where:
\begin{displaymath}
    k = \lcubr{\matr{lcr}{
        \kw{linear\_viscous\_coefficient} & & 
            \shbr{\dot{\varepsilon}} \leq \kw{threshold} \\
        \kw{parabolic\_viscous\_coefficient} & &
            \shbr{\dot{\varepsilon}} > \kw{threshold}
    }}
\end{displaymath}
if \kw{threshold} is null, or not defined, the constitutive law is always
parabolic. If the \kw{linear\_viscous\_coefficient} is not defined, it is
computed based on \kw{parabolic\_viscous\_coefficient} and on 
\kw{threshold} to give a continuous force curve (with discontinuous slope).
Otherwise, it can be set by the user to give a discontinuous force curve,
as observed in some fluids at intermediate Reynolds number.

\subsection{Linear viscoelastic bi-stop generic}
\begin{verbatim}
    <specific_const_law> ::= linear viscoelastic bistop ,
        (derivative_of_entity) <stiffness> ,
        (derivative_of_entity) <viscosity_coefficient> ,
        [ initial state , { inactive | active } , ]
        (DriveCaller)<activating_condition> ,
        (DriveCaller)<deactivating_condition>
\end{verbatim}
  
\subsection{GRAALL damper}
This is a very experimental constitutive law, based on a nonlinear model
for a hydraulic damper to be used in landing gear modeling.
Basically, it requires the user to supply the name of the GRAALL-style 
input file with damper data.
It will be documented as soon as it reaches an appreciable level of
stability.
See also the 
\htmlref{\kw{shock absorber}}{sec:CL-SHOCK-ABSORBER}
constitutive law.


\subsection{shock absorber}\label{sec:CL-SHOCK-ABSORBER}
This constitutive law implements a landing gear hydraulic shock absorber:
\begin{verbatim}
    <specific_const_law> ::= shock absorber ,
        [ prestrain , <value> , ]
        <reference pressure> ,
        <reference area for force computation> ,
        <interaction coefficient> ,
        <polytropic exponent> ,
        [ epsilon max , <upper strain bound> , ]
        [ epsilon min , <lower strain bound> , ]
        [ penalty , <penalty factor for strain> , 
            <penalty factor for strain rate> , ]
        [ metering , <metering area> ,
            [ negative , <metering area for negative strain rate> , ]
        [ orifice , <orifice area> , ]
        <fluid area> ,
        <fluid density> ,
        <drag coefficient / reference length
                (scales strain rate to velocity)>
        [ , friction, <reference epsilon prime> ,
                 <friction amplitude coefficient> ]
\end{verbatim}
where
\begin{itemize}
\item the \kw{interaction coefficient} is represented by
\begin{displaymath}
	\kw{kinematic scale} \frac{L A}{V_0}
\end{displaymath}
where \kw{kinematic scale} is the ratio between the stroke
of the shock absorber and that of the gas;
\item \kw{epsilon max} is the upper strain bound; it must be
at least larger than the prestrain, and defaults to 0,
i.e.\ the shock absorber, at rest, is assumed to be fully
extended;
\item \kw{epsilon min} is the lower strain bound; it must be
at least smaller than the prestrain, and defaults to -0.5, 
i.e.\ the shock absorber is assumed to allow a contraction
equal to half its full length;
\item the \kw{penalty factor for strain} defaults to 1e+9;
it is active only when strain bounds are violated;
\item the \kw{penalty factor for strain rate} defaults to 0;
it is active only when strain bounds are violated;
\item the \kw{metering area} is given by a \kw{drive} 
and is strain dependent; if the keyword \kw{negative} is used, 
then the \kw{metering area for negative strain rate} is used
when the strain rate is negative, i.e.\ the shock absorber
is being compressed, while the \kw{metering area} is used only
when the shock absorber is extending;
\item the \kw{<orifice>} drive determines the area of an
additional orifice, which essentially depends on the sign
of the strain rate; it is used to implement relief valves;
\item ...
\end{itemize}
This constitutive law adds the entities described
in Table~\ref{tab:CL-SHOCK-ABSORBER-OUTPUT} to the output of the
element it is used for.
The table also indicates the names that can be used to reference
the entities as element private data.

\begin{table}
\centering
\caption{Shock absorber output data}\label{tab:CL-SHOCK-ABSORBER-OUTPUT}
\begin{tabular}{ll}
\hline
\multicolumn{1}{c}{\textbf{entity}} & \multicolumn{1}{c}{\textbf{name}} \\
\hline
gas pressure	& \kw{p} \\
metering area	& \kw{A} \\
elastic force	& \kw{Fe} \\
viscous force	& \kw{Fv} \\
\hline
\end{tabular}
\end{table}


\section{Hydraulic fluid}\label{sec:HYDRAULIC-FLUID-DATA}
Hydraulic fluid data defines the constitutive properties
of hydraulic fluids, which are generally required by hydraulic elements.
Hycraulic fluid data can be defined in two ways, according to the BNF:
\begin{verbatim}
    <hydraulic_flid> ::=
        { <fluid_type> , <fluid_properties>
            | reference, <label> }
\end{verbatim}
The latter references a previously defined hydraulic fluid dataset,
described in Section~\ref{sec:HYDRAULIC-FLUID}.
The \kw{fluid\_type}s, with the related \kw{fluid\_properties}, are:

\subsection{Uncompressible}
\begin{verbatim}
    <fluid_type> ::= uncompressible
    <fluid_properties> ::=
        [ density , <density> ]
        [ , viscosity , <viscosity> ]
        [ , pressure , <pressure > ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible}
\begin{verbatim}
    <fluid_type> ::= linear compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ]
        [ , viscosity , <viscosity> ]
        [ , temperature , <temperature> ]
\end{verbatim}

\subsection{Linearly compressible, with thermal dependency}
\begin{verbatim}
    <fluid_type> ::= linear thermal compressible
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}

\subsection{Super (linearly compressible, with thermal dependency)}
\begin{verbatim}
    <fluid_type> ::= super
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> ]
        [ , viscosity , <viscosity> ]
\end{verbatim}
according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 + \rho_{ref}\cfrac{1}{2}\plbr{
			1 + \llk{tanh}\plbr{a\plbr{p-p_{ref}}}
		} & p < p_{ref} \\
		+= \ \cfrac{p-p_{ref}}{\beta} & p > p_{ref}
	}
\end{displaymath}
\emph{Note: highly experimental}

\subsection{Exponential compressible fluid, with saturation}
\begin{verbatim}
    <fluid_type> ::= exponential
    <fluid_properties> ::=
        [ density , <ref_density> ,
            <beta> , <ref_pressure> ,
            <alpha> , <ref_temperature> , ]
        [ viscosity , <viscosity> , ]
        <psat>
\end{verbatim}
where \kw{psat} is the saturation pressure, according to equation
\begin{displaymath}
	\matr{ll}{
		\rho \ = \ \rho_0 \e{\cfrac{p-p_0}{\beta}} &
		p > p_{sat} \\
		\rho \ = \ \rho_0 \e{1000\cfrac{p-p_0}{\beta}} &
		p < p_{sat}
	}
\end{displaymath}
\emph{Note: this fluid constitutive law is loosely inspired by AMESim's
simply corrected compressible fluid.}



\section{Authentication Methods}
Some authentication methods are defined and made available to specific
program modules; they are used to authenticate before accessing some
resources of the program while it is running.
The syntax is:
\begin{verbatim}
    <authentication_method> ::= <method> [ , <specific_data> ]
\end{verbatim}
Authentication methods in general expect some authentication tokens to be
input.
Usually a user name and a password are required.

\subsection{Note on security and confidentiality}
No encryption is used in communications, unless provided
by the underlying mechanism (e.g. some SASL mechs), 
so the authentication methods are very rough
and should be considered as insecure.
Secure Socket connection or other SSL-like communication protocol
may be considered in the future.
If confidentiality is required, SASL with at least DIGEST-MD5 
is strongly recommended; otherwise no authentication should be used.
As alternatives, a SSH tunnel may be established between the client
and the server machine, and simple authentication can be used.
Otherwise, if the user has direct access to the server where
the computation is being run, sockets with \kw{local} namespace
can be used, and security can be enforced by means of the access
privileges of the socket file.
Since some of the UNIX systems do not honor socket permissions,
a portable way to exploit filesystem access permissions is to put
the socket in a dedicated directory, and use the permissions
of the directory to control access to the socket.

\noindent
Available methods are:
\subsection{No authentication}
\begin{verbatim}
    <authentication_method> ::= no auth
\end{verbatim}

\subsection{Password}
\begin{verbatim}
    <authentication_method> ::= password ,
        user , " <user_name> " ,
        credentials , { prompt | " <user_cred> " }
        [ , salt format , <salt_format> ]
\end{verbatim}
In case the keyword \kw{prompt} is given as credentials, the user is
prompted for a password.
The optional parameter \kw{salt\_format} allows to specify different
formats for the \kw{salt}, for those \kw{crypt(3)} extensions 
that support more sophisticated encryption mechanisms (e.g.\ MD5).
See \kw{crypt(3)} for details.
If the credentials are preceded by the string \kw{\{CRYPT\}},
they are assumed to be already encypted, and the remaining portion is used.

\subsection{PAM (Pluggable Authentication Modules)}
\begin{verbatim}
    <authentication_method> ::= pam 
        [ , user , " <user_name> " ]
\end{verbatim}
The {\em Linux-PAM} Pluggable Authentication Modules can be used to
authenticate a user. 
If no user name is provided, the effective user id, as provided by the 
\kw{geteuid()} system function, is used to retrieve the username of the
owner of mbdyn process.
the \kw{user} must be valid. 
The authentication is performed through a system-dependent \kw{pam}
configuration file.
No checks on the validity of the account or on the permission of opening a
session are made; account, session and password changes should be explicitly
denied to \kw{mbdyn} to avoid possible security breaks (see the following
example).
The interested reader should consult the documentation that comes with the
package, try for instance
\begin{verbatim}
    http://parc.power.net/morgan/Linux-PAM/index.html
\end{verbatim}
An example is provided with the package, in  \kw{/etc/pam.d/mbdyn}, reading:
\begin{verbatim}
    ### use either of the following:
    auth       required     /lib/security/pam_unix_auth.so
    # auth       required     /lib/security/pam_pwdb.so
    #
    ### no account, session or password allowed
    account    required     /lib/security/pam_deny.so
    session    required     /lib/security/pam_deny.so
    password   required     /lib/security/pam_deny.so
\end{verbatim}
which allows authentication by using standard Un*x or \kw{libpwdb} based
authentication.



\subsection{SASL (Simple Authentication and Security Layer)}
\begin{verbatim}
    <authentication_method> ::= sasl
        [ , user , " <user_name> " ]
        [ , mech , " <preferred_mechanism> " ]
\end{verbatim}
This is the preferred authentication method because 
it is mechanism-independent, it can be reasonably secure
and automatically selects the most appropriate mechanism available
on both the client and the server machine.
It requires Cyrus SASL 2 (See 
\htmladdnormallink{\texttt{http://asg.web.cmu.edu/sasl/}} for details,
and follow the documentation to obtain a working setup).



\section{Miscellaneous}
Finally there are some miscellaneous points:
\begin{itemize}
    \item (UN*X systems) Environment variables whose name starts with MBDYN may
    be defined and passed to an execution of the mbdyn command.
    The following are recognized at present:
  
    \begin{enumerate}
  
        \item \kw{MBDYNVARS=<expr\_list>}
	where \kw{expr\_list} is a series of mathematical expressions
	separated by semicolons. 
	They are parsed and evaluated; if variables are declared, they are
	added to the symbol table to be used during the whole execution 
	of the program.
    
        \item \kw{MBDYN\_<type>\_<name>=<value>},
	where \kw{type} is a legal mbdyn type (\kw{integer} or \kw{real}),
	\kw{name} is a legal symbol name and \kw{value} is a legal
	mathematical expression.
    
    \end{enumerate}
    
    \item Newlines and indentations are not meaningful. But good indentation
    habits can lead to better and more readable input files.
    
    \item Everything that follows the character \kw{`\#'} is considered a
    remark, and is discarded until the end of the line. 
    This can occur everywhere in the file, even inside a math expression 
    (if any problems occur, please let me know, because chances are 
    it is a bug!)
    
    \item A new style for comments has been introduced, resembling the 
    C programming language style: everything comprised between the marks 
    \begin{verbatim}
    /*
        useful comments make input files readable!
    */
    \end{verbatim}
    is regarded as a remark. 
    This can happen everywhere in the text {\bf except} in the middle 
    of a keyword.
    
    \item (UN*X systems) Whenever a file name contains a portion
    of the form \verb;$VARNAME; or \verb;${VARNAME};, appropriate
    expansion from environment is performed; \verb;VARNAME; is
\begin{verbatim}
    VARNAME ::= [_a-zA-Z][_a-zA-Z0-9]*
\end{verbatim}
    namely, it must begin with a letter or an underscore, and can be
    made of underscores, letters and digits.

    \item (UN*X systems) Whenever a file name is required, the shell-like
    syntax for home directories (i.e.\ \verb1~/filename1
    or \verb1~user/filename1 is automatically resolved if legal [user and]
    filename values are inserted.
    Home expansion occurs after environment variable expansion (see above).

    \item The \kw{license} and the \kw{warranty} commands
    respectively show the license and the warranty statement under 
    which the code is released on the standard output.
    They do not affect the simulation.
    
\end{itemize}  
 
