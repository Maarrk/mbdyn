% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2011
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Overview}\label{sec:OVERVIEW}
This chapter gives a global overview of the structure of the input file.


\section{Input File Structure}
The input is divided in blocks.
This is a consequence of the fact that almost every module of the code 
needs data and each module is responsible for its data input. 
So it is natural to make each module read and interpret its data starting 
from the input phase.

Every statement (or `card') follows the syntax:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{card} ::= \bnt{description} [ : \bnt{arglist} ] ;
\end{Verbatim}
%\end{verbatim}
\nt{arglist} is a(n optional) list of arguments, that is driven by the 
\nt{description} that identifies the card. 
The keyword can be made of multiple words separated by spaces or tabs; 
the extra spaces\footnote{
	Anything that makes the C function \texttt{isspace()} 
	return \kw{true}
} are skipped, and the match is case insensitive. 
The arguments are usually separated by commas\footnote{
	A few exceptions require a colon to separate blocks of arguments;
	wherever it is feasible, those exceptions will be eliminated 
	in future versions.
	Those cards will be marked as deprecated.
}.
A semicolon ends the card. 

Many cards allow extra arguments that may assume default values 
if not supplied by the user. 
Usually these arguments are at the end of the card
and must follow some rules. 
A check for the existence of extra args is made,
and they are usually read in a fixed sequence.
Optional args are usually prefixed by a keyword.

When structured arguments like matrices, vectors, or drive callers are
expected, they are parsed by dedicated functions.
Anyway, the structured data always follows the rules of the general data. 
Few exceptions are present, and will be eliminated soon.
Every data block is surrounded by the control statements \kw{begin} and
\kw{end}:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{begin} : \bnt{block_name} ;
        # block content
    \kw{end} : \bnt{block_name} ;
\end{Verbatim}
%\end{verbatim}
The block sequence is:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{begin} : \kw{data} ;
        # select a problem
        \kw{problem} : \bnt{problem_name} ;
    \kw{end} : \kw{data} ;

    \kw{begin} : \bnt{problem_name} ;
        # problem-specific data
    \kw{end} : \bnt{problem_name} ;

    \kw{begin} : \kw{control data} ;
        # model control data
    \kw{end} : \kw{control data} ;

    \kw{begin} : \kw{nodes} ;
        # nodes data
    \kw{end} : \kw{nodes} ;

    # note: optional, if requested in \kw{control data}
    \kw{begin} : \kw{drivers} ;
        # special drivers data
    \kw{end} : \kw{drivers} ;

    \kw{begin} : \kw{elements} ;
        # elements data
    \kw{end} : \kw{elements} ;
\end{Verbatim}
%\end{verbatim}
The \kw{drivers} block is optional.

The Schur solver allows an extra block after that of the elements:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    # note: optional; only allowed when Schur solver is defined in \nt{problem_name}
    \kw{begin} : \kw{parallel} ;
        # parallel data
    \kw{end} : \kw{parallel} ;
\end{Verbatim}
%\end{verbatim}
where data specific to the partitioning and the connectivity
of the Schur solver is provided.
This is yet undocumented, and will likely be described 
in a future chapter.

Chapter~\ref{sec:GENERAL} describes the basic and aggregate
data structures that concur in building up the cards.
Chapter~\ref{sec:DATA} describes problem selection options.
Chapter~\ref{sec:PROBLEMS} describes the cards dedicated
to the specification of the parameters of the simulation
and of the selected integration scheme.
Chapter~\ref{sec:CONTROL-DATA} describes the model control data.
Chapter~\ref{sec:NODES} describes the cards related to the input
of nodes.
Nodes come first because they are the elementary blocks 
of the connectivity graph of the model, so historically 
they had to be defined before any element could be introduced.
Chapter~\ref{sec:DRIVERS} describes the cards related 
to special drivers.
Chapter~\ref{sec:ELEMENTS} describes the cards related to the input
of elements.



\section{Output}
The program outputs data to a set of files for each simulation.
The contents of each file is related to the file extension,
which is appended to the input file if no output file name 
is explicitly supplied.

If no input file is explicitly provided as well, and thus input
is directly read from \kw{stdin}, the output file name defaults
to `MBDyn'.
Otherwise, unless the output file name is explicitly set, the name 
of the input file is used.

The contents of the output files are described within the description
of the items (nodes or elements) that generate them.
Only a general information file, with extension \texttt{.out}, 
is described here. 
The file contains general information about the simulation; 
it is not formatted. 

The file contains occasional informational messages,
prefixed by a hash mark (`\#').
These messages should be intended as comments about the current status
of the simulation.
At some point, after initialization completes, the comment
\begin{verbatim}
# Step Time TStep NIter ResErr SolErr SolConv
\end{verbatim}
appears, which illustrates the contents of the lines that will be written
for each time step.
The fields indicate:
\begin{enumerate}
\item \texttt{Step}: the time step number;
\item \texttt{Time}: the time at that step;
\item \texttt{TStep}: the time step at that step
	(\texttt{Time}$_k$ - \texttt{Time}$_{k-1}$);
\item \texttt{NIter}: the number of iterations required to converge;
\item \texttt{ResErr}: the error on the residual after convergence
	(0 if not computed);
\item \texttt{SolErr}: the error on the solution after convergence
	(0 if not computed);
\item \texttt{SolConv}: a boolean that indicates whether convergence
	was determined by the error criterion on the residual
	or on the solution (0 for residual, 1 for solution).
\end{enumerate}

There is also a supplementary file, with \texttt{.log} extension,
that may contain extra (logging) information.
Its content, although very experimental and subjected to changes,
is documented in Appendix~\ref{sec:APP:LOGFILE}.

\bigskip

Experimental support for output using the NetCDF database format
is available for selected items.
See Appendix~\ref{sec:NETCDF} for details.

