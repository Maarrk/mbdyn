% $Header$
% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2010
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
% Copyright (C) 2008
%
% Marco Morandini

\chapter{Elements}\label{sec:ELEMENTS}
The \kw{elements} section is enclosed in the cards:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \kw{begin} : \kw{elements} ;
        # ...
    \kw{end} : \kw{elements} ;
\end{Verbatim}
%\end{verbatim}
Every element card has the following format:
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{card} ::= \bnt{elem_type} :
        \bnt{arglist}
        [ , \kw{output} , \{ \kw{yes} | \kw{no} \} ] 
        [ , \bnt{extra_arglist} ] ;
\end{Verbatim}
%\end{verbatim}
where \kw{elem\_type} is one of the following:
\begin{itemize}
\item structural elements:
\begin{itemize}
\item \kw{automatic structural}
\item \kw{beam}
\item \kw{body}
\item \kw{couple}
\item \kw{gravity}
\item \kw{joint}
\item \kw{joint regularization}
\end{itemize}

\item aerodynamic elements:
\begin{itemize}
\item \kw{aerodynamic beam2}
\item \kw{aerodynamic beam3}
\item \kw{aerodynamic body}
\item \kw{aeromodal}
\item \kw{aircraft instruments}
\item \kw{air properties}
\item \kw{induced velocity}
\end{itemize}

\item electric elements:
\begin{itemize}
\item \kw{electric}
\end{itemize}

\item hydraulic elements:
\begin{itemize}
\item \kw{hydraulic}
\end{itemize}

\item thermal elements:
\begin{itemize}
\item TODO \ldots
\end{itemize}

\item output elements:
\begin{itemize}
\item \kw{RTAI output}
\item \kw{stream output}
\item \kw{stream motion output}
\end{itemize}

\item generic elements:
\begin{itemize}
\item \kw{bind}
\item \kw{bulk}
\item \kw{force}
\item \kw{genel}
\item \kw{loadable}
\end{itemize}

\item miscellaneous element cards
\end{itemize}


In case of elements that can be instantiated only once, like
the \kw{gravity} or the \kw{air properties} elements, the \nt{arglist}
doesn't contain any label; otherwise, a label is expected first, to allow 
for checks on duplicated elements, namely: 
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{arglist} ::= \bnt{label} , \bnt{normal_arglist}
\end{Verbatim}
%\end{verbatim}
The data manager reads the element type and the label and checks for
duplication. If the element is not defined yet, the proper read function is
called, which parses the rest of the card and constructs the element.
The elements are read as follows.



\input{elemaero}



\section{Automatic structural}
The so called \kw{automatic structural} element is automatically generated
when a dynamic structural node is instantiated.
As such, when defined in the \kw{elements} block,
the element already exists.
The only reason to repeat its definition is to modify the values
of the momentum and of the momenta moment, and to initialize
their derivatives.
The label must match that of the node it refers to.
\begin{verbatim}
    <element_type> ::= automatic structural
    <normal_arglist> ::=
        (Vec3) <momentum> ,
        (Vec3) <momenta_moment> ,
        (Vec3) <momentum_derivative> ,
        (Vec3) <momenta_moment_derivative>
\end{verbatim}
All the provided values are recomputed during the initial derivatives phase,
so they should be intended as initial values for the Newton iteration.
In general, there is no need to provide this data; they can speed up
initial convergence in case of systems that are not at rest in the initial
configuration, with kinematic constraints that strongly affect
the motion.

\paragraph{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"beta[1]"} momentum in global direction 1
\item \kw{"beta[2]"} momentum in global direction 2
\item \kw{"beta[3]"} momentum in global direction 3
\item \kw{"gamma[1]"} momenta moment in global direction 1
\item \kw{"gamma[2]"} momenta moment in global direction 2
\item \kw{"gamma[3]"} momenta moment in global direction 3
\item \kw{"betaP[1]"} momentum derivative in global direction 1
\item \kw{"betaP[2]"} momentum derivative in global direction 2
\item \kw{"betaP[3]"} momentum derivative in global direction 3
\item \kw{"gammaP[1]"} momenta moment derivative in global direction 1
\item \kw{"gammaP[2]"} momenta moment derivative in global direction 2
\item \kw{"gammaP[3]"} momenta moment derivative in global direction 3
\end{enumerate}


% beam element
\input{beam}


\section{Bind}\label{sec:EL:BIND}
The statement \kw{bind} does not really define an element.
It is rather used to instruct a
\htmlref{\kw{parameter node}}{sec:NODE:PARAMETER}
about which parameter of an element it is bound to.
The \kw{parameter node} must exist, and the element the node 
is being bound to, of type \kw{element\_type} and label \kw{element\_label},
must have been already defined.
The complete syntax is:
\begin{verbatim}
    <arglist> ::= <element_label> , 
        <element_type> ,
        <parameter_node_label> , 
        <bind_args>
\end{verbatim}
where \kw{bind\_args} depend on the type of parameter node.

\subsection{Element}
When binding an element to an 
\htmlref{\kw{element}}{sec:NODE:PARAMETER:ELEMENT} parameter node,
each element makes a number of specific parameters available.
A detailed list is given for each element in the \kw{private data}
section.
In that case:
\begin{verbatim}
    <bind_args> ::=
        { <parameter_index> | name , " <parameter_name> " }
\end{verbatim}
The value of \kw{parameter\_index} must be legal, i.e.\ between 1 and the
maximum number of parameters made available by the element.
The alternative form, which will become the default, allows more
friendly definition of the binding.
The name of the parameter depends on the element whose property
is being bound.
A complete listing of the parameters that a parameter node 
can be bound to is not available, since most are added based
on developers' needs.
It is advisable that a mechanism for elements to publish 
what parameters they can make available be devised and implemented.

\paragraph{Example.} \
The parameter node \kw{angle} is bound to the rotation of a 
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE}.
\begin{verbatim}
    # ... problem block

    begin: control data;
        structural nodes: 2;
        parameter nodes: 1;
        forces: 2;
        # ... other control data
    end: control data;

    set: integer node1 = 1000;
    set: integer node2 = 2000;
    set: integer angle = 5000;

    begin: nodes;
        structural: node1, dynamic, null, eye, null, null;
        structural: node2, dynamic, null, eye, null, null;
        parameter: angle, element;

        # ... other nodes
    end: nodes;

    begin: elements;
        joint: 1, revolute hinge,
            node1, reference, node, null,
                hinge, reference, node, eye,
            node2, reference, node, null,
                hinge, reference, node, eye;
        bind: 1, joint, angle, string, "rx";
        couple: 1, node1, 0.,0.,1.,
            dof, angle, parameter, 1, linear, 0.,1.;
        couple: 2, node2, 0.,0.,1.,
            element, 1, joint, string, "rx", linear, 0.,1.;

        # ... other elements
    end: elements;
\end{verbatim}
Note that the same element data, i.e.\ the revolute hinge
relative rotation angle, is used to drive a couple in two different
ways; the latter, by means of the 
\hyperref{\kw{element} drive}{\kw{element} drive (see Section~}{)}{sec:DRIVE:ELEMENT}
is more direct, but the former, by means of the 
\hyperref{\kw{dof} drive}{\kw{dof} drive (see Section~}{)}{sec:DRIVE:DOF}
through the \kw{bind} mechanism has the additional effect of updating
the \kw{parameter} node, which can be used to connect
\htmlref{\kw{genel}}{sec:EL:GENEL} elements for special purposes.

\subsection{Beam strain gage}
When binding an element to a
\htmlref{\kw{beam strain gage}}{sec:NODE:PARAMETER:BEAM_STRAIN_GAGE}
parameter node, the \kw{element\_type} field must be \kw{beam}.
In that case:
\begin{verbatim}
    <bind_args> ::=
        <evaluation_point>
\end{verbatim}
where \kw{evaluation\_point} is the evaluation point of the beam element
where the internal strain and curvatures must be evaluated.
It must be 1 for 2-node beams, while it can be either 1 or 2
for 3-node beams.

\paragraph{Example.} \
\begin{verbatim}
    # ... problem block

    begin: control data;
        parameter nodes: 1;
        beams: 1;
        # ... other control data
    end: control data;

    set: integer BEAM = 100;
    set: integer STRAIN = 200;

    begin: nodes;
        parameter: STRAIN, beam strain gage, 0.0, 0.1;
        # ... other nodes
    end: nodes;

    begin: elements;
        beam3: BEAM, ...; # beam data
        bind: BEAM, beam, STRAIN, 1;
        # ... other elements
    end: elements;
\end{verbatim}



\section{Body}
\begin{verbatim}
    <one_body> ::=
        (scalar) <mass> , 
        (Vec3)   <relative_center_of_mass> ,
        (Mat3x3) <inertia_matrix>
        [ , inertial , 
            { node | (OrientationMatrix) <orientation_matrix> } ]

    <normal_arglist> ::= <node_label> ,
        { <one_body>
        | condense, (integer) <num_masses> ,
            <one_body> [ , ... ] }
\end{verbatim}
If only one mass is defined, the first method should be used. Otherwise,
many masses can be referred to the same element by means of the keyword
\kw{condense}, followed by the number of expected masses \kw{num\_masses}.
The format of each sub-mass is the same as for the single mass input (actually, 
when \kw{condense} is not supplied, \kw{num\_masses} is assumed to be 1).

The \kw{inertia\_matrix} is always referred to the center of mass of the
mass that is being added. It can be rotated locally by means of the extra
\kw{orientation\_matrix} supplied after the (optional) keyword \kw{inertial}.
The keyword \kw{node} corresponds to the default, i.e.\ the inertia matrix
is assumed to be input in the node reference frame.

Note: in many commercial finite element software, the off-diagonal elements 
of the inertia matrix are defined with a minus sign; for instance, 
NASTRAN's \kw{CONM2} lumped inertia card expects the values as indicated
in Figure~\ref{fig:el:body:CONM2}.
%
\begin{figure}[b]
\centering
\begin{minipage}{120mm}
\begin{boxedverbatim}
$.......2.......3.......4.......5.......6.......7.......8.......
CONM2   EID     G       CID     M       X1      X2      X3
        I11     I21     I22     I31     I32     I33
\end{boxedverbatim}
\end{minipage}
\caption{NASTRAN \kw{CONM2} card}
\label{fig:el:body:CONM2}
\end{figure}
%
However, the matrix is reconstructed as
\begin{displaymath}
	\mathrm{NASTRAN \ ::= } \ \sqbr{\matr{cccccc}{
		M & & & & & \\
		& M & & \multicolumn{3}{c}{\mathrm{symmetric}} \\
		& & M & & & \\
		& & & I11 & & \\
		& & & -I21 & I22 & \\
		& & & -I31 & -I32 & I33
	}}
\end{displaymath}
see for instance \emph{NASTRAN V70.5 Quick Reference Guide} for details.

\noindent
On the contrary, MBDyn directly reads the matrix 
that will be used in the computation, i.e.\ 
\textbf{without the minus signs in the off-diagonal terms},
as reported below:
\begin{displaymath}
	\mathrm{MBDyn \ ::= } \ \sqbr{\matr{ccc}{
		i11 & i12 & i13 \\
		& i22 & i23 \\
		\multicolumn{2}{l}{\mathrm{sym.}} & i33
	}}
\end{displaymath}
So:
\begin{eqnarray*}
	i11 & = & I11 \\
	i22 & = & I22 \\
	i33 & = & I33 \\
	i12 & = & - I21 \\
	i13 & = & - I31 \\
	i23 & = & - I32
\end{eqnarray*}
The inertia properties of the model can be logged and verified
by means of the \kw{inertia} keyword, as detailed
in Section~\ref{sec:EL:MISC:INERTIA}.

\paragraph{Example.} \
\begin{verbatim}
    set: integer NODE_LABEL = 100;
    set: integer BODY_LABEL = 100;

    # single mass example
    body: BODY_LABEL, NODE_LABEL,
        8.,                            # mass
        reference, node, 0., 0., 0.,   # c.m. offset
        diag, 4.8, 4.8, .4;            # inertia tensor

    # three masses example (equivalent to the previous one)
    body: BODY_LABEL, NODE_LABEL,
        condense, 3,
        4.,                            # mass 1 (mid)
        reference, node, 0., 0., 0.,   # c.m. offset 1
        diag, .4, .4, .2,              # inertia tensor 1
        2.,                            # mass 2 (top)
        reference, node, 0., 0., 1.,   # c.m. offset 2
        diag, .2, .2, .1,              # inertia tensor 2
        2.,                            # mass 3 (bottom)
        reference, node, 0., 0., -1.,  # c.m. offset 3
        diag, .2, .2, .1;              # inertia tensor 3
\end{verbatim}

\section{Bulk Elements}
The \kw{bulk} element is intended as a sort of NASTRAN's \kw{CELAS} card,
that can be used to apply a stiffness term on an arbitrary degree of freedom.
Extensions are planned to different kind of elements.
The syntax of the \kw{bulk} element is:
\begin{verbatim}
    <normal_arglist> ::= <bulk_type> , <bulk_arglist>
\end{verbatim}
At present only the \kw{stiffness spring} type is available.

\subsection{Stiffness spring}
\begin{verbatim}
    <bulk_type> ::= stiffness spring
    <bulk_arglist> ::= (node_dof) <dof> ,
                       (drive_caller) <stiffness_drive>
\end{verbatim}
The equation related to the desired dof of the linked node is added a
contribution based on the value of the desired degree of freedom (even the
derivative can be used) multiplied times the stiffness.

{\em Note: this family of elements has been partially superseded by the
\htmlref{\kw{genel}}{sec:EL:GENEL} elements, which allow more generality.}




\section{Couple}
A variant of \kw{force}; see Section~\ref{sec:EL:FORCE} for details.




\section{Electric Elements}
\kw{electric} elements are those elements that model electric and electronic
devices, dealing with abstract degrees of freedom more than with electric
ones (from the program's point of view they are exactly the same, the
difference is only semantic). The true electric elements, such resistors,
switches and so on, are classified as \kw{electric bulk} elements.
The syntax for \kw{electric} elements is:
\begin{verbatim}
    <normal_arglist> ::= <electric_type> , <electric_arglist>
\end{verbatim}
The \kw{electric} elements implemented at present are:
\begin{itemize}
	\item \kw{accelerometer}
	\item \kw{displacement}
	\item \kw{motor}
	\item \kw{discrete control}
\end{itemize}
The syntax is described below.

\subsection{Accelerometer}
\begin{verbatim}
    <electric_arglist> ::=
        { translational | rotational } ,
        <struct_node_label> ,
        <abstract_node_label> ,
        ((Unit)Vec3) <measure_direction>
        [ , position , (Vec3) <position> ]
\end{verbatim}
The \kw{position} is optional; it is meaningless for \kw{rotational}
accelerometers.
The measure is taken along or about direction \kw{measure\_direction};
the vector is internally normalized to unity.

\noindent
Legacy element: accelerometer with built-in transfer function
\begin{verbatim}
    <electric_arglist> ::= <struct_node_label> ,
        <abstract_node_label> ,
        ((Unit)Vec3) <measure_direction> ,
        (scalar) <omega> ,
        (scalar) <tau> ,
        (scalar) <csi> ,
        (scalar) <kappa>	
\end{verbatim}
The label \kw{struct\_node\_label} defines the node whose acceleration 
is being measured; the label \kw{abstract\_node\_label} defines the
\kw{abstract node} that will receive the output signal. 
An \kw{electric node} can be used as well (?).
The measure is taken along direction \kw{measure\_direction};
the vector is internally normalized to unity.
The transfer function of the accelerometer is:
\begin{displaymath}
    \frac{e_0}{a} = \kw{kappa}\frac{\kw{tau} \ s}{
        \plbr{1+\kw{tau} \ s}
        \plbr{1+2 \ \kw{csi}/\kw{omega} \ s+s^2/\kw{omega}^2}
    }
\end{displaymath}
where $ e_0 $ is the output signal, $ a $ is the input (the acceleration)
and $ s $ is the Laplace variable.

\subsection{Displacement}
\begin{verbatim}
    <electric_arglist> ::=
        <node_1> , (Vec3) <relative_offset_1> ,
        <node_2> , (Vec3) <relative_offset_2> ,
        <abstract_node_label>
\end{verbatim}
\begin{subequations}
\begin{align}
	\T{d} &= \T{x}_b + \T{o}_b - \T{x}_a - \T{o}_a \\
	x &= \sqrt{\T{d}^T \T{d}}
\end{align}
\end{subequations}
The value $x$ is added to the right-hand side of the equation
of the \kw{abstract} node.

\subsection{Motor}
\begin{verbatim}
    <electric_arglist> ::=
        <node_1> ,
        <node_2> , 
        ((Unit)Vec3) <direction_relative_to_node_1> ,
        <abstract_node_label1>,
        <abstract_node_label2>,
        (scalar) dG,
        (scalar) dl,
        (scalar) dr
\end{verbatim}
\begin{subequations}
\begin{align}
	\omega &= \T{e}^T \plbr{\T{\omega}_2 - \T{\omega}_1} \\
	V &= V_2 - V_1 \\
	V &= \mathtt{dl} \frac{\mathrm{d}i}{\mathrm{d}t} + \mathtt{dr} \, i + \mathtt{dG} \, \omega \\
	\T{c}_1 &= - \T{e} \, \mathtt{dG} \, i \\
	\T{c}_2 &= \T{e} \, \mathtt{dG} \, i \\
	i_1 &= -i \\
	i_2 &= i
\end{align}
\end{subequations}
The motor applies an internal torque about direction
$\T{e}$=\kw{direction\_relative\_to\_node\_1}
to both the structural nodes it is connected to.
The direction $\T{e}$ is internally normalized to unity.
It also applies a current to both the electrical nodes it is connected to.

The element assumes that the relative orientation between nodes 1 and 2
can only change by rotating about the direction $\T{e}$, so appropriate
joints must be in place.


\subsection{Discrete control}\label{sec:EL:DISCCTRL}
This element implements a discrete equation
that can be used to represent the behavior
of a discrete linear controller.
The control matrices can be either provided,
or identified during the simulation by recursive least squares.

Assume the original system consists in a generic nonlinear process
that depends on a set of measures $\T{y}$ and a set of inputs $\T{u}$
at a finite number of time steps past the current time, $t_k$, namely
\begin{align}
	\T{f}\plbr{\T{y}_{k - i}, \T{u}_{k - j}} = \T{0} ,
\end{align}
with $i=0,p$ and $j=0,q$.
Only $\T{y}_k$ is unknown, and thus represents the output of the process.
It is assumed that $\T{u}_k$ is known, and represents an input
to the process.

This element implements a controller of the form
\begin{align}
	\T{u}_{ck}
	&= \sum_{i=1,p} \TT{B}_{ci} \T{u}_{k - i}
	+ \sum_{j=1,q} \TT{A}_{cj} \T{y}_{k - j} ,
\end{align}
where $\T{u}_{ck}$ is the control input that must be applied
at time $t_k$ in addition to any exogenous input $\T{u}_{ek}$,
so that $\T{u}_k = \T{u}_{ek} + \T{u}_{ck}$.
The control input $\T{u}_{ck}$ can only depend on the measures
and the inputs at previous time steps.

Note that the symbols commonly used for discrete systems
are here reversed, since the element is intended to compute
the control signals at time $t_k$, $\T{u}_{ck}$,
based on the previous value of the controls,
$\T{u}_{k-i} = \T{u}_{e(k - i)} + \T{u}_{c(k - i)}$,
and on the previous value of the motion of the original system,
$\T{y}_{k-j}$;
$\T{u}_e$ indicates a generic measured exogenous input
to the system to be controlled.

The order $p$ and $q$ of the auto-regressive and exogenous portions
of the system can differ.
In detail, the order $p$ can be zero; in that case, the system
implements a \emph{finite impulse response} function.

This element is not self-starting; it assumes that both
inputs and outputs at times before the start time are zero.

The so-called ``output'' signals, indicated with $\T{y}$,
can be instances of either \kw{node\_dof} or \kw{drive\_caller} objects.
The so-called ``input'' signals, indicated with $\T{u}$,
must be instances of \kw{node\_dof} object.
This implies that instances of \kw{node\_dof} objects
need the corresponding equations to be (at least) statically defined.
In fact, the \kw{discrete control} element uses the ``output''
\kw{node\_dof} values, the $\T{y}$, to compute the corresponding
``inputs'', the $\T{u}$.
The latter are substantially added as a right-hand side
to the equations of the corresponding \kw{node\_dof} objects.
As a consequence, other elements must contribute to the left-hand side
of all the \kw{node\_dof} equations in order to make them defined.

Note that other elements may also contribute to the right-hand side
of the ``input'' \kw{node\_dof} object.
Specifically, other \kw{abstract} forces may contribute to their value.
In that case, the additional forces represent the exogenous inputs.
They are considered as part of the input used by the \kw{discrete control}
element, since the value $\T{u}_k$ to be used in the control equation
is extracted from the value of the corresponding \kw{node\_dof} objects.

Figure~\ref{fig:discctrl} illustrates the behavior of the element.
The typical suggested approach is illustrated later in an example.
\begin{figure}
\centering
\psfrag{A}{$\TT{A}$}
\psfrag{B}{$\TT{B}$}
\psfrag{f}{$\T{f}$}
\psfrag{uc}{$\T{u}_c$}
\psfrag{fe}{$\T{u}_e$}
\psfrag{uk-2}{$\T{u}_{k-2}$}
\psfrag{uk-1}{$\T{u}_{k-1}$}
\psfrag{uk}{$\T{u}_{k}$}
\psfrag{yk-2}{$\T{y}_{k-2}$}
\psfrag{yk-1}{$\T{y}_{k-1}$}
\psfrag{yk}{$\T{y}_{k}$}
\psfrag{k=1}{$\mathbb{K}=1$}
\includegraphics[width=.7\textwidth]{discctrl}
\caption{Discrete control layout.}
\label{fig:discctrl}
\end{figure}

The syntax is
\begin{verbatim}
    <electric_arglist> ::= <num_outputs> , <num_inputs> ,
        <orderA> [, fir , <orderB> ] ,
        <num_iter> ,
        <control_data> , 
        outputs ,
            (scalar_value)<output_value> 
                [ , scale , (drive_caller) scale ]
            [ , ... ] ,
        inputs ,
            (node_dof) <input_dof>
            [ , ... ]

    <output_value> ::=
        { [ node dof , ] (node_dof)<output_dof>
            | drive , (drive_caller)<output_drive> }
\end{verbatim}
The lists of the output and input dofs follows. The input {\tt
node\_dof}s do not require the \kw{orderA} and \kw {orderB} 
fields, since they are simply
used to compute the control forces, and thus identify an equation.
\kw{orderB} defaults to \kw{orderA} unless a \kw{fir} control is choosen.\\
The \kw{control\_data} has the following syntax:
\begin{verbatim}  
        <control_data> ::= <control_type> , <control_arglist>
\end{verbatim}

At present only a simple form of control is implemented. Other types
to come are system identification, both recursive and one-shot, and
adaptive control, with different models and schemes, all based on 
Generalized Predictive Control (GPC) and Deadbeat Control.
The \kw{control\_data} syntax is:
\begin{verbatim}
    <control_data> ::=
        { control , " <control_matrices_file> " |
        | identification , <identification_data> }
        | adaptive control , <adaptive_control_data> }
\end{verbatim}

\subsubsection{Control}
The file \kw{control\_matrices\_file} must contain the matrices
$ a_c $, $ b_c $ of the control in plain text (as generated by Matlab, for
instance):

\noindent
\begin{tabular}{l}
    $ a_{c1} $, \\
    \ldots,     \\
    $ a_{cp} $, \\
    $ b_{c1} $, \\
    \ldots,     \\
    $ b_{cp} $  \\
\end{tabular} \\
where $ p $ is the \kw{order} of the controller and the matrices $ a_c $
have \kw{num\_inputs} rows and \kw{num\_outputs} columns, while the
matrices $ b_c $ have \kw{num\_inputs} rows and \kw{num\_inputs} columns.

\subsubsection{Identification}
\begin{verbatim}
    <identification_data> ::=
        { arx | armax } ,
        <forgetting_factor> ,
        <persistent excitation> ,
        [file, " <output_file_name> " ]
\end{verbatim}
The forgetting factor is defined as
\begin{verbatim}
    <forgetting_factor> ::=
        [ forgettingfactor,
          { const , (scalar) d |
            dynamic,
              (integer) n1 ,
              (integer) n2 ,
              (scalar) rho ,
              (scalar) fact ,
              (scalar) kref ,
              (scalar) klim
           }
        ]    
\end{verbatim}
The default is a \kw{const} forgetting factor with $d=1$.

The \kw{persistent\_excitation} is defined as
\begin{verbatim}
    <persistent_excitation> ::=
        [ excitation , (drive caller) excitation_drive [ , ... ] ]
\end{verbatim}
where \kw{num\_inputs} \kw{excitation\_drive}s must be defined.

\subsubsection{Adaptive control}
The \kw{adaptive\_control\_data} card is
\begin{verbatim}
    <adaptive_control_data> ::=
        [ arx | armax ]
        [ , periodic , (scalar) periodic_factor ] ,
        [ , { 
               gpc ,
               (integer) prediction_advancing_horizon ,
               (integer) control_advancing_horizon ,
               (integer) prediction_receding_horizon ,
               [ prediction weights , (scalar) Wi [ , ... ] , ]
               [ control weights , (scalar) Ri [ , ... ] , ]
               (drive_caller) weight_drive
             } | { 
               deadbeat,
               (integer) prediction_advancing_horizon ,
               (integer) control_advancing_horizon
             }
        ] ,
        <forgetting_factor> ,
        <persistent_excitation>
        [ , trigger , (drive_caller) trigger_drive ]
        [ , desired output , (drive_caller) output_drive [ , ... ] ]
        [ , file , " <file_name> " ]            
\end{verbatim}
The default is \kw{arx}.

The meaning of the keywords is:
\begin{itemize}
\item the \kw{periodic\_factor} defaults to 0;

\item if the keyword \kw{prediction weights} is present,
(\kw{prediction\_advancing\_horizon} - \kw{prediction\_receding\_horizon}) 
weights \kw{Wi} must be supplied.
If the keyword \kw{control weights} is present,
\kw{control\_advancing\_horizon} weights \kw{Ri} must be supplied.
If the keywords are not defined, the corresponding weights
default to 1;

\item the \kw{desired output}
card requires \kw{num\_outputs} drives to be defined.
\end{itemize}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"u[<idx>]"} value of the \kw{idx}-th control output.
\end{enumerate}

\subsubsection{Examples}
Consider the case of a discrete controller that computes
a set of control signals $\T{u}_k$ by adding to their value
at the previous step, $\T{u}_{k-1}$, a contribution coming
from some measure $\T{y}_{k-1}$.
The control matrices are
\begin{subequations}
\begin{align}
	\TT{A}_{c1} &= \sqbr{\matr{cc}{
		a_{11} & a_{12} \\
		a_{21} & a_{22}
	}} \\
	\TT{B}_{c1} &= \sqbr{\matr{cc}{
		1 & 0 \\
		0 & 1
	}}
\end{align}
\end{subequations}
They are defined in the control data file \kw{discretecontrol.dat} as
\begin{verbatim}
    a_11 a_12
    a_21 a_22
    1.0 0.0
    0.0 1.0
\end{verbatim}
The model consists in two abstract nodes for the control input
\kw{node\_dof} objects.
They need to be grounded.
This can be formulated by using a \kw{spring support} \kw{genel}
for each abstract node, characterized by a unit spring coefficient,
such that
\begin{subequations}
\begin{align}
	1 \cdot x_{u1} = u_1 \\
	1 \cdot x_{u2} = u_2
\end{align}
\end{subequations}
Moreover, assume that the first measure, $y_1$,
comes from a \kw{node\_dof} object,
while the second one, $y_2$, comes from a \kw{drive} object.
The equation corresponding to $y_1$ must be appropriately grounded
as well, for example by means of yet another \kw{spring support}
\kw{genel}.
This is outside the scope of the present example, so it will assume
the output nodes are defined appropriately.

The model is
\begin{verbatim}
    set: integer U_1 = 1;
    set: integer U_2 = 2;
    set: integer Y_1 = 11;
    # ...
    abstract: U_1;
    abstract: U_2;
    # ...
    genel: U_1, spring support,
        U_1, abstract, algebraic,
        linear elastic, 1.;
    genel: U_2, spring support,
        U_2, abstract, algebraic,
        linear elastic, 1.;
    electric: 99, discrete control,
        2,    # number of `outputs' y
        2,    # number of `inputs' u
        1,    # order of output matrices A (same for input matrices B)
        1,    # update every iteration
        control, "discretecontrol.dat",
        outputs,
            node dof, Y_1, abstract, algebraic, scale, 1.e-3,
            drive, sine, .5, 2*pi, 1., forever, 0, scale, 1.e-3,
        inputs,
            U_1, abstract, algebraic,
            U_2, abstract, algebraic;
\end{verbatim}




\section{Force}\label{sec:EL:FORCE}
The \kw{force} element, in MBDyn, is a general means to introduce 
a right-hand side to the equations, i.e.\ an explicit contribution
to the equations.
There is a basic distinction between abstract and structural forces:
abstract forces apply to arbitrary equations, while structural forces
(and couples) are specific to structural nodes and have
a spatial characterization.
Essentially, structural forces have three components
that may depend on arbitrary parameters (usually the simulated time),
and a location in space.
Structural couples have three parameter-dependent components.
The syntax of the \kw{force} element is:
\begin{verbatim}
  <normal_arglist> ::= <force_type> , <force_arglist>
\end{verbatim}
where \kw{force\_type} can be \kw{abstract} for an abstract force, or 
\kw{absolute} or \kw{follower} for a structural force.
The latter types also apply to the \kw{couple} element,
which can be structural only.
It is discussed in this section because of its input syntax commonality 
with the structural force elements.

There is yet another type of structural force,
the \kw{external structural}, which is essentially used to provide
an easy to use interface for coupling with external software
in a loose or tight manner (the tight manner is not fully implemented yet).

\subsection{Output}
The output is discussed according to the types of forces. 
The label of the element is output first in all the cases.

\subsection{Abstract force}\label{sec:EL:FORCE:ABSTRACT}
\begin{verbatim}
    <force_type> ::= abstract 
    <force_arglist> ::= (node_dof) <dof> ,
                        (drive_caller) <force_magnitude>
\end{verbatim}
the \kw{dof} field is a normal \kw{node\_dof} but no \kw{order} is required
since the \kw{force} simply applies to the equation related to the node,
regardless of the order.

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the node\footnote{Since the \kw{abstract} force type
	can connect to \kw{node\_dof}, information provided here
	can be partial if the \kw{node\_dof} actually represents
	a component of a node with more than one degree of freedom.
	\label{footnote:EL:FORCE:ABSTRACT:OUTPUT:node_dof}}
	the force is applied to;
    \item the value of the force.
\end{itemize}

\subsection{Abstract reaction force}
\begin{verbatim}
    <force_type> ::= abstract internal
    <force_arglist> ::= (node_dof) <dof1> ,
                        (node_dof) <dof2> ,
                        (drive_caller) <force_magnitude>
\end{verbatim}
the \kw{dof1} and \kw{dof2} fields are normal \kw{node\_dof}
but no \kw{order} is required since the \kw{force} simply applies
to the equations related to the nodes, regardless of the order, with
opposite magnitudes.

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the first node\footnote{See
	footnote~\ref{footnote:EL:FORCE:ABSTRACT:OUTPUT:node_dof}.}
	the force is applied to;
    \item the value of the force applied to the first node;
    \item the label of the second node\footnote{See
	footnote~\ref{footnote:EL:FORCE:ABSTRACT:OUTPUT:node_dof}.}
	the force is applied to;
    \item the value of the force applied to the second node
	  (opposite to that applied to the first node).
\end{itemize}

\subsection{Structural force}
\label{sec:EL:FORCE:STRUCTURAL:FORCE}
\begin{verbatim}
    <force_type> ::= { absolute | follower } 
    <force_arglist> ::=
        <node_label> , 
        position, (Vec3) <relative_arm> ,
        (Vec3_tpl_drive_caller) <force_value>
\end{verbatim}
The vector \kw{relative\_arm} defines the offset with respect
to the node of the point where the force is applied.
The drive \kw{force\_value} defines the value of the force
as a function of time.

The force and the moment applied to node \kw{node\_label} are thus
\begin{itemize}
\item \kw{absolute} force element:
\begin{subequations}
\begin{align}
	\T{f} & = \mathtt{force\_value} \\
	\T{m} & = \plbr{\TT{R} \ \mathtt{relative\_arm}} \times \mathtt{force\_value} ;
\end{align}
\end{subequations}

\item \kw{follower} force element:
\begin{subequations}
\begin{align}
	\T{f} & = \TT{R} \ \mathtt{force\_value} \\
	\T{m} & = \TT{R} \plbr{\mathtt{relative\_arm} \times \mathtt{force\_value}} ;
\end{align}
\end{subequations}
\end{itemize}
$\TT{R}$ is the orientation matrix of the node \kw{node\_label}.

\paragraph{Example.} \
\begin{verbatim}
    force: 10, absolute,
        1000,
            position, .5, 0., 0.,
        1., 0., 0.,
            const, 25.;
    force: 20, follower,
        2000,
            position, null,
        component,
            const, 0.,
            ramp, 10., 0., 1., 0.,
            file, 5, 2;
\end{verbatim}

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the node the force is applied to;
    \item the three components of the force;
    \item the arm of the force, in the global frame (i.e.\ referred
          to point $ \cubr{0,0,0} $ and oriented as the global frame)
\end{itemize}

\subsection{Structural internal force}
\label{sec:EL:FORCE:STRUCTURAL:INTERNAL_FORCE}
\begin{verbatim}
    <force_type> ::= { absolute | follower } internal
    <force_arglist> ::=
        <node1_label> , 
        position, (Vec3) <relative_arm1> ,
        <node2_label> ,
        position, (Vec3) <relative_arm2> ,
        (Vec3_tpl_drive_caller) <force_value>
\end{verbatim}
The format is basically identical to the previous case,
except for the definition of the second node.

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the first node the force is applied to;
    \item the three components of the force applied to the first node;
    \item the arm of the force with respect to the first node,
	  in the global frame (i.e.\ referred to point $ \cubr{0,0,0} $
	  and oriented as the global frame).
    \item the label of the second node the force is applied to;
    \item the three components of the force applied to the second node
	  (opposite to that applied to the first node);
    \item the arm of the force with respect to the second node,
	  in the global frame (i.e.\ referred to point $ \cubr{0,0,0} $
	  and oriented as the global frame).
\end{itemize}

\paragraph{Example.} \
\begin{verbatim}
    # constant structural force
    force: 1, absolute,
        10, position, null,
        0., 0., 1.,
            const, 100.;

    # constant structural internal force
    force: 1, absolute internal,
        10, position, null,
        20, position, null,
        0.,0.,1.,
            const, 100.;
\end{verbatim}


\subsection{Structural couple}
\label{sec:EL:FORCE:STRUCTURAL:COUPLE}
The structural couple is defined by using \kw{couple} as \kw{elem\_type}.
\begin{verbatim}
    <elem_type> ::= couple
    <force_type> ::= { absolute | follower } 
    <force_arglist> ::=
        <node_label> ,
        [ position, (Vec3) <relative_arm> , ]
        (Vec3_tpl_drive_caller) <couple_value>
\end{verbatim}
The vector \kw{relative\_arm} defines the offset with respect
to the node of the point where the couple is applied.
It is not used in the analysis, but it can be optionally provided
for future reference (e.g.\ for the visualization of the couple).
The drive \kw{couple\_value} defines the value of the couple
as a function of time.

The moment applied to node \kw{node\_label} is thus
\begin{itemize}
\item \kw{absolute} couple element:
\begin{align}
	\T{m} & = \mathtt{couple\_value}
\end{align}

\item \kw{follower} couple element:
\begin{align}
	\T{m} & = \TT{R} \ \mathtt{couple\_value}
\end{align}
\end{itemize}
$\TT{R}$ is the orientation matrix of the node \kw{node\_label}.

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the node the couple is applied to;
    \item the three components of the couple.
\end{itemize}

\subsection{Structural internal couple}
\label{sec:EL:FORCE:STRUCTURAL:INTERNAL_COUPLE}
The structural couple is defined by using \kw{couple} as \kw{elem\_type}.
\begin{verbatim}
    <elem_type> ::= couple
    <force_type> ::= { absolute | follower } internal
    <force_arglist> ::=
        <node1_label> ,
        [ position, (Vec3) <relative_arm1> , ]
        <node2_label> ,
        [ position, (Vec3) <relative_arm2> , ]
        (Vec3_tpl_drive_caller) <couple_value>
\end{verbatim}
The format is basically identical to the previous case,
except for the definition of the second node.

\subsubsection{Output}
The format is:
\begin{itemize}
    \item the label of the element;
    \item the label of the first node the couple is applied to;
    \item the three components of the couple applied to the first node;
    \item the label of the second node the couple is applied to;
    \item the three components of the couple applied to the second node
	  (opposite to that applied to the first node);
\end{itemize}

\bigskip
Note: by using a \kw{dof}, a \kw{node} or an \kw{element} drive,
a simple feedback control can be easily implemented.
Note however that the dependence of a force on some internal state
does not result in adding the corresponding contribution 
to the Jacobian matrix: the force remains explicit.
Their improper use may result in missing convergence.

\subsection{Modal}
\label{sec:EL:FORCE:MODAL}
This element allows to define a set of generalized forces
acting on the equations related to the generalized variables
of a \htmlref{\kw{modal}}{sec:EL:STRUCT:JOINT:MODAL} joint element.
\begin{verbatim}
    <force_type> ::= modal
    <force_arglist> ::=
        <modal_label> ,
            [ list , <number_of_modes> , <mode1> [ , ... ] , ]
        (DriveCaller)<force1>
            [ , resultant , (Vec3)<f> , (Vec3)<m> ]
        [ , ... ]
\end{verbatim}
It requires the label of the modal joint it is connected to,
\kw{modal\_label}.
If the optional keyword \kw{list} is given, the number of excited modes
\kw{number\_of\_modes} and the list of the excited modes is expected,
otherwise it assumes all modes of the \kw{modal\_label} modal joint
will be excited.

A list of
\hyperref{\kw{drive callers}}{\kw{drive callers} (see Section~}{)}{sec:DRIVE}.
that provide the excitation value for each mode is required last.
If the keyword \kw{list} was given, the drive callers
must be \kw{number\_of\_modes}, otherwise they must be as many
as the modes of the excited modal joint element.

If the \kw{modal} joint element is connected to a modal node
instead of being clamped to the ground, the optional keyword \kw{resultant}
is allowed for each mode drive caller.
The keyword \kw{resultant} is followed by two $3\times 1$ vectors
containing the resultant force and moment associated to the related mode.

If the keyword \kw{list} was given, the mode numbers must be
the actual mode numbers defined in the FEM model.

\paragraph{Example.} \
In this example, all the modes available in the FEM data file 
are used by the modal joint, and all the modes are excited
by the modal force
\begin{verbatim}
    joint: MODAL_JOINT, modal, MODAL_NODE,
        5,             # number of modes
        from file,
        "model.fem",
        0;             # no interface nodes
    force: MODAL_FORCE, modal, MODAL_JOINT,
        const, 5.,
        const, 10.,
        const, 1.,
        const, -1.,
        const, -3.;
\end{verbatim}

In this example, only three modes of the same FEM data file
of the previous example are used by the modal joint;
only the last mode is excited by the modal force
\begin{verbatim}
    joint: MODAL_JOINT, modal, MODAL_NODE,
        3,             # number of modes
            list, 1, 3, 5,
        from file,
        "model.fem",
        0;             # no interface nodes
    force: MODAL_FORCE, modal, MODAL_JOINT,
        list, 1,       # only one mode is excited
            5,         # it is mode #5 in "model.fem"
        const, -3.;
\end{verbatim}
Note that the mode is indicated by its number in the FEM data file.




\subsection{External forces}
External forces are elements that allow to communicate
with an external software that computes forces
based on information on the kinematics of the model.

Different communication schemes are supported.
By default, communication occurs via files.
Currently supported communication schemes are
\begin{verbatim}
    <external_force_communicator> ::= { <file> | <edge> | <socket> }

    <file> ::=
        " <input_file_name> " [ , unlink ] ,
        " <output_file_name> " [ , no clobber ]
        [ <common_parameters> ]

    <edge> ::= edge ,
        " <flag_file_name> " ,
        " <data_file_name> "
        [ <common_parameters> ]

    <socket> ::= socket ,
        [ create , { yes | no } , ]
        { path , <path> | port , <port> [ , host , <host> ] }

    <common_parameters> ::=
        [ , sleep time , <sleep_time> ]
        [ , precision , { default | <digits> } ]
        [ , coupling , { loose | tight | <coupling_steps> } ]
        [ , send after predict , { yes | no } ]
\end{verbatim}

\subsubsection{File communicator}
\kw{input\_file\_name} is the name of the file MBDyn expects to find
with the values of the force.
The content depends on the purpose it is used for.
The optional keyword \kw{unlink} indicates that MBDyn is supposed
to unlink the file as soon as it is ready to read another one,
as a primitive form of inter-process communication.

\kw{output\_file\_name} is the name of the file MBDyn creates
each time it intends to communicate the kinematics of the model
to the external software.
The contents depend on the purpose it is used for.
The option \kw{no clobber} indicates that MBDyn is supposed to wait
until the external software removed the file before generating a new one,
as a primitive form of inter-process communication.



\subsubsection{EDGE communicator}
This communicator has been developed in cooperation with Luca Cavagna,
to support communication with FOI's EDGE.

The file \kw{flag\_file\_name} is used to synchronize the communication
between the processes.
The same file is truncated and reused by both processes.
The syntax of the file changed since EDGE 5.1; this change is reflected
from MBDyn 1.3.16 on.
The file contains a two lines header, followed by a line containing a single digit.
The header is
\begin{verbatim}
    UPDATE,N,0,0,1
    FLAG,I,1,1,0
\end{verbatim}
The digit indicates the command.  Its meaning is:
\begin{itemize}
\item[0 :] external software is initializing; MBDyn must wait;
\item[1 :] external software is busy; MBDyn must wait;
\item[2 :] external software is ready to read kinematics; MBDyn can start reading forces and writing kinematics;
\item[3 :] MBDyn finished writing kinematics; external software can start reading kinematics and writing forces
	(written by MBDyn when data file is ready);
\item[4 :] external software converged; MBDyn should go to convergence, advance to the next time step,
and start writing new step kinematics;
\item[5 :] external software decided to quit; MBDyn should stop communicating.
\end{itemize}
So far, there are no provisions for re-executing a time step,
nor for communicating either the time or the time step,
so adaptive time stepping cannot be implemented.

\kw{data\_file\_name} is the name of the file used to actually send data
between the two processes.
Its contents depend on the purpose it is used for,
as described in the subsequent sections.



\subsubsection{Socket communicator}
The optional parameter \kw{create}, when set to \kw{yes}, indicates
that MBDyn will create the socket, and the peer will have to connect to it.
Otherwise, when set to \kw{no}, it indicates that MBDyn will try to connect
to an already existing socket created by the peer.
Connecting to a peer is attempted while reading the input file.
Sockets are created when the input file has been read.
MBDyn waits until all sockets have been connected to by peers
before the simulation is started.

MBDyn supports local (unix) sockets, defined using the \kw{path} parameter,
and inet sockets, defined using the \kw{port} parameter.
When \kw{create} is set to \kw{yes}, the optional keyword \kw{host}
allows to define what interface of the host MBDyn will listen on.
When \kw{create} is set to \kw{no}, the optional keyword \kw{host}
indicates what host to connect to.
It defaults to \kw{localhost}.




\subsubsection{Common parameters}
The optional parameter \kw{sleep\_time} determines how long MBDyn
is supposed to sleep while waiting for a new input file to appear
or for an old output file to disappear.

The optional parameter \kw{precision} determines the precision
used in writing the output file; the default is 16 digits.

The optional parameter \kw{coupling} determines whether the coupling
will be \kw{loose} (communicate each time step, the default) or
\kw{tight} (communicate each iteration); otherwise, if \kw{coupling\_steps}
is provided, the communication occurs every \kw{coupling\_steps}.

The optional parameter \kw{send after predict} allows to indicate
whether MBDyn must send the predicted motion or not when playing
a tight coupling loop.

\paragraph{Loose Coupling.} \
When the coupling is \kw{loose}, the communication pattern is:
\begin{enumerate}
\item MBDyn receives a set of forces sent by the external peer
	the first time the residual is assembled within time step $k$;
	the external peer generated that set of forces
	based on the kinematics at step $k-1$;

\item MBDyn sends a set of kinematic parameters related to step $k$
	after convergence.
\end{enumerate}
As a consequence, MBDyn solves the kinematics at the current time step, $k$,
using forces evaluated for the kinematics at the previous time step, $k-1$.
Something like
\begin{align}
	\T{f}\plbr{\T{y}_k, \dot{\T{y}}_k, \T{u}_{k - 1}}
	&=
	\T{0}
	.
\end{align}

\paragraph{Tight Coupling.} \
When the coupling is \kw{tight}, the communication pattern is:
\begin{enumerate}
\item MBDyn sends the predicted kinematics for step $k$
	during the ``after predict'' phase
	(unless \kw{send after predict} is set to \kw{no});

\item MBDyn receives a set of forces sent by the external peer
	each time the residual is assembled; those forces are computed
	based on the kinematics at iteration $j$

\item as soon as, while reading the forces, MBDyn is informed that
	the external peer converged, it continues iterating until
	convergence using the last set of forces it read.

%\item if coupling only occurs every some iterations, MBDyn sends
%	a set of kinematic parameters after convergence.
\end{enumerate}
As a consequence, MBDyn solves the kinematics at the current time step, $k$,
at iteration $j$,
using forces evaluated for the kinematics at the same time step, $k$,
but at iteration $j-1$.
Something like
\begin{align}
	\T{f}\plbr{\T{y}_k^{(j)}, \dot{\T{y}}_k^{(j)}, \T{u}_k^{(j-1)}}
	&=
	\T{0}
	.
\end{align}




\subsection{External structural}
\label{sec:EL:FORCE:EXTERNAL:STRUCTURAL}
This element allows to communicate with an external software that computes
forces applied to a pool of nodes and may depend on the kinematics of those
nodes.
Communication occurs by means of the communicators illustrated earlier.
\begin{verbatim}
    <force_type> ::= external structural

    <force_arglist> ::= <external_force_communicator> ,
        [ reference node , <ref_node_label> , ]
        [ labels , { yes | no } , ]
            [ sorted , { yes | no } ]
        [ orientation ,
            { none | orientation matrix | orientation vector | euler 123 } , ]
        [ accelerations , { yes | no } ]
        [ use reference node forces , { yes | no } ,
            [ rotate reference node forces , { yes | no } ] ]
        <num_nodes> ,
            <node_label> [ , offset , (Vec3) <offset> ]
            [ , ... ]
\end{verbatim}
\begin{itemize}
\item \kw{use reference node forces} only meaningful
when \kw{reference node} is used.
It assumes the external solver is sending the forces and moments
related to the reference node.
They correspond to the rigid-body forces and moments applied
to the whole system.
As such, the forces and moments applied to each node
are removed accordingly.
If it is set to \kw{no}, reference node forces and moments
will be ignored.

\item The orientation style \kw{none} implies that only positions, velocities 
and accelerations will be output (the latter only if \kw{accelerations}
is set to \kw{yes}).
\end{itemize}


\subsubsection{File communicator}
The forces are read from the input file in textual form,
each line formatted as follows:
\begin{itemize}
\item a label (if \kw{labels} is set to \kw{yes});
\item three components of force in the global frame;
\item three components of moment in the global frame,
	referred to the node as the pole.
\end{itemize}
The label indicates what node the force and the moment apply to; 
each force is applied in a point that may be optionally offset 
from the corresponding node location according to \kw{offset}.
If optional keyword \kw{sorted} is set to \kw{no}, the forces might be
read in arbitrary order, so they need to be recognized by the label.
The option \kw{sorted} is only meaningful when \kw{labels} is set to \kw{yes}.

The kinematics are written to the output file in textual form,
each line formatted as follows:
\begin{itemize}
\item a label (if \kw{labels} is set to \kw{yes});
\item the position in the global frame;
\item the orientation of the node with respect to the global frame:
\begin{itemize}
	\item if \kw{orientation} is set to \kw{orientation matrix},
	the orientation matrix in the global frame, row-oriented:
	$R_{11}$, $R_{12}$, $R_{13}$, $R_{21}$, \ldots, $R_{32}$, $R_{33}$;
	\item if \kw{orientation} is set to \kw{orientation vector},
	the orientation vector's components;
	\item if \kw{orientation} is set to \kw{euler 123},
	the three Euler anlgles, in degrees, according to the 1,2,3
	convention;
\end{itemize}
\item the velocity with respect to the global frame;
\item the angular velocity with respect to the global frame.
\end{itemize}
If the optional keyword \kw{accelerations} is set to \kw{yes},
at the end of each line the following optional fields will appear:
\begin{itemize}
\item the acceleration with respect to the global frame;
\item the angular acceleration with respect to the global frame.
\end{itemize}
The label indicates what node the kinematics is related to;
the position and the velocity refer to a point that may be optionally
offset from the node location according to \kw{offset}.

If a \kw{reference node} was given, the first record is related
to the reference node itself.
The following records contain forces and moments in the reference frame
of the reference node.



\subsubsection{EDGE communicator}
TBD




\subsubsection{Socket communicator}
TBD




\paragraph{Example.} \
The following defines an \kw{external structural} force
with the file communicator
\begin{verbatim}
    set: integer FORCE_LABEL = 1000;
    set: integer NODE_1 = 10;
    set: integer NODE_2 = 20;
    force: FORCE_LABEL, external structural,
        "IN.dat", unlink,
        "OUT.dat", no clobber,
        sleep time, 10,
        precision, 12,
        coupling, loose,
        2, # number of nodes
            NODE_1,
            NODE_2, offset, 0.,0.,.5;
\end{verbatim}

\subsubsection{Output}
An external modal element writes one line for each connected node
at each time step in the \kw{.frc} file.
Each line contains:
\begin{itemize}
\item in column 1 the label of the element and that of the corresponding node;
	the format of this field is \kw{element\_label@node\_label};
\item in columns 2--4 the three components of the force;
\item in columns 5--7 the three components of the moment.
\end{itemize}
If a reference node is defined, a special line is output for the reference node,
containing:
\begin{itemize}
\item in column 1 the label of the element and that of the corresponding node;
	the format of this field is \kw{element\_label\#node\_label};
\item in columns 2--4 the three components of the force,
	in the global reference frame;
\item in columns 5--7 the three components of the moment
	with respect to the reference node,
	in the global reference frame;
\item in columns 8--10 the three components of the force,
	as received from the peer;
\item in columns 11--13 the three components of the moment,
	as received from the peer.
\end{itemize}




\subsection{External structural mapping}
\label{sec:EL:FORCE:EXTERNAL:STRUCTURAL_MAPPING}
This element allows to communicate with an external software that computes
forces applied to a pool of nodes and may depend on the kinematics of those
nodes through a linear mapping.
Communication occurs by means of the communicators illustrated earlier.
%\begin{verbatim}
\begin{Verbatim}[commandchars=\\\{\}]
    \bnt{force_type} ::= \kw{external structural mapping}

    \bnt{force_arglist} ::= \bnt{external_force_communicator} ,
        [ \kw{reference node} , \bnt{ref_node_label} , ]
        [ \kw{labels} , { \kw{yes} | \kw{no} } , ]
        [ \kw{orientation} ,
            { \kw{none} | \kw{orientation matrix} | \kw{orientation vector} | \kw{euler 123} } , ]
        [ \kw{accelerations} , { \kw{yes} | \kw{no} } ]
        [ \kw{use reference node forces} , { \kw{yes} | \kw{no} } ,
            [ \kw{rotate reference node forces} , { \kw{yes} | \kw{no} } ] ]
        \bnt{num_points} ,
            \bnt{node_label} , \kw{offset} [ , \bnt{point_label} ] , \ty{(Vec3)} \bnt{offset}
                [ , ... ]
        [ , \kw{echo} , " \bnt{echo_file_name} " [ , \kw{precision} , \bnt{digits} ] [ , \kw{stop} ] ]
        [ , \kw{mapped points number} , \bnt{mapped_points} ,
            { \kw{full} | \kw{sparse} } \kw{mapping file} , " \bnt{mapping_file_name} "
                [ , \kw{threshold} , \bnt{threshold} ]
            [ , \{ \kw{mapped labels file} , " \bnt{mapped_labels_file_name} "
                | \bnt{mapped_label} [ , ... ] \} ] ]
\end{Verbatim}
%\end{verbatim}
A set of \nt{num\_points} points is generated first,
by computing the kinematics of the points originating
from the rigid-body motion of the structural nodes \nt{node\_label}
according to the specified offset.
Multiple \kw{offset} blocks can appear for each \nt{node\_label}.

The \kw{echo} keyword causes the positions of those points
to be written in a file named \nt{echo\_file\_name}.
If the keyword \kw{stop} is present, the simulation ends here.
This is useful to generate the bulk data that is needed to compute
the linear mapping matrix.

When the \kw{reference node} keyword is present, the kinematics
of the points is formulated in the reference frame of node
\nt{ref\_node\_label}.
The forces are expected in the same reference frame.
In this case, if \kw{use reference node forces} is set to \kw{yes},
the force and moment related to node \nt{ref\_node\_label} 
returned by the external solver are used;
if \kw{rotate reference node forces} is set to \kw{yes},
they are first rotated in the global reference frame.

When the \kw{mapped points number} keyword is present,
a mapping matrix is read from the file named \nt{mapping\_file\_name}.
The matrix must be
$(3 \times \nt{mapped\_points}) \times (3 \times \nt{num\_points})$.
Otherwise, the element behaves as if the mapping were the identity matrix.
See the \htmlref{\kw{modal}}{sec:EL:FORCE:EXTERNAL:MODAL_MAPPING}
variant for a description of the mapping file format.

The labels of the original points, indicated as \nt{point\_label},
and the labels of the mapped points, either contained
in the \nt{mapped\_labels\_file\_name},
or directly listed as \nt{mapped\_label}, must be provided
when \kw{labels} is set to \kw{yes}.

\paragraph{Example.} \
\begin{verbatim}
    force: 100, external structural mapping,
        socket,
            create, yes,
            path, "/tmp/mbdyn.sock",
            no signal,
        coupling, tight,
        reference node, 0,
        points number, 9,
            10,
                offset, null,       # centered at node
                offset, 0., 1., 0., # y offset
                offset, 0., 0., 1., # z offset
            20,
                offset, null,       # ...
                offset, 0., 1., 0.,
                offset, 0., 0., 1.,
            30,
                offset, null,
                offset, 0., 1., 0.,
                offset, 0., 0., 1.,
        # echo, "points.dat", stop,
        mapped points number, 27,
        sparse mapping file, "mapping.dat";
\end{verbatim}

\subsubsection{File communicator}
TBD

\subsubsection{EDGE communicator}
TBD

\subsubsection{Socket communicator}
TBD

The format of the socket communicator is relatively simple;
however, implementors may exploit the peer library \kw{libmbc},
whose API is defined in \kw{mbc.h}.
A python wrapper is also available.

\subsubsection{Output}
TBD



\subsection{External modal}
\label{sec:EL:FORCE:EXTERNAL:MODAL}
This element allows to communicate with an external software that computes
forces applied to a 
\htmlref{\kw{modal}}{sec:EL:STRUCT:JOINT:MODAL} joint element,
and may depend on the values of the corresponding generalized variables.
Communication occurs by means of the communicators illustrated earlier.
\begin{verbatim}
    <force_type> ::= external modal

    <force_arglist> ::= <external_force_communicator> ,
        <modal_label>
        [ , accelerations ]
        [ , type , { rigid | modal | all } ]
\end{verbatim}
\kw{modal\_label} is the label of the 
\htmlref{\kw{modal}}{sec:EL:STRUCT:JOINT:MODAL} joint element
the force element is connected to.

If the optional keyword \kw{accelerations} is present,
the output will also contain the modal accelerations.

If the optional keyword \kw{type} is present,
the alternative keywords \kw{rigid}, \kw{modal} or \kw{all}
inform MBDyn about whether only the rigid or the modal portions
of the force are expected.
The default is \kw{all}, but some communicators might require
a specific value.
If \kw{rigid} or \kw{all} are used, the \kw{modal} joint element
must be connected to a \kw{modal} node.
The number of modes of the modal force must match that of the active modes
in the \kw{modal} joint element.



\subsubsection{File communicator}
If \kw{type} is \kw{rigid} or \kw{all}, the first line of the input file
must contain:
\begin{itemize}
\item the label of the \kw{modal} node the \kw{modal} joint element
	is connected to, or 0 if the element is grounded;
\item three components of force in the \kw{modal} node reference frame;
\item three components of moment in the \kw{modal} node reference frame.
\end{itemize}
If the \kw{modal} joint element is grounded, the force and moment
are ignored.
If \kw{type} is \kw{modal} or \kw{all},
each of the following lines contains the value of the generalized force
for the respective mode.

The output file file is written in textual form.
If \kw{type} is \kw{rigid} or \kw{all}, the first line contains:
\begin{itemize}
\item the label of the \kw{modal} node the \kw{modal} joint element
	is connected to, or 0 if the element is grounded;
\item the position in the global frame;
\item the orientation matrix in the global frame;
\item the velocity with respect to the global frame;
\item the angular velocity with respect to the global frame.
\end{itemize}
If the optional keyword \kw{accelerations} is present,
at the end of each line the following optional fields will appear:
\begin{itemize}
\item the acceleration with respect to the global frame;
\item the angular acceleration with respect to the global frame.
\end{itemize}
If the \kw{modal} joint element is grounded, all the data corresponds
to that of the origin of the global reference frame.
If \kw{type} is \kw{modal} or \kw{all}, each of the following lines contains,
for each mode:
\begin{itemize}
\item the value of the generalized variable;
\item the value of the first derivative of the generalized variable.
\end{itemize}
If the optional keyword \kw{accelerations} is present,
at the end of each line the following optional field will appear:
\begin{itemize}
\item the value of the second derivative of the generalized variable.
\end{itemize}



\subsubsection{EDGE communicator}
When the \kw{edge} communicator is used,
the \kw{accelerations} keyword is ignored.
\kw{type} must be either \kw{rigid} or \kw{modal}.
If both need to be used, two \kw{external modal} forces must be instantiated:
one with \kw{type} set to \kw{rigid}
and the other with \kw{type} set to \kw{modal}.

\paragraph{Rigid.} \
When \kw{type} is \kw{rigid}, the data file written by the external software
is expected to contain:
\begin{verbatim}
* this is a comment
body_forces,R,1,6,0
<fx> <fy> <fz> <mx> <my> <mz>
\end{verbatim}
where \kw{fx}, \kw{fy}, \kw{fz}, \kw{mx}, \kw{my}, \kw{mz}
respectively are the force and moment components
oriented according to the global reference frame.
The moments are referred to the point that represents the origin
of the FE model reference frame, or to either of
the \kw{origin position} or the \kw{origin node}, if defined.

The data file written by MBDyn contains:
\begin{verbatim}
* this is a comment
body_dynamics,N,0,0,3
* Body linear velocity in body axes
VRELV,R,1,3,0
<vx> <vy> <vz>
* Body angular velocity in body axes
VRELM,R,1,3,0
<omegax> <omegay> <omegaz>
* Body reference frame cosines (listed by columns)
OMGMAN,R,3,3,0
<R11> <R21> <R31>
<R12> <R22> <R32>
<R13> <R23> <R33>
\end{verbatim}
where:
\begin{itemize}
\item \kw{vx}, \kw{vy}, \kw{vz} are the components of the velocity
	of the rigid body, in body axes;
\item \kw{omegax}, \kw{omegay}, \kw{omegaz} are the components
	of the angular velocity of the rigid body, in body axes;
\item \kw{R11}, \kw{R12}, \kw{R13}, \kw{R21}, \kw{R22}, \kw{R23},
	\kw{R31}, \kw{R32}, \kw{R33} are the components
	of the orientation matrix.
\end{itemize}

\paragraph{Modal.} \
When \kw{type} is \kw{modal}, the data file written by the external software
is expected to contain:
\begin{verbatim}
* this is a comment
modal_force_flow,R,<n>,1,0
<f1> ... <fn>
\end{verbatim}
where \kw{n} is the number of modes (must match the number of active modes
in the \kw{modal} joint element), while \kw{f1} to \kw{fn} are the amplitudes
of the modal forces.

The data file written by MBDyn contains:
\begin{verbatim}
* this is a comment
modal_state,N,0,0,2
modal_coordinate,R,1,<n>,0
<q1> ... <qn>
modal_velocity,R,1,<n>,0
<qp1> ... <qpn>
\end{verbatim}
where:
\begin{itemize}
\item \kw{n} is again the number of modes;
\item \kw{q1} to \kw{qn} are the amplitudes of the modal coordinates;
\item \kw{qp1} to \kw{qpn} are the amplitudes of the derivatives
	of the modal coordinates.
\end{itemize}

Each field can be separated by an arbitrary amount of whitespace,
and by at most one ``comma'' (``,'').
Although specifically developed for ease of interfacing with EDGE,
this format is open, and thus can be implemented by other software
in order to easily couple with MBDyn.



\subsubsection{Socket communicator}
TBD



\subsubsection{Output}
An external modal element writes multiple lines at each time step
in the \kw{.frc} file.

If \kw{type} is \kw{ridig} or \kw{all}, the line contains:
\begin{itemize}
\item in column 1 the label of the element and that of the corresponding node;
	the format of this field is \kw{element\_label\#node\_label};
\item in columns 2--4 the three components of the force;
\item in columns 5--7 the three components of the moment.
\end{itemize}
If \kw{type} is \kw{modal} or \kw{all}, each line contains:
\begin{itemize}
\item in column 1 the label of the element and the corresponding mode;
	the format of this field is \kw{element\_label.mode\_number};
\item in column 2 the amplitude of the corresponding modal force.
\end{itemize}



\subsection{External modal mapping}
\label{sec:EL:FORCE:EXTERNAL:MODAL_MAPPING}
This element allows to communicate with an external software that computes
forces applied to a set of structural nodes,
and may depend on the values of the corresponding variables.
Modal forces are actually computed, based on the value of modal variables.
The element thus projects the motion of the set of structural nodes
in the space of a set of modes before communicating it to the peer.
Similarly, it receives generalized forces that are projected back
in the space of the structural nodes before assembly.
Communication occurs by means of the communicators illustrated earlier
for the \kw{external modal} case.
\begin{verbatim}
    <force_type> ::= external modal mapping

    <force_arglist> ::= <external_force_communicator> ,
    [ reference node , <ref_node_label> , ]
    [ use rigid body forces , { yes | no } ,
        [ rotate rigid body forces , { yes | no } , ] ]
    [ accelerations , { yes | no } , ]
    [ type , { rigid | modal | all } , ]
    nodes number , <num_nodes> ,
        <node1_label> [ , ... ] ,
    modes number , <num_modes> ,
    { full | sparse } mapping file , " <mapping_file_name> "
        [ , threshold , <threshold> ]
\end{verbatim}
\kw{ref\_node\_label} is the label of the reference node
if the modes express the motion relative to a specific node.

The mapping file contains the matrix that maps the nodal and modal
displacements, velocities and forces.
When \kw{full mapping file} is used, a file containing
$\kw{num\_modes} \times (6\times\kw{num\_nodes}$) coefficients is expected.
When \kw{sparse mapping file} is used, a file containing
\kw{row}, \kw{col}, \kw{value} triplets is expected,
with $1\le\kw{row}\le\kw{num\_modes}$
and $1\le\kw{col}\le6\times\kw{num\_nodes}$.
Both files may start with an arbitrary number of lines beginning
with a hash mark (`\kw{\#}').
They are treated as comments and ignored.
If a \kw{threshold} is given, only elements whose absolute value
is larger than threshold are retained.
The value of \kw{threshold} defaults to 0.
The mapping matrix is internally stored and handled as sparse,
regardless of the file format.

If the optional keyword \kw{accelerations} is present,
the output will also contain the modal accelerations.

If the optional keyword \kw{type} is present,
the alternative keywords \kw{rigid}, \kw{modal} or \kw{all}
inform MBDyn about whether only the rigid or the modal portions
of the force are expected.
The default is \kw{all}, but some communicators might require
a specific value.
If \kw{rigid} or \kw{all} are used, the \kw{reference node} must be defined.



\subsubsection{File communicator}
Same as \kw{external modal}.

\subsubsection{EDGE communicator}
Same as \kw{external modal}.

\subsubsection{Socket communicator}
Same as \kw{external modal}.




\subsubsection{Output}
An external modal mapping element writes multiple lines at each time step
in the \kw{.frc} file.

If \kw{type} is \kw{ridig} or \kw{all}, the line contains:
\begin{itemize}
\item in column 1 the label of the element and that of the corresponding node;
	the format of this field is \kw{element\_label\#node\_label};
\item in columns 2--4 the three components of the force,
	in the global reference frame;
\item in columns 5--7 the three components of the moment
	with respect to the reference node,
	in the global reference frame;
\item in columns 8--10 the three components of the force,
	as received from the peer;
\item in columns 11--13 the three components of the moment,
	as received from the peer.
\end{itemize}
If \kw{type} is \kw{modal} or \kw{all}, two types of output are generated:
\begin{itemize}
\item a line for each node participating in the mapping, containing:
\begin{itemize}
\item in column 1 the label of the element and the corresponding node;
	the format of this field is \kw{element\_label\#node\_number};
\item in columns 2--4 the three components of the corresponding nodal force,
	in the global reference frame;
\item in columns 5--7 the three components of the corresponding nodal moment,
	in the global reference frame;
\item in columns 8--10 the three components of the nodal displacement,
	either in the global reference frame, or in that of the reference node,
	if any;
\item in columns 11--13 the three components of the nodal orientation,
	either in the global reference frame, or in that of the reference node,
	if any;
\item in columns 14--16 the three components of the nodal velocity,
	either in the global reference frame, or in that of the reference node,
	if any;
\item in columns 17--19 the three components of the nodal angular velocity,
	either in the global reference frame, or in that of the reference node,
	if any.
\end{itemize}

\item a line for each mode the motion is mapped to, containing:
\begin{itemize}
\item in column 1 the label of the element and the corresponding mode;
	the format of this field is \kw{element\_label.mode\_number};
\item in column 2 the amplitude of the corresponding modal force;
\item in column 3 the amplitude of the corresponding modal variable;
\item in column 4 the amplitude of the corresponding modal variable derivative.
\end{itemize}
\end{itemize}





\section{Genel Element}
\label{sec:EL:GENEL}
\textsc{Genel} is the compact form for \textsc{Gen}eral \textsc{el}ement.
Those elements that cannot in general be classified in a precise way, 
or are just under development and thus are not collected in a class 
of their own until their configuration is stabilized, usually are
classified as \textsc{Genel}.
The syntax of the \textsc{Genel} elements is:
\begin{verbatim}
    <normal_arglist> ::= <genel_type> , <genel_arglist>
\end{verbatim}

\noindent
The output goes in a file with extension \kw{.gen}; only few elements
actually generate output.

\noindent
At present, the \textsc{Genel} class contains very basic general elements
and some elements specifically developed fo rotorcraft analysis.
The latter could be moved to a more specific class in future releases.

\subsection{General Purpose Elements}
   
\subsubsection{Clamp}
\label{sec:EL:GENEL:CLAMP}
\begin{verbatim}
    <genel_type> ::= clamp
    <genel_arglist> ::= (node_dof) <clamped_node> ,
                        (drive_caller) <imposed_value>
\end{verbatim}
This element simply forces one arbitrary degree of freedom to assume a value
depending on the drive.

\paragraph{Output}
The format is:
\begin{itemize}
    \item the label of the element
    \item the value of the reaction unknown
\end{itemize}
  
\subsubsection{Distance}
\label{sec:EL:GENEL:DISTANCE}
\begin{verbatim}
    <genel_type> ::= distance
    <genel_arglist> ::= (node_dof) <node_1> ,
                        (node_dof) <node_2> ,
                        (drive_caller) <imposed_distance>
\end{verbatim}
This element forces the difference between two arbitrary degrees of freedom
to assume the value dictated by the driver.

\paragraph{Output}
The format is:
\begin{itemize}
    \item the label of the element
    \item the value of the reaction unknown
\end{itemize}
  
\subsubsection{Spring}
\label{sec:EL:GENEL:SPRING}
\begin{verbatim}
    <genel_type> ::= spring
    <genel_arglist> ::= (node_dof) <node_1> ,
                        (node_dof) <node_2> ,
                        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
{\em 
    Note: the constitutive law must be \kw{elastic}, but the \kw{distance}
    genel can apply to arbitrary order degrees of freedom, even between degrees 
    of freedom of different order.
}

\subsubsection{Spring support}
\label{sec:EL:GENEL:SPRING-SUPPORT}
\begin{verbatim}
    <genel_type> ::= spring support
    <genel_arglist> ::= (node_dof) <node> ,                      
                        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
{\em
    Note: the \kw{spring support} must use the \kw{algebraic} value of a 
    \kw{differential} node, but it can use an arbitrary constitutive law,
    i.e.\ an elastic constitutive law for a spring, or a viscous
    constitutive law for a damper, and so on.
}

\subsubsection{Cross spring support}
\label{sec:EL:GENEL:CROSS-SPRING-SUPPORT}
\begin{verbatim}
    <genel_type> ::= cross spring support
    <genel_arglist> ::= (node_dof) <row_node> ,                      
                        (node_dof) <col_node> ,                      
                        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
It writes a term depending on the \kw{col\_node} degree of freedom in an
arbitrary manner (given by the \kw{const\_law}) to the 
\kw{row\_node} equation. \\
{\em
    Note: the \kw{cross spring support} must use the \kw{algebraic} value
    of a \kw{differential} node, but can use an arbitrary constitutive law,
    i.e.\ an elastic constitutive law for a spring, or a viscous
    constitutive law for a damper, and so on.
}

\subsubsection{Mass}
\label{sec:EL:GENEL:MASS}
\begin{verbatim}
    <genel_type> ::= mass
    <genel_arglist> ::= (node_dof) <node> ,                     
                        (drive_caller) <mass>
\end{verbatim}
{\em
    Note: the mass must use the \kw{algebraic} value of a {\tt
    differential} node. The derivative of the \kw{differential} value of
    the dof is differentiated in a state-space sense, and an inertial driven
    term is applied to the equation related to the dof:
    \begin{eqnarray*}
        m\dot{u} + \ldots & = & f \\
	u - \dot{x} & = & 0
    \end{eqnarray*}
}

\subsubsection{Scalar filter}
\label{sec:EL:GENEL:SCALAR-FILTER}
\begin{verbatim}
    <genel_type> ::= scalar filter
    <genel_arglist> ::=
        (node_dof) <output_node> ,
        { [ node dof , ] (node_dof) <input_node>
            | drive , (drive_caller) <input_value> } ,
        [ canonical form , { controllable | observable } , ]
        <output_order> [ , <output_coef_list> ] ,
        <input_order> , <input_coef_list>
        [ , gain , <gain> ]
        [ , balance , { yes | no } ]
\end{verbatim}
This element models a scalar filter of the form
\begin{displaymath}
    A\plbr{s}y = B\plbr{s}u
\end{displaymath}
where $ A $, $ B $ are polynomials of arbitrary order, namely
\begin{displaymath}
	y\plbr{s} = \frac{
		b_0 s^{n_n}
		+ b_1 s^{n_n-1}
		+ \ldots
		+ b_{n_n}
	}{
		a_0 s^{n_d}
		+ a_1 s^{n_d-1}
		+ \ldots
		+ a_{n_d}
	} u\plbr{s}
\end{displaymath}
The filter must be proper, namely the \kw{output\_order} $n_d$
must be greater than or at most equal to the \kw{input\_order}, $n_n$.
The polynomial $ A $ is assumed to be monic, so the coefficient 
$a_0=1$ and only the coefficients from $a_1$ to $a_{n_d}$ must be input,
while all the coefficients of polynomial $ B $ are required,
i.e.\ from $b_0$ to $b_{n_n}$.

If a \kw{gain} is supplied, all the coefficients of $ B $
are multiplied by the gain.

Originally, the input needed to be taken from a \kw{scalar\_dof};
now, it can also be taken from a \kw{drive}, which can completely replace
the original form (e.g.\ by means of the \kw{dof}, the \kw{node}
and the \kw{element} drives) and requires much less effort because
no auxiliary node needs to be set up.
% FIXME: elaborate with examples

The filter is internally rewritten as a \kw{state space SISO} element.
By default, the \kw{controllable} canonical form is used, namely
\begin{align*}
	\cubr{\cvvect{
		\dot{x}_1 \\
		\dot{x}_2 \\
		\dot{x}_3 \\
		\vdots \\
		\dot{x}_{n_d}
	}} &= \sqbr{\matr{ccccc}{
		-a_1 & -a_2 & -a_3 & \ldots & -a_{n_d} \\
		1 & 0 & 0 & & 0 \\
		0 & 1 & 0 & & 0 \\
		\vdots & & & \ddots & \vdots \\
		0 & 0 & 0 & \ldots & 0
	}} \cubr{\cvvect{
		x_1 \\
		x_2 \\
		x_3 \\
		\vdots \\
		x_{n_d}
	}} + \sqbr{\cvvect{
		1 \\
		0 \\
		0 \\
		\vdots \\
		0
	}} u\plbr{t} \\
	y &= \sqbr{\matr{ccccc}{
		b_1 & b_2 & b_3 & \ldots & b_{n_d}
	}} \cubr{\cvvect{
		x_1 \\
		x_2 \\
		x_3 \\
		\vdots \\
		x_{n_d}
	}}
\end{align*}
Otherwise, a \kw{observable} canonical form can be used, namely
\begin{align*}
	\cubr{\cvvect{
		\dot{x}_1 \\
		\dot{x}_2 \\
		\dot{x}_3 \\
		\vdots \\
		\dot{x}_{n_d}
	}} &= \sqbr{\matr{ccccc}{
		-a_1 & 1 & 0 & \ldots & 0 \\
		-a_2 & 0 & 1 & & 0 \\
		-a_3 & 0 & 0 & & 0 \\
		\vdots & & & \ddots & \vdots \\
		-a_{n_d} & 0 & 0 & \ldots & 0
	}} \cubr{\cvvect{
		x_1 \\
		x_2 \\
		x_3 \\
		\vdots \\
		x_{n_d}
	}} + \sqbr{\cvvect{
		b_1 \\
		b_2 \\
		b_3 \\
		\vdots \\
		b_{n_d}
	}} u\plbr{t} \\
	y &= \sqbr{\matr{ccccc}{
		1 & 0 & 0 & \ldots & 0
	}} \cubr{\cvvect{
		x_1 \\
		x_2 \\
		x_3 \\
		\vdots \\
		x_{n_d}
	}}
\end{align*}
In case the filter is not strictly proper, because $n_n=n_d=n$,
it is turned into a strictly proper one by the transformation
\begin{align*}
	H\plbr{s}
	&= \frac{B\plbr{s}}{A\plbr{s}} \\
	&= \frac{
		b_0 s^n
		+ b_1 s^{n-1}
		+ \ldots
		+ b_n
	}{
		s^n
		+ a_1 s^{n-1}
		+ \ldots
		+ a_n
	} \\
	&= b_0 + \frac{B\plbr{s} - b_0 A\plbr{s}}{A\plbr{s}} \\
	&= b_0 + \frac{
		+ \plbr{b_1 - b_0 a_1} s^{n-1}
		+ \ldots
		+ \plbr{b_n - b_0 a_n}
	}{
		s^n
		+ a_1 s^{n-1}
		+ \ldots
		+ a_n
	}
\end{align*}
and the state space realization is modified by using the resulting 
numerator coefficients and by introducing a direct feedthrough term
$b_0 u\plbr{t}$ in the output.


\paragraph{Example.} \
To model a 2nd order Butterworth filter of equation
\begin{equation}
	H\plbr{s} = \frac{
		1
	}{
		\plbr{\cfrac{s}{\omega_c}}^2
		+ \sqrt{2}\plbr{\cfrac{s}{\omega_c}}
		+ 1
	}
	\label{eq:scalar-filter}
\end{equation}
use
\begin{verbatim}
    set: real OMEGA_C = 1.*2*pi;                    # filter at 1Hz
    genel: 1, scalar filter,
        100, abstract, algebraic,                   # output node
        drive, sine, 0., 2.*pi, 1., forever, 0.,    # input drive
        2, sqrt(2.)*OMEGA_C, OMEGA_C^2,             # a_1, a_2
        0, 1.,                                      # b_0
        gain, OMEGA_C^2;
\end{verbatim}
Note that the formula of Eq.~(\ref{eq:scalar-filter})
had to be rearranged in order to make the denominator monic.




\subsubsection{State space SISO}
\label{sec:EL:GENEL:STATE-SPACE-SISO}
\begin{verbatim}
    <genel_type> ::= state space SISO
    <genel_arglist> ::=
        (node_dof) <output_node> ,
        { [ node dof , ] (node_dof) <input_node>
            | drive , (drive_caller) <input_value> } ,
        <state_order>
        [ , matrix E , <coefficient_list> ] ,
        matrix A , <coefficient_list> ,
        matrix B , <coefficient_list> ,
        matrix C , <coefficient_list>
        [ , matrix D , <coefficient> ]
        [ , gain , <gain> ]
        [ , balance , { yes | no } ]
        [ , value , <x0 list>
            [ , derivative , <x0p list> ] ]
\end{verbatim}
This element models a scalar (SISO) state space filter of the form
\begin{align*}
	\T{E} \dot{\T{x}} &= \T{A} \T{x} + \T{B} u \\
	y &= \T{C} \T{x} + D u
\end{align*}
where
\begin{itemize}
\item $\T{E}$ is a(n optional) matrix
	$\mathtt{state\_order} \times \mathtt{state\_order}$,
\item $\T{A}$ is a matrix
	$\mathtt{state\_order} \times \mathtt{state\_order}$,
\item $\T{B}$ is a vector
	$\mathtt{state\_order} \times 1$,
\item $\T{C}$ is a vector
	$1 \times \mathtt{state\_order}$, and
\item $D$ is a(n optional) scalar.
\end{itemize}
The matrices are read row-oriented; e.g., for matrix $\T{A}$:
\begin{verbatim}
    matrix A,
       a11, a12, ..., a1N,
       a21, a22, ..., a2N,
       ...,
       aN1, aN2, ..., aNN
\end{verbatim}

If LAPACK is available, the matrices are balanced by default,
unless explicitly disabled by using the \kw{balance} optional keyword.
If matrix $\TT{E}$ is defined, the \kw{DGGBAL} routine is used;
the \kw{DGEBAL} routine is used otherwise.

The state and its derivative can be initialized using the keyword \kw{value}
and \kw{derivative}.
The initialization of the derivative only makes sense when the filter
is in descriptor form.

\subsubsection{State space MIMO}
\label{sec:EL:GENEL:STATE-SPACE-MIMO}
\begin{verbatim}
    <genel_type> ::= state space MIMO
    <genel_arglist> ::=
        <num_outputs> , (node_dof) <output_node_list> ,
        <num_inputs> ,
            { [ node dof , ] (node_dof) <input_node>
                | drive , (drive_caller) <input_value> }
            [ , ... ] ,
        <state_order>
        [ , matrix E , <coefficient_list> ] ,
        matrix A , <coefficient_list> ,
        matrix B , <coefficient_list> ,
        matrix C , <coefficient_list>
        [ , matrix D , <coefficient_list> ]
        [ , gain , <gain> ]
        [ , balance , { yes | no } ]
        [ , value , <x0 list>
            [ , derivative , <x0p list> ] ]
\end{verbatim}
This element models a vector (MIMO) state space filter of the form
\begin{align*}
        \T{E} \dot{\T{x}} &= \T{A}\T{x}+\T{B}\T{u} \\
	\T{y} &= \T{C}\T{x}+\T{D}\T{u}
\end{align*}
where
\begin{itemize}
\item $\T{E}$ is a(n optional) matrix
	$\mathtt{state\_order} \times \mathtt{state\_order}$,
\item $\T{A}$ is a matrix
	$\mathtt{state\_order} \times \mathtt{state\_order}$,
\item $\T{B}$ is a matrix
	$\mathtt{state\_order} \times \mathtt{num\_inputs}$,
\item $\T{C}$ is a matrix
	$\mathtt{num\_outputs} \times \mathtt{state\_order}$, and
\item $\T{D}$ is a(n optional) matrix
	$\mathtt{num\_outputs} \times \mathtt{num\_inputs}$.
\end{itemize}
The matrices are read row-oriented.

If LAPACK is available, the matrices are balanced by default,
unless explicitly disabled by using the \kw{balance} optional keyword.
If matrix $\TT{E}$ is defined, the \kw{DGGBAL} routine is used;
the \kw{DGEBAL} routine is used otherwise.


\subsection{Special Rotorcraft \textsc{Genel} Elements}
The \textsc{Genel} elements specifically developed for use
in rotorcraft analysis currently include:
\begin{itemize}
\item the \kw{swashplate};
\item the \kw{rotor trim}.
\end{itemize}

\subsubsection{Swashplate}
\label{sec:EL:GENEL:SWASHPLATE}
The \kw{swashplate} \textsc{Genel} is used to transform the controls 
of a rotor, in terms of collective and fore/aft and lateral cyclic pitch, 
into the elongations of the actuators that actually move the swash plate.
The syntax of the \kw{swashplate} is:
\begin{verbatim}
    <genel_type> ::= swash plate
    <genel_arglist> ::=
        <collective_abstract_node> 
        [ , limits , <min_collective> , <max_collective> ] ,
        <fore/aft_abstract_node> 
        [ , limits , <min_fore/aft> , <max_fore/aft> ] ,
        <lateral_abstract_node> 
        [ , limits , <min_lateral> , <max_lateral> ] ,
        <actuator_1_abstract_node> ,
        <actuator_2_abstract_node> ,
        <actuator_3_abstract_node> 
        [ , <dynamic_coef> , <cyclic_factor> , <collective_factor> ]
\end{verbatim}
The first three abstract nodes will contain the input values 
of collective, fore/aft and cyclic pitch
(they can be actuated by means of abstract forces),
and the limits on the ``angles'' can be easily set. 
The last three nodes will contain the values of the stroke of the actuators.
The first actuator should be put at the azimuthal position 
that makes the current blade assume the fore/aft pitch,
so that its pitch link is $\llk{atan}\plbr{1/\omega_{\beta}}$
before the front direction.
The other actuators should follow, 120\degr apart in clockwise direction.
The limits on the actuators will simply force the value of the control
inputs to remain in the boundaries regardless of the input values.
The last three optional parameters are a dynamic coefficient that is used to
add some dynamics to the actuators' stroke, namely the input variables are
applied a sort of \kw{spring stiffness} \kw{bulk} element, while the
actuators' strokes are applied a transfer function of the first order, namely
$ \alpha\dot{x}+x=f $, where $ \alpha=\kw{dynamic\_coef} $ and $ f $ is
the desired stroke, so the smaller is $ \alpha $, the more the behavior is
static.
The \kw{cyclic\_factor} and the \kw{collective\_factor} parameters are
used to scale the inputs from angles in the desired units to strokes, that
usually are dimensional parameters. The actual strokes are made of the
collective contribution multiplied by \kw{collective\_factor}, and the
cyclic contribution multiplied by \kw{collective\_factor} times 
\kw{cyclic\_factor}.

\subsubsection{Rotor Trim}
\label{sec:EL:GENEL:ROTOR-TRIM}
The syntax of the \kw{rotor trim} is
\begin{verbatim}
    <genel_type> ::= rotor trim
    <genel_arglist> ::= <rotor_label> ,
        <thrust_node_label> ,
        <longitudinal_moment_node_label> ,
        <lateral_moment_node_label> ,
        (drive_caller) <desired_thrust_coefficient> ,
        (drive_caller) <desired_longitudinal_moment_coefficient> ,
        (drive_caller) <desired_lateral_moment_coefficient> ,
        <rotor_lock_number> ,
        <rotor_nondimensional_flap_frequency> ,
        <thrust_time_constant> , <moments_time_constant> ,
	<thrust_gain> , <moments_gain>
	[ , trigger , (drive_caller) <trigger> ]
\end{verbatim}
The \kw{rotor trim} is experimental; it allows to set the controls 
of a generic helicopter, in conjunction with the \kw{swashplate}
element, to asymptotically obtain the desired level of thrust and
moment coefficients.
The corresponding behavior in terms of trim values (flapping angles
and shaft angle) has not been implemented yet.
For details, see \cite{PETERS-TRIM90}.







\section{Gravity Element}
\begin{verbatim}
    <arglist> ::= (Vec3_tpl_drive_caller) <gravity_acceleration>
\end{verbatim}
the drive of the gravity acceleration, in the global reference frame.




\section{Hydraulic Element}
\label{sec:EL:HYDR}
{\em 
    Note: under development; syntax subjected to changes \\
    Initially implemented by: Lamberto Puggelli \\
    Reviewed by: Pierangelo Masarati
}
\begin{verbatim}
    <normal_arglist> ::= <hydr_elem_type> , 
        <hydr_elem_data>
\end{verbatim}
The field \kw{hydraulic\_element\_data} usually contains information
about fluid properties, which are handled by means of an \kw{hydraulic\_fluid}.
This can be directly inserted, following the syntax described in
Section~\ref{sec:HYDRAULIC-FLUID} preceded by the keyword \kw{fluid}, or a
previously defined fluid can be recalled by using the keyword 
\kw{reference} followed by the label of the desired fluid:
\begin{verbatim}
    <hydraulic_fluid_properties> ::=
        { <hydraulic_fluid_specification>
        | reference , <hydraulic_fluid_label> }
\end{verbatim}

\subsection{Actuator}
The \kw{actuator} element models the hydraulic and interactional aspects
of a two-way linear hydraulic actuator.
The two hydraulic nodes represent the pressure in the two chambers
of the cylinder.
The two structural nodes represent the cylinder and the piston.
Their relative motion is assumed to consist essentially
in a displacement along a given direction in the reference frame
of structural node 1.
The user must take care of this by constraining the two nodes
with an appropriate set of \kw{joint} elements.
Other hydraulic aspects of this component, like leakages between
the two chambers and between the chambers and the outside,
and the related pressure losses, must be explicitly taken care of,
e.g.\ by means of \kw{minor loss} elements.
\label{sec:EL:HYDR:ACTUATOR}
\begin{verbatim}
    <hydr_elem_type> ::= actuator

    <hydr_elem_data> ::= <node_1> , <node_2> , 
        <struct_node_1> , (Vec3) <offset_1> ,
        <struct_node_2> , (Vec3) <offset_2> ,
        [ direction , ((Unit)Vec3) <direction> , ]
        <area_1> ,
        <area_2> ,
        <cylinder_length> ,
        fluid , (hydraulic_fluid_properties)<fluid_1> ,
        { same | fluid , (hydraulic_fluid_properties)<fluid_2> }
\end{verbatim}
The vector \kw{direction} is internally normalized to unity.
By default, it is direction 3 in the reference frame of structural node 1.

\paragraph{Example.} \
See the ``actuator'' example at
\begin{quote}
\htmladdnormallink{\kw{http://www.aero.polimi.it/mbdyn/documentation/examples/actuator}}{http://www.aero.polimi.it/mbdyn/documentation/examples/actuator}
\end{quote}
and the related chapter of the tutorials
\begin{quote}
\htmladdnormallink{\kw{http://www.aero.polimi.it/mbdyn/documentation/tutorials/}}{http://www.aero.polimi.it/mbdyn/documentation/tutorials/}
\end{quote}



\subsection{Minor Loss}
A pressure loss between two pressure nodes.
\label{sec:EL:HYDR:MINOR_LOSS}
\begin{verbatim}
    <hydr_elem_type> ::= minor loss

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <k12> , <k21> , <area> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
Coefficients \kw{k12} and \kw{k21} characterize the pressure loss
when the flow goes from pressure node 1 to 2 and viceversa.
Turbulent flow is assumed.



\subsection{Three Way Minor Loss}
A pressure loss between three pressure nodes,
depending on the sign of the pressure drop.
\label{sec:EL:HYDR:THREE_WAY_MINOR_LOSS}
\begin{verbatim}
    <hydr_elem_type> ::= three way minor loss

    <hydr_elem_data> ::=
        <node_1> , <node_2> , <node_3> ,
        <k12> , <k31> , <area_12> , <area_31> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
Coefficients \kw{k12} and \kw{k31} and the respective values of area
characterize the pressure loss when the flow goes
from pressure node 1 to 2 and from pressure node 3 to 1, respectively.
Turbulent flow is assumed.



\subsection{Control Valve}
\label{sec:EL:HYDR:CONTROL_VALVE}
\begin{verbatim}
    <hydr_elem_type> ::= control valve

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <node_3> , <node_4>
        <area> ,
        [ loss , <loss_factor> , ]
        (DriveCaller) <state> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
This element represents a valve that connects
\kw{node\_1} to \kw{node\_2} and \kw{node\_3} to \kw{node\_4}
when \kw{state} is positive, and \kw{node\_1} to \kw{node\_3}
and \kw{node\_2} to \kw{node\_4} when \kw{state} is negative.
The flow area is proportional to \kw{area} times the norm of \kw{state},
which must be comprised between $-1$ and $1$.
If \kw{loss\_factor} is defined, it represents the fraction
of area that leaks even when \kw{state} is exactly zero.



\subsection{Dynamic Control Valve}
\label{sec:EL:HYDR:DYNAMIC_CONTROL_VALVE}
\begin{verbatim}
    <hydr_elem_type> ::= dynamic control valve

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <node_3> , <node_4> ,
        (DriveCaller) <force> ,
        <initial_displacement> ,
        <max_displacement> ,
        <duct_width> ,
        [ loss , <loss_factor> , ]
        <valve_diameter> ,
        <valve_density> ,
        <displacement> ,
        <velocity> ,
        <acceleration> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
This element represents a valve that connects
\kw{node\_1} to \kw{node\_2} and \kw{node\_3} to \kw{node\_4}
when the displacement is positive and \kw{node\_1} to \kw{node\_3}
and \kw{node\_2} to \kw{node\_4} when the displacement is negative,
accounting for the dynamics of the valve body.
The control force \kw{force} is applied to the valve, whose 
geometric and structural properties are described by 
\kw{initial\_displacement}, \kw{max\_displacement},
\kw{duct\_width}, \kw{valve\_diameter} and \kw{valve\_density}.
Again the \kw{loss\_factor}, if defined, represents the fraction
of the area that leaks when the displacement is zero.
Finally, \kw{displacement}, \kw{velocity} and \kw{acceleration}
are the penalty coefficients for displacement, velocity and acceleration
when the maximum stroke is reached.




\subsection{Pressure Flow Control Valve}
\label{sec:EL:HYDR:PRESSURE_FLOW_CONTROL_VALVE}
\begin{verbatim}
    <hydr_elem_type> ::= pressure flow control valve

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <node_3> , <node_4> ,
        <node_5> , <node_6> ,
        (DriveCaller) <force> ,
        <initial_displacement> ,
        <max_displacement> ,
        <duct_width> ,
        [ loss , <loss_factor> , ]
        <valve_diameter> ,
        <valve_density> ,
        <displacement> ,
        <velocity> ,
        <acceleration> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
Same as Dynamic Control Valve (\ref{sec:EL:HYDR:DYNAMIC_CONTROL_VALVE}),
only the pressures at \kw{node\_5} and \kw{node\_6} are applied
at the sides of the valve body and participate in the force balance.



\subsection{Pressure Valve}
\label{sec:EL:HYDR:PRESSURE_VALVE}
\begin{verbatim}
    <hydr_elem_type> ::= pressure valve

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <area> ,
        <mass> ,
        <max_area> ,
        <spring_stiffness> ,
        <spring_preload> ,
        <width> ,
        <displacement_penalty> ,
        <velocity_penalty> ,
        <acceleration_penalty> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}

\subsection{Flow Valve}
\label{sec:EL:HYDR:FLOW_VALVE}
\begin{verbatim}
    <hydr_elem_type> ::= flow valve

    <hydr_elem_data> ::=
        <node_1> , <node_2> , <node_3> ,
        <area> ,
        <mass> ,
        <max_area> ,
        <spring_stiffness> ,
        <spring_preload> ,
        <width> ,
        <displacement_penalty> ,
        <velocity_penalty> ,
        <acceleration_penalty> ,
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}



\subsection{Orifice}
\label{sec:EL:HYDR:ORIFICE}
\begin{verbatim}
    <hydr_elem_type> ::= orifice

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <orifice_area> ,
        [ area , <pipe_area> , ]
        [ reynolds , <critical_reynolds_number> , ]
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}



\subsection{Accumulator}
\label{sec:EL:HYDR:ACCUMULATOR}
Not documented yet.



\subsection{Tank}
\label{sec:EL:HYDR:TANK}
Not documented yet.



\subsection{Pipe}
\label{sec:EL:HYDR:PIPE}
This element models a simple pipeline connecting two \kw{hydraulic} nodes.
In detail, it models the pressure loss due to fluid viscosity
according to a constitutive law that depends on the Reynolds number
computed on average fluid velocity and hydraulic diameter.
Transition between laminar and turbulent flow is also modeled.
\begin{verbatim}
    <hydr_elem_type> ::= pipe

    <hydr_elem_data> ::=
        <node_1> , <node_2> ,
        <hydraulic_diameter> ,
        [ area , <area> , ]
        <length> ,
        [ turbulent , ]
        [ initial value , <flow> , ]
        fluid , (hydraulic_fluid_properties)<fluid>
\end{verbatim}
When \kw{area} is not given, it defaults to the equivalent area
computed according to the hydraulic diameter.
The flag \kw{turbulent} forces the flow to be considered turbulent
since the first iteration, when the initial conditions would fall
in the transition region.
The \kw{initial value} parameter refers to the initial value
of the flow internal state.

\paragraph{Example.} \
\begin{verbatim}
    set: integer NODE_1 = 10;
    set: integer NODE_2 = 20;
    set: integer PIPE = 100;
    set: integer FLUID = 1000;
    # ...
    hydraulic: PIPE, pipe, NODE_1, NODE_2,
        5e-3, 100.e-3,
        fluid, reference, FLUID;
\end{verbatim}



\subsection{Dynamic Pipe}
\label{sec:EL:HYDR:DYNAMIC_PIPE}
Same syntax as the \kw{pipe} hydraulic element
(Section~\ref{sec:EL:HYDR:PIPE}),
it also considers fluid compressibility in terms of pressure time derivative,
and thus the corresponding dynamic effect.




\subsection{Imposed Pressure}
\label{sec:EL:HYDR:IMPOSED_PRESSURE}
No specific element has been implemented to impose the pressure at one node.
The \kw{clamp} variant of the \kw{genel} element type
(Section~\ref{sec:EL:GENEL:CLAMP}) can be used instead.

\paragraph{Example.} \
\begin{verbatim}
    set: integer HYDRAULIC_NODE_LABEL = 100;
    set: integer IMPOSED_PRESSURE_LABEL = 200;
    genel: IMPOSED_PRESSURE_LABEL, clamp,
        HYDRAULIC_NODE_LABEL, hydraulic,
        const, 101325.0;
\end{verbatim}


\subsection{Imposed Flow}
\label{sec:EL:HYDR:IMPOSED_FLOW}
No specific element has been implemented to impose the flow at one node.
The \kw{abstract} variant of the \kw{force} element type
(Section~\ref{sec:EL:FORCE:ABSTRACT}) can be used instead.
The magnitude of the abstract force is the mass flow extracted
from the circuit at that node.
In fact, a negative value of the abstract force means that the flow enters
the node.

\paragraph{Example.} \
\begin{verbatim}
    set: integer HYDRAULIC_NODE_LABEL = 100;
    set: integer IMPOSED_FLOW_LABEL = 200;
    force: IMPOSED_PRESSURE_LABEL, abstract,
        HYDRAULIC_NODE_LABEL, hydraulic,
        const, -1e-3;
\end{verbatim}





\section{Joint Element}
Many different joints are available. A first rough classification can be
based on which joints have internal degrees of freedom (the reactions) and
which don't. The latter are flexible joints, that directly add their
stiffness contribution to the dynamic system matrix. From the input point
of view there is no difference between the two classes.
a typical joint entry is made as follows:
\begin{verbatim}
    <normal_arglist> :: = <joint_type> , <joint_arglist>
\end{verbatim}
The output is written to a file with extension \kw{.jnt}.
The output is generally made of a standard part, plus some extra information
depending on the type of joint, which, when available, is described along
with the joint description.
Here the standard part is described:
\begin{itemize}
    \item the label of the joint
    \item the three components of the reaction force in a local reference
    \item the three components of the reaction couple in a local frame
    \item the three components of the reaction force in the global frame
    \item the three components of the reaction couple, rotated into the
          global frame
\end{itemize}
Legal joint types, with relative data, are:




\subsection{Angular acceleration}
This joint imposes the absolute angular acceleration of a node
about a given axis.
\begin{verbatim}
    <joint_type> ::= angular acceleration
    <joint_arglist> ::= <node> , ((Unit)Vec3) <relative_direction> , 
                        (drive_caller) <acceleration>
\end{verbatim}
The axis is \kw{relative\_direction}; it is internally normalized to unity.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"M"} constraint reaction moment along joint direction
\item \kw{"wp"} imposed angular acceleration along joint direction
\end{enumerate}




\subsection{Angular velocity}
This joint imposes the absolute angular velocity of a node
about a given axis.
\begin{verbatim}
    <joint_type> ::= angular velocity
    <joint_arglist> ::= <node> , ((Unit)Vec3) <relative_direction> , 
                        (drive_caller) <velocity>
\end{verbatim}
The axis is \kw{relative\_direction}; it is internally normalized to unity.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"w"} imposed angular velocity about joint direction
\end{enumerate}

\subsection{Axial rotation}
\label{sec:EL:STRUCT:JOINT:AXIAL_ROTATION}
This joint is equivalent to a
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE},
but the angular velocity about axis 3 is imposed by means of the driver.
\begin{verbatim}
    <joint_type> ::= axial rotation
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        (drive_caller) <angular_velocity>
\end{verbatim}
{\em
    Note: this joint forces nodes 1 and 2 to rotate about relative 
    axis 3 with imposed angular velocity.
}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rz"} relative rotation angle about revolute axis
\item \kw{"wz"} relative angular velocity about revolute axis
\item \kw{"Fx"} constraint reaction force in node 1 local direction 1
\item \kw{"Fy"} constraint reaction force in node 1 local direction 2
\item \kw{"Fz"} constraint reaction force in node 1 local direction 3
\item \kw{"Mx"} constraint reaction moment about node 1 local direction 1
\item \kw{"My"} constraint reaction moment about node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment about node 1 local direction 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the relative orientation of the joint
with respect to node 1 is reset;
\item \kw{hinge\{2\}} the relative orientation of the joint
with respect to node 2 is reset;
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset;
\item unrecognized hints are passed through to the friction model,
if any.
\end{itemize}





\subsection{Beam slider}
This joint implements a slider, e.g.\ it constrains a structural node 
on a string of three-node beams, as discussed in \cite{SLIDER-AIDAA-2003}.
\begin{verbatim}
    <joint_type> ::= kinematic
    <joint_arglist> ::=
        <slider_node> ,
        (Vec3) <relative_offset> ,
        [ hinge , (OrientationMatrix) <relative_or_mat> ] ,
        [ type , { spherical | classic | spline } , ]
        <beam_number> ,
            <3_node_beam> ,
                { same | (Vec3) <first_node_offset> } ,
    [ hinge , { same | (OrientationMatrix) <first_node_or_mat> ] , }
                (Vec3) <mid_node_offset> ,
    [ hinge , (OrientationMatrix) <mid_node_or_mat> ] ,
                (Vec3) <end_node_offset> ,
    [ hinge , (OrientationMatrix) <end_node_or_mat> ] ,
                [ ... ]
        [ , initial beam , <initial_beam> ]
        [ , initial node, <initial_node> ]
        [ , smearing, <smearing_factor> ]
\end{verbatim}
There are three types of slider:
\begin{itemize}
	\item the \kw{spherical} slider does not constrain
	the orientation of the node;
	\item the \kw{classical} slider does allow rotation
	only about the sliding line;
	\item the \kw{spline} slider constrain the orientation
	of the node.
\end{itemize}
For each node of each beam element, the offset and the orientation
of the slider can be defined; except for the first element, the
offset and the orientation of the first node can be specified using
the keyword \kw{same}, which causes the node to take the same
value of the last node of the previous beam.
The \kw{initial\_beam} and \kw{initial\_node} indices
serve as hints to set the initial contact point of the sliding node.
The \kw{smearing\_factor} determines the (non-dimensional) extension
of the interference segment when the node passes from one segment
to another. % \cite{SLIDER}.



\subsection{Brake}
This element models a wheel brake, i.e.\ a constraint that applies
a frictional internal torque between two nodes about an axis.
The frictional torque depends on the normal force that is applied 
as an external input by means of the same friction models implemented
for regular joints.
\begin{verbatim}
    <joint_type> ::= brake
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        friction , <average_radius> , 
                   [ preload , <const_value> , ]
                   <friction_model> , 
                   <shape_function> ,
        (drive caller) <normal force>
\end{verbatim}
\emph{Note: a
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE}
between the same two nodes must be defined as well, such that
the only allowed relative kinematics between the two nodes are
a rotation about relative axis 3.
}

\subsubsection{Output}
In addition to the standard output, the \kw{brake} joint outputs:
\begin{itemize}
\item the three Euler-Cardano angles that express the relative rotation
	between the two connected nodes, in degrees;
\item the three components of the relative angular velocity,
	in the reference frame of node 2;
\item any output specific for the friction model in use;
\item the value of the force the brake is activated with.
\end{itemize}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rz"} relative rotation angle about brake axis
\item \kw{"wz"} relative angular velocity about brake axis
\end{enumerate}




\subsection{Cardano hinge}
\label{sec:EL:STRUCT:JOINT:CARDANO_HINGE}
This joint implements a Cardano's joint, also known as Hooke's joint
or Universal joint, which is made of a sequence
of two revolute hinges orthogonal to each other, one about relative axis 2
and one about relative axis 3 of the reference systems
defined by the two \kw{hinge} statements.
Or, in other words, this joint constrains the relative axis 3 of node 1 
to be always orthogonal to the relative axis 2 of node 2.
As a result, torque is transmitted about axis 1 of both nodes.
The relative position is also constrained.
\begin{verbatim}
    <joint_type> ::= cardano hinge
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
\end{verbatim}
Note: this joint does not represent a constant velocity joint,
so, when a steady deflection between the two nodes is present,
a constant velocity about axis 1 of one node results in an oscillating
velocity about axis 1 for the other node.
The constant velocity joint is implemented by the \kw{gimbal joint}
(Section~\ref{sec:EL:JOINT:GIMBALROTATION}), which essentially consists
of a sequence of two
\hyperref{\kw{cardano hinge}}{\kw{cardano hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_HINGE}
joints with the hinges in reversed order, assembled
in a manner that the deflection is split half and half
between the two joints.

\subsection{Cardano pin}
\label{sec:EL:STRUCT:JOINT:CARDANO_PIN}
This joint implements a ``Cardano'' joint between a node and the ground.
The absolute position is also constrained.
See above for details about the formulation.
\begin{verbatim}
    <joint_type> ::= cardano pin
    <joint_arglist> ::= 
        <node> , (Vec3) <relative_offset>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix> ] ,
        (Vec3) <absolute_pin_position>
        [ , hinge , 
            (OrientationMatrix) <absolute_pin_orientation_matrix> ]
\end{verbatim}
\emph{Note: this is equivalent to a
\hyperref{\kw{cardano hinge}}{\kw{cardano hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_HINGE}
when one node is grounded.
}

\subsection{Cardano rotation}
\label{sec:EL:STRUCT:JOINT:CARDANO_ROTATION}
This joint implements a ``Cardano'' joint, which is made of a sequence
of two revolute hinges orthogonal to each other.
The relative position is not constrained.
\begin{verbatim}
    <joint_type> ::= cardano rotation
    <joint_arglist> ::= 
        <node_1>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
\end{verbatim}
{\em
    Note: this joint forces the relative direction 3 of node 1 to be always 
    normal to the relative direction 2 of node 2.
}

\emph{Note: this is equivalent to a
\hyperref{\kw{cardano hinge}}{\kw{cardano hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_HINGE}
without position constraint.
Or, in other words, a 
\hyperref{\kw{cardano hinge}}{\kw{cardano hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_HINGE}
is made of a \kw{cardano rotation} on top of a 
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}.
}



\subsection{Clamp}
This joint grounds all 6 degrees of freedom of a node
in an arbitrary position and orientation that remains fixed.
\begin{verbatim}
    <joint_type> ::= clamp 
    <joint_arglist> ::= <node>
        [ , position ,
            { node | (Vec3) <absolute_position> } ]
        [ , orientation ,
            { node | (OrientationMatrix) <absolute_orientation_matrix> } ]
\end{verbatim}
\emph{Note: the keyword \kw{node} forces the joint to use
the nodal position and reference frame. Otherwise, they must be entered
in the usual way for these entities} \\
\emph{Note: the default value for \kw{position} and \kw{orientation}
are the position and the orientation of the clamped node.}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"Fx"} constraint reaction force in global direction 1
\item \kw{"Fy"} constraint reaction force in global direction 2
\item \kw{"Fz"} constraint reaction force in global direction 3
\item \kw{"Mx"} constraint reaction moment in local direction 1
\item \kw{"My"} constraint reaction moment in local direction 2
\item \kw{"Mz"} constraint reaction moment in local direction 3
\end{enumerate}




\subsection{Coincidence}
not implemented yet, use a
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}
and a \kw{prismatic} 
instead.

\subsection{Deformable displacement hinge}
Deprecated; use the 
\hyperref{\kw{deformable displacement joint}}
	{\kw{deformable displacement joint} (see Section~}{)}
	{sec:EL:JOINT:DEFORMABLEDISP}
instead.


\subsection{Deformable displacement joint}
\label{sec:EL:JOINT:DEFORMABLEDISP}
This joint implements a configuration dependent force that is exchanged
between two points associated to two nodes with an offset.
The force may depend, by way of a generic 3D constitutive law, 
on the relative position and velocity of the two points, 
expressed in the reference frame of node 1.

\noindent
The constitutive law is attached to the reference frame of node 1,
so the sequence of the connections may matter in case of anisotropic
constitutive laws, if the relative orientation of the two nodes
changes during the analysis.
\begin{verbatim}
    <joint_type> ::= deformable displacement joint
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        (ConstitutiveLaw3D) <const_law>
\end{verbatim}

\noindent
Note: a variant of this element is under development,
which refers the material reference frame to an orientation 
that is intermediate between those of the two nodes.
See the
\hyperref{\kw{invariant deformable displacement joint}}
	{\kw{invariant deformable displacement joint} (Section~}{)}
	{sec:EL:JOINT:INVDEFORMABLEDISP}.



\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"dx"} relative displacement in node 1 local direction 1
\item \kw{"dy"} relative displacement in node 1 local direction 2
\item \kw{"dz"} relative displacement in node 1 local direction 3
\item \kw{"vx"} relative velocity in node 1 local direction 1
\item \kw{"vy"} relative velocity in node 1 local direction 2
\item \kw{"vz"} relative velocity in node 1 local direction 3
\item \kw{"Fx"} constraint reaction force in node 1 local direction 1
\item \kw{"Fy"} constraint reaction force in node 1 local direction 2
\item \kw{"Fz"} constraint reaction force in node 1 local direction 3
\end{enumerate}
In addition, the joint provides
access to any private data provided by the constitutive law.
They are accessed by prefixing the name of the data with the string
\kw{"constitutiveLaw."}; see the specific constitutive law
description of the available data in Section~\ref{sec:CONSTITUTIVE-LAWS}.

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the \kw{deformable displacement joint}
honors the following hints:
\begin{itemize}
\item \kw{hinge\{1\}} the orientation with respect to node 1
of the reference used to compute the linear strain is reset
to the value resulting from the node 2 hinge orientation
and the node 1 orientation
\begin{displaymath}
	\tilde{\T{R}}_{1h} = \T{R}_1^T \T{R}_2 \tilde{\T{R}}_{2h}
\end{displaymath}
\item \kw{hinge\{2\}} the orientation with respect to node 2
of the reference used to compute the linear strain is reset
to the value resulting from the node 1 hinge orientation
and the node 2 orientation
\begin{displaymath}
	\tilde{\T{R}}_{2h} = \T{R}_2^T \T{R}_1 \tilde{\T{R}}_{1h}
\end{displaymath}
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset to the value resulting 
from the node 2 offset and the node 1 position
\begin{displaymath}
	\tilde{\T{f}}_1 = \T{R}_1^T \plbr{
		\T{x}_2
		+ \T{R}_2 \tilde{\T{f}}_2
		- \T{x}_1
	}
\end{displaymath}
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset to the value resulting 
from the node 1 offset and the node 2 position
\begin{displaymath}
	\tilde{\T{f}}_2 = \T{R}_2^T \plbr{
		\T{x}_1
		+ \T{R}_1 \tilde{\T{f}}_1
		- \T{x}_2
	}
\end{displaymath}
\item unrecognized hints are passed through to the constitutive law.
\end{itemize}

\subsubsection{Output}
In addition to the standard output, the \kw{deformable displacement joint}
outputs:
\begin{itemize}
\item columns 14--16: the three components of the linear strain.
\end{itemize}
If the constitutive law is either viscous or viscoelastic:
\begin{itemize}
\item columns 17--19: the three components of the linear strain rate.
\end{itemize}



\subsection{Deformable hinge}
\label{sec:EL:JOINT:DEFORMABLEHINGE}
This joint implements a configuration dependent moment that is exchanged
between two nodes.
The moment may depend, by way of a generic 3D constitutive law, 
on the relative orientation and angular velocity of the two nodes, 
expressed in the reference frame of node 1.

\noindent
The constitutive law is attached to the reference frame of node 1,
so the sequence of the connections may matter in case of anisotropic
constitutive laws, if the relative orientation of the two nodes
changes during the analysis.
\begin{verbatim}
    <joint_type> ::= deformable hinge
    <joint_arglist> ::= 
        <node_1>
        [ , position , (Vec3) <relative_position_1> ]
        [ , orientation , (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> 
        [ , position , (Vec3) <relative_position_2> ]
        [ , orientation , (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        (ConstitutiveLaw3D) <const_law>
        [ , orientation description ,
            { euler123 | euler313 | euler 321
                | orientation vector | orientation matrix } ]
\end{verbatim}
\noindent
Note: a variant of this element has been developed,
which refers the material reference frame to an orientation 
that is intermediate between those of the two nodes.
See the
\hyperref{\kw{invariant deformable hinge}}
	{\kw{invariant deformable hinge} (Section~}{)}
	{sec:EL:JOINT:INVDEFORMABLEHINGE}.

\noindent
Note: this joint only applies internal moments; no forces
and no constraints to displacements are applied.
Usually, it is best used in conjunction with a
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE},
or any kind of joint that constrains the relative displacement
of the nodes as appropriate.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rx"} relative rotation vector component in node 1 local direction 1
\item \kw{"ry"} relative rotation vector component in node 1 local direction 2
\item \kw{"rz"} relative rotation vector component in node 1 local direction 3
\item \kw{"wx"} relative angular velocity in node 1 local direction 1
\item \kw{"wy"} relative angular velocity in node 1 local direction 2
\item \kw{"wz"} relative angular velocity in node 1 local direction 3
\item \kw{"Mx"} constraint reaction moment in node 1 local direction 1
\item \kw{"My"} constraint reaction moment in node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment in node 1 local direction 3
\end{enumerate}
In addition, the joint provides
access to the private data provided by the constitutive law.
They are accessed by prefixing the name of the data with the string
\kw{"constitutiveLaw."}; see the specific constitutive law
description of the available data in Section~\ref{sec:CONSTITUTIVE-LAWS}.

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the \kw{deformable hinge}
joint honors the following hints:
\begin{itemize}
\item \kw{hinge\{1\}} the orientation with respect to node 1
of the reference used to compute the angular strain is reset
to the value resulting from the node 2 hinge orientation
and the node 1 orientation
\begin{displaymath}
	\tilde{\T{R}}_{1h} = \T{R}_1^T \T{R}_2 \tilde{\T{R}}_{2h}
\end{displaymath}
\item \kw{hinge\{2\}} the orientation with respect to node 2
of the reference used to compute the angular strain is reset
to the value resulting from the node 1 hinge orientation
and the node 2 orientation
\begin{displaymath}
	\tilde{\T{R}}_{2h} = \T{R}_2^T \T{R}_1 \tilde{\T{R}}_{1h}
\end{displaymath}
\item unrecognized hints are passed through to the constitutive law.
\end{itemize}

\subsubsection{Output}
In addition to the standard output, the \kw{deformable joint}
outputs:
\begin{itemize}
\item columns 14--16 (or 14--22): the angular strain
in the selected orientation format (either three or nine columns,
according to the selected \kw{orientation description}, or to its 
\hyperref{default value)}{default value, see Section~}{)}{sec:CONTROLDATA:DEFAULTORIENTATION}.
\end{itemize}
If the constitutive law is either viscous or viscoelastic:
\begin{itemize}
\item columns 17--19 (or 23--25): the three components
of the angular strain rate.
\end{itemize}




\subsection{Deformable joint}
\label{sec:EL:JOINT:DEFORMABLEJOINT}
This joint implements a configuration dependent force and moment
that are exchanged by two points associated to two nodes with an offset.
The force the and moment may depend, by way of a generic 6D constitutive law,
on the relative position, orientation, velocity and angular velocity 
of the two points, expressed in the reference frame of node 1.
It may be thought of as a combination of a
\hyperref{\kw{deformable displacement joint}}
	{\kw{deformable displacement joint} (see Section~}{)}
	{sec:EL:JOINT:DEFORMABLEDISP}
and of a 
\hyperref{\kw{deformable hinge}}
	{\kw{deformable hinge} (see Section~}{)}
	{sec:EL:JOINT:DEFORMABLEHINGE};
a significant difference is that the \kw{deformable joint} uses a 6D
\hyperref{\kw{constitutive law}}
	{\kw{constitutive law} (see Section~}{)}
	{sec:CONSTITUTIVE-LAWS},
so the force and the moment may both depend on the displacement
and on the orientation.

\noindent
The constitutive law is attached to the reference frame of node 1,
so the sequence of the connections may matter in case of anisotropic
constitutive laws, if the relative orientation of the two nodes
changes during the analysis.

\noindent
This element may add a considerable overhead because of the computation
of the cross-coupling effects between the forces and moments and the
relative positions and orientations; if the constitutive law does not couple
relative displacements and orientations, a better choice consists 
in combining a \kw{deformable hinge} and a \kw{deformable displacement joint}.
\begin{verbatim}
    <joint_type> ::= deformable joint
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        (ConstitutiveLaw6D) <const_law>
\end{verbatim}
\emph{Note: this joint is experimental; it only works with elastic 
constitutive laws, the use with viscous and viscoelastic laws 
is untested yet, and thus it is disabled.}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"dx"} relative displacement in node 1 local direction 1
\item \kw{"dy"} relative displacement in node 1 local direction 2
\item \kw{"dz"} relative displacement in node 1 local direction 3
\item \kw{"rx"} relative rotation vector component in node 1 local direction 1
\item \kw{"ry"} relative rotation vector component in node 1 local direction 2
\item \kw{"rz"} relative rotation vector component in node 1 local direction 3
\item \kw{"vx"} relative velocity in node 1 local direction 1
\item \kw{"vy"} relative velocity in node 1 local direction 2
\item \kw{"vz"} relative velocity in node 1 local direction 3
\item \kw{"wx"} relative angular velocity in node 1 local direction 1
\item \kw{"wy"} relative angular velocity in node 1 local direction 2
\item \kw{"wz"} relative angular velocity in node 1 local direction 3
\item \kw{"Fx"} constraint reaction force in node 1 local direction 1
\item \kw{"Fy"} constraint reaction force in node 1 local direction 2
\item \kw{"Fz"} constraint reaction force in node 1 local direction 3
\item \kw{"Mx"} constraint reaction moment in node 1 local direction 1
\item \kw{"My"} constraint reaction moment in node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment in node 1 local direction 3
\end{enumerate}
In addition, the joint provides
access to the private data provided by the constitutive law.
They are accessed by prefixing the name of the data with the string
\kw{"constitutiveLaw."}; see the specific constitutive law
description of the available data in Section~\ref{sec:CONSTITUTIVE-LAWS}.

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the \kw{deformable joint}
honors the same hints of the \kw{deformable displacement joint}.

\subsubsection{Output}
In addition to the standard output, the \kw{deformable joint}
outputs:
\begin{itemize}
\item columns 14--16: the three components of the linear strain;
\item columns 17--19 (or 17--25): the angular strain
in the selected orientation format (either three or nine columns,
according to the selected \kw{orientation description}, or to its 
\hyperref{default value)}{default value, see Section~}{)}{sec:CONTROLDATA:DEFAULTORIENTATION}.
\end{itemize}
If the constitutive law is either viscous or viscoelastic:
\begin{itemize}
\item columns 20--22 (or 26--28): the three components
of the linear strain rate;
\item columns 23--25 (or 29--31): the three components
of the angular strain rate.
\end{itemize}




\subsection{Distance}
This joint forces the distance between two points,
each relative to a node, to assume the value indicated by the drive.
If no offset is given, the points are coincident with the node themselves.
\begin{verbatim}
    <joint_type> ::= distance 
    <joint_arglist> ::= <node_1> , 
                        [ position , <relative_offset_1> , ]
                        <node_2> ,
                        [ position , <relative_offset_2> , ]
                        { (drive_caller) <distance> | from nodes }
\end{verbatim}

\noindent
{\em 
    Note: the \kw{relative\_offset\_*} are the distances of each end
    of the joint from the relative nodes in the node reference frame.
    Both the \kw{distance} and the \kw{distance with offset} joints
    allow for null distance, but the transition from null to non-null
    distance is not smooth at all.
} \\
{\em
    Note: in case the keywords \kw{from nodes} are used, a constant drive
    caller is automatically instantiated for the \kw{distance}. 
    Its value is computed from the initial positions of the nodes;
    if defined, the distance between the offsets is considered. 
}

\subsubsection{Output}
The extra output is:
\begin{itemize}
    \item the three components of the imposed distance in the global frame
    \item the norm of the imposed distance
\end{itemize}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"d"} enforced distance
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item unrecognized hints are passed through to the distance drive.
\end{itemize}



\subsection{Distance with offset}
This element has been deprecated in favor of the \kw{distance}
joint element, which now supports offsets.
It may be dropped in future releases.

\subsubsection{Private Data}
See the \kw{distance} joint element.



\subsection{Drive displacement}
\label{sec:EL:JOINT:DRIVEDISPLACEMENT}
This joint imposes the relative position between two points 
optionally offset from two structural nodes,
in the form of a vector that expresses the direction of the displacement
in the reference frame of node 1, whose amplitude is defined by a drive.
\begin{verbatim}
    <joint_type> ::= drive displacement
    <joint_arglist> ::= 
        <node_1> , (Vec3) <offset_1> ,
        <node_2> , (Vec3) <offset_2> ,
        (Vec3_tpl_drive_caller) <relative_position>
\end{verbatim}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"dx"} imposed displacement component along node 1 axis 1
\item \kw{"dy"} imposed displacement component along node 1 axis 2
\item \kw{"dz"} imposed displacement component along node 1 axis 3
\item \kw{"fx"} reaction force component along node 1 axis 1
\item \kw{"fy"} reaction force component along node 1 axis 2
\item \kw{"fz"} reaction force component along node 1 axis 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset by pointing 
to the drive displacement point;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset by pointing 
to the drive displacement point;
\item unrecognized hints are passed through to the \kw{Vec3} drive.
\end{itemize}



\subsection{Drive displacement pin}
\label{sec:EL:JOINT:DRIVEDISPLACEMENTPIN}
This joint imposes the absolute position of a point optionally offset
from a structural node, in the form of a vector that expresses 
the direction of the displacement in the absolute reference frame,
whose amplitude is defined by a drive.
\begin{verbatim}
    <joint_type> ::= drive displacement pin
    <joint_arglist> ::= 
        <node> , (Vec3) <node_offset> ,
        (Vec3) <offset> ,
        (Vec3_tpl_drive_caller) <position>
\end{verbatim}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"dx"} imposed displacement component along absolute axis 1
\item \kw{"dy"} imposed displacement component along absolute axis 2
\item \kw{"dz"} imposed displacement component along absolute axis 3
\item \kw{"fx"} reaction force component along absolute axis 1
\item \kw{"fy"} reaction force component along absolute axis 2
\item \kw{"fz"} reaction force component along absolute axis 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to the node is reset by pointing 
to the driven displacement point;
\item \kw{offset\{0\}} the offset of the joint
with respect to the absolute reference frame is reset by pointing
to the driven displacement point;
\item unrecognized hints are passed through to the \kw{Vec3} drive.
\end{itemize}



\subsection{Drive hinge}
\label{sec:EL:JOINT:DRIVEHINGE}
This joint imposes the relative orientation between two nodes,
in the form of a rotation about an axis whose amplitude is defined
by a drive.
\begin{verbatim}
    <joint_type> ::= drive hinge
    <joint_arglist> ::= 
        <node_1>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> 
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_2> ] ,
        (Vec3_tpl_drive_caller) <hinge_orientation>
\end{verbatim}
\emph{Note: this element is eXperimental; now it is more reliable, 
but it is limited to $\nrbr{\tt <hinge\_orientation>} < \pi$}.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rx"} imposed relative rotation about node 1 hinge axis 1
\item \kw{"ry"} imposed relative rotation about node 1 hinge axis 2
\item \kw{"rz"} imposed relative rotation about node 1 hinge axis 3
\item \kw{"Mx"} reaction moment about node 1 hinge axis 1
\item \kw{"My"} reaction moment about node 1 hinge axis 2
\item \kw{"Mz"} reaction moment about node 1 hinge axis 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the orientation with respect to node 1
of the reference in which the enforced orientation is expressed is reset;
\item \kw{hinge\{2\}} the orientation with respect to node 2
of the reference in which the enforced orientation is expressed is reset;
\item unrecognized hints are passed through to the \kw{Vec3} drive.
\end{itemize}

\subsection{Gimbal hinge}
This joint has not been implemented yet; use a \kw{gimbal rotation}
and a
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}
to emulate.

\subsection{Gimbal rotation}\label{sec:EL:JOINT:GIMBALROTATION}
A homokinetic joint without position constraints;
this joint, in conjunction with a
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}
joint, should be used to implement an ideal tiltrotor gimbal
instead of a
\hyperref{\kw{cardano rotation}}{\kw{cardano rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_ROTATION}.
See the technical manual and \cite{GIMBAL-2008} for details.
It is equivalent to a series of two Cardano's joints
(the \hyperref{\kw{cardano hinge}}{\kw{cardano hinge}, see Section~}{}{sec:EL:STRUCT:JOINT:CARDANO_HINGE})
rotated 90 degrees apart, each accounting for half the relative rotation
between axis 3 of each side of the joint.
\begin{verbatim}
    <joint_type> ::= gimbal rotation
    <joint_arglist> ::= 
        <node_1>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
        [ , orientation description ,
            { euler123 | euler313 | euler 321
                | orientation vector | orientation matrix } ]
\end{verbatim}
{\em
    Note: this joint allows nodes 1 and 2 to rotate about relative 
    axes 1 and 2.
}

\subsubsection{Output}
The \kw{gimbal rotation} joint outputs the three components
of the reaction couple in the local frame (that of node 1) 
and in the global frame.

The extra columns 14 and 15 contain the angles $\vartheta$ and $\varphi$.
The extra columns from 16 on contain the relative rotation
between nodes 1 and 2, in the format determined either by an explicit
selection of the orientation description, or by the default
orientation description defined by the 
\hyperref{\kw{default orientation} keyword}{\kw{default orientation} keyword (see Section~}{)}{sec:CONTROLDATA:DEFAULTORIENTATION}.

The three components of the reaction couple in the local frame, 
and the angles $\vartheta$ and $\varphi$ are also available
as private data of the element under the names \kw{lambda[1-3]},
\kw{theta} and \kw{phi}.
For a description of the formulation and of the angles describe above,
see the Technical Manual.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"lambda[1]"} constraint reaction moment about node 1 local axis 1
\item \kw{"lambda[2]"} constraint reaction moment about node 1 local axis 2
\item \kw{"lambda[3]"} constraint reaction moment about node 1 local axis 3
\item \kw{"theta"} relative angle $\vartheta$
\item \kw{"phi"} relative angle $\varphi$
\end{enumerate}



\subsection{Imposed displacement}
\label{sec:EL:JOINT:IMPOSEDDISPLACEMENT}
This joint imposes the relative position between two points,
optionally offset from two structural nodes,
along a given direction that is rigidly attached to the first node.
The amplitude of the displacement is defined by a drive.
\begin{verbatim}
    <joint_type> ::= imposed displacement
    <joint_arglist> ::= 
        <node_1> , (Vec3) <offset_1> ,
        <node_2> , (Vec3) <offset_2> ,
        (Vec3) <direction> ,
        (drive_caller) <relative_position>
\end{verbatim}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"d"} imposed displacement along \kw{direction},
in node 1 reference frame;
\item \kw{"f"} reaction force along \kw{direction},
in node 1 reference frame.
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset by pointing exactly
to the imposed displacement point;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset by pointing exactly
to the imposed displacement point;
\item unrecognized hints are passed through to the drive.
\end{itemize}



\subsection{Imposed displacement pin}
\label{sec:EL:JOINT:IMPOSEDDISPLACEMENTPIN}
This joint imposes the absolute displacement of a point optionally offset
from a structural node, along a direction defined
in the absolute reference frame.
The amplitude of the displacement is defined by a drive.
\begin{verbatim}
    <joint_type> ::= imposed displacement pin
    <joint_arglist> ::= 
        <node> , (Vec3) <node_offset> ,
        (Vec3) <offset> ,
        (Vec3) <direction> ,
        (drive_caller) <position>
\end{verbatim}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"x"} imposed displacement along \kw{direction},
in the absolute reference frame;
\item \kw{"f"} reaction force along \kw{direction},
in the absolute reference frame.
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to the node is reset by pointing exactly
to the imposed displacement point;
\item \kw{offset\{0\}} the offset of the joint
with respect to the absolute reference frame is reset by pointing exactly
to the imposed displacement point;
\item unrecognized hints are passed through to the drive.
\end{itemize}




\subsection{In line}
This joint forces a point relative to the second node to move 
along a line attached to the first node.
\begin{verbatim}
    <joint_type> ::= in line
    <joint_arglist> ::= 
        <node_1> , 
        (Vec3) <relative_line_position> ,
        (Mat3x3) <relative_orientation> ,
        <node_2>
        [ , offset , (Vec3) <relative_offset>]
\end{verbatim}
A point, optionally offset by \kw{relative\_offset} from the position
of node \kw{node\_2}, slides along a line that passes through a point 
that is rigidly offset by \kw{relative\_line\_position}
from the position of \kw{node\_1}, and is directed as direction 3 
of \kw{relative orientation}.



\subsection{In plane}
This joint forces a point relative to the second node to move 
in a plane attached to the first node.
\begin{verbatim}
    <joint_type> ::= in plane
    <joint_arglist> ::= 
        <node_1> , 
        (Vec3) <relative_plane_position> ,
        ((Unit)Vec3) <relative_normal_direction> ,
        <node_2>
        [ , offset , (Vec3) <relative_offset>]
\end{verbatim}
A point, optionally offset by \kw{relative\_offset} from the position
of node \kw{node\_2}, slides on a plane that passes through a point 
that is rigidly offset by \kw{relative\_plane\_position}
from the position of \kw{node\_1}, and is perpendicular to 
\kw{relative\_normal\_direction}.
The vector \kw{relative\_normal\_direction} is internally normalized to unity.



\subsection{Invariant deformable displacement joint}\label{sec:EL:JOINT:INVDEFORMABLEDISP}
Under development; right now, use the
\hyperref{\kw{deformable displacement joint}}
	{\kw{deformable displacement joint} (see Section~}{)}
	{sec:EL:JOINT:DEFORMABLEDISP}
instead.



\subsection{Invariant deformable hinge}\label{sec:EL:JOINT:INVDEFORMABLEHINGE}
This (experimental) element is a variant of the
\hyperref{\kw{deformable hinge}}
	{\kw{deformable hinge} (see Section~}{)}
	{sec:EL:JOINT:DEFORMABLEHINGE};
refer to that joint for the input syntax.

\noindent
The \emph{invariant} form of the \kw{deformable hinge} joint 
refers the constitutive law to an orientation that is intermediate 
between those of the nodes it connects.
As a result, the moment exchanged between the two nodes
is invariant to the sequence of definition of the nodes
when anisotropic constitutive laws are used.
It is worth stressing that determining the consititive law for this
element may be tricky, since usual measurement approaches
directly measure forces and moments in a reference frame
that is attached to one of the two ends of the component,
so in practical cases it might be more appropriate to use the
\emph{variant} form of the joint, and consistently referring
the constitutive law to the same end used to measure
the mechanical properties of the component.

%%% FIXME: the residual (and the tecman) is available,
%%% but needs work to split it out of the DeformableHinge,
%%% define it as a separate element, and implement
%%% the Jacobian matrix contribution



\subsection{Kinematic}
This joint will eventually evolve into a connection with external programs
that impose the entire motion of a node; at present, you can use it
by directly writing code in files \verb;mbdyn/struct/kin.cc; and
\verb;mbdyn/struct/kin.h; that implement the motion you wish to impose.
\begin{verbatim}
    <joint_type> ::= kinematic
    <joint_arglist> ::= 
        <node_1> ,
        (drive_caller) <input>
\end{verbatim}
\emph{Note: this element is eXperimental.}

\subsection{Linear acceleration}
This joint imposes the absolute linear acceleration of a node
along a given axis.
\begin{verbatim}
    <joint_type> ::= linear acceleration
    <joint_arglist> ::= <node> , ((Unit)Vec3) <relative_direction> , 
                        (drive_caller) <acceleration>
\end{verbatim}
The axis is \kw{relative\_direction}; it is internally normalized to unity.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"F"} constraint reaction force along joint direction
\item \kw{"a"} imposed acceleration along joint direction
\end{enumerate}

\subsection{Linear velocity}
This joint imposes the absolute linear velocity of a node
along a given axis.
\begin{verbatim}
    <joint_type> ::= linear velocity
    <joint_arglist> ::= <node> , ((Unit)Vec3) <relative_direction> , 
                        (drive_caller) <velocity>
\end{verbatim}
The axis is \kw{relative\_direction}; it is internally normalized to unity.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"v"} imposed velocity along joint direction
\end{enumerate}

\subsection{Modal}\label{sec:EL:STRUCT:JOINT:MODAL}
\emph{
Original implementation: Felice Felippone; \\
Initial review: Giuseppe Quaranta; \\
Current review: Pierangelo Masarati.}

This joint implements a Component Mode Synthesis (CMS) deformable body.
Its interface with the multibody domain is represented by clamps
that constrain the multibody interface nodes to the position
and orientation of the corresponding FEM nodes.

\begin{verbatim}
    <joint_type> ::= modal
    <joint_arglist> ::=
        { <reference_modal_node> | clamped
            [ , position , (Vec3)<absolute_position> ]
            [ , orientation , (Mat3x3)<absolute_orientation> ] } ,
        <mode_number> ,
        [ list, <mode> [ , ... ] , ]
        [ initial value ,
            { mode , <n> , <q_n> , <qP_n> [ , ... ]
                | <q_1> , <qP_1> [ ... ] } , ]
        { <fem_node_number> | from file } ,
        [ { no damping 
            | proportional damping , <damping_coef>
            | diag damping ,
                { all , <damping_coef> [ , ...]
                | <damped_modes > , <mode_damping> [ , ... ] } } ,
        ]
        " <fem_data_file> " ,
        [ [ { mass | stiffness } ] threshold , <threshold> , ]
        [ { create binary | use binary | update binary }
            [ , ... ] , ]
        [ use invariant 9 , ]
        [ { origin node , <origin_node> | origin position , (Vec3)<pos> } , ]
        <interface_nodes_number> , <interface_node> [ , ... ]

    <mode_damping> ::= <mode_index> , <mode_damping_coef>

    <interface_node> ::=
        { " <fem_node_label> " | (integer)<fem_node_label> } ,
            <multibody_label> , (Vec3)<offset_of_FEM_node>
\end{verbatim}
The \kw{reference\_modal\_node} is a special dynamic structural node 
that is required to handle the rigid body motion of the modal joint.
Its input is completely analogous to that of the \kw{dynamic} structural
nodes, see Section~\ref{sec:NODE:STRUCTURAL}, only the keyword \kw{dynamic} 
must be replaced by \kw{modal}.

If no rigid body dynamics is required, e.g.\ if the modal element
is clamped, the \kw{clamped} option can be used, which allows
to set the optional \kw{absolute\_position}
and \kw{absolute\_orientation}.
The former is the location, in the multibody
global reference system, of the origin of the FEM reference system.
The latter is the orientation,
in the multibody global reference frame,
of the FEM reference system.
They default to zero and identity, which means
that the global multibody reference frame
and the FEM reference system are coincident.

The mode count in \kw{mode\_number} is not required to match
the number of modes listed in the FEM data file; if a lower number
is given, only the first \kw{mode\_number} modes are used;
moreover, a list of active modes can be given, to use non-consecutive
modes; e.g., to use modes 1, 2, 3 and 6 out of a set of 10 modes
defined in the FEM data file, write
\begin{verbatim}
    ...,
    4,                        # number of active modes
        list, 1, 2, 3, 6,     # list of active modes
    ...
\end{verbatim}

By default, the origin of the FEM grid is placed either in the position
of the modal node, with its orientation, or in the absolute position 
and orientation in case the modal element is clamped, 
unless one of the mutually exclusive \kw{origin node} 
and \kw{origin position} optional keywords is used.
The \kw{origin node} keyword defines what FEM node corresponds 
to the \kw{modal} node in the multibody domain,
or what FEM node corresponds to the optional absolute position 
and orientation in case of a clamped modal element.
The \kw{origin position } keyword defines where, in the FEM model
reference frame, the \kw{modal} node is placed, or the location
that corresponds to the optional absolute position and orientation
in case of a clamped modal element.

The FEM labels can be strings made of any character,
provided they do not contain blanks.
The strings must be enclosed in double quotes.
For legacy reasons, a label not enclosed in double quotes
is accepted, provided it is an integer.

If any of \kw{mass threshold}, \kw{stiffness threshold} are given,
elements whose absolute value is lower than the threshold
are discarded from the mass and stiffness matrix, respectively.
The keyword \kw{threshold} is a catchall for both,
meaning that the same threshold must be used for both matrices.

The list of matchings between FEM and multibody nodes needs
special care.
The \kw{offset\_of\_FEM\_node} field contains the distance
of the FEM node from the respective multibody node; by default,
this is expressed in the reference frame of the multibody node.

The \kw{fem\_data\_file} can be generated by NASTRAN, 
following the procedure illustrated
in Appendix~\ref{sec:APP:EL:STRUCT:JOINT:MODAL:NASTRAN}.

It is strongly recommended that constrained modal analysis
be used for otherwise free bodies, with the statically 
determined constraint consisting of clamping the FEM node 
that will coincide with the node indicated as \kw{reference\_modal\_node},
and using the \kw{origin node} to make that point the origin
of the FEM frame.

\textbf{Note about reference frames:} the coincidence constraint between 
multibody and FEM nodes is written between the local frame 
of the FEM node and the global frame of the multibody node.
As such, the multibody nodes must be oriented as the \kw{modal}
node the \kw{modal} joint refers to, if any, or as the reference
orientation of the \kw{modal} joint, if it is clamped.

\textbf{Note about initial assembly:} it is very important that multibody 
and FEM nodes at interfaces are given with a high degree of accuracy,
because the initial assembly procedure of the modal element
does not behave very well (it's on the TODO list with a very low
priority); as a consequence, pay very much attention to the input
of these nodes, until more robust procedures are developed.
One trick is to build models incrementally.
%\begin{itemize}
%\item build the model up to the modal element
%\item find out where a FEM node is going to end out by running
%	mbdyn with \kw{abort after: input}
%\item place the corresponding multibody node exactly in the position
%	indicated by the FEM model output.
%\end{itemize}
Offsets between FEM and multibody nodes 
should be avoided unless strictly required.

\textbf{Note about the FEM file:}
the format of the \kw{fem\_data\_file} is relatively straightforward;
it is reported
in Appendix~\ref{sec:APP:EL:STRUCT:JOINT:MODAL:FORMAT}.
Initial modal displacements and velocities can be added,
if required, by manually editing the file; however this practice
is discouraged, unless strictly required.


\textbf{Note about large FEM files:}
using a very large \kw{fem\_data\_file} may require long time for
reading and parsing ASCII floats.
The keyword \kw{use binary} instructs MBDyn to use a binary version
of the \kw{fem\_data\_file}.
This binary version is automatically generated by MBDyn if requested
by means of the keyword \kw{create binary}.
The binary version of the \kw{fem\_data\_file} is used only if its
timestamp is more recent than that of the ASCII version.
The keyword \kw{update binary} instructs MBDyn to regenerate the
binary version when the ASCII version is more recent.

\textbf{Note about the structural damping:}
structural damping can be provided by specifying any of the
\kw{no damping}, \kw{proportional damping} or \kw{diag damping}.
In the last two cases, a damping factor is required.
The corresponding damping for the $i$-th mode is computed as
\begin{displaymath}
	c_i = \mathtt{factor}_i \, 2 \sqrt{k_i m_i}
\end{displaymath}
where $\mathtt{factor}_i$ is the value provided
for \kw{proportional damping} (same for all modes) or the list 
of values provided for \kw{diag damping} (for each mode).
For example, a factor of 0.01 means 1\% damping.

The keyword \kw{diag damping} is followed by the count of damped modes,
or by the keyword \kw{all}.
If \kw{all} is used, as many damping coefficients as the available modes
are expected.
Otherwise, a list of \kw{mode\_damping} values follows.
Each occurrence of \kw{mode\_damping} is made of the mode's index
and the related damping value.


\subsubsection{Output}
Up to MBDyn 1.2.6 output occurred in a specific file that needed
to be mandatorily given as the last argument to each modal element
definition.
Now output occurs in a \kw{.mod} file, which contains, for each time step,
as many rows as all the modes of all the modal elements whose output is enabled.
Each row is structured as follows:
\begin{itemize}
\item a field containing the label of the modal joint and the number of the mode,
separated by a dot (e.g. \kw{label.mode})
\item the value of the modal unknown
\item the value of the first derivative of the modal unknown
\item the value of the second derivative of the modal unknown
\end{itemize}
Note: the number of the mode is the first field of the output
is the ordinal of the mode in the FEM data file.
If only a portion of the modes was selected using the \kw{list} keyword,
the mode numbers will reflect the selected modes.
For example, if the \kw{modal} joint was defined as
\begin{verbatim}
    set: MODAL_ELEM = 99;
    set: MODAL_NODE = 101;
    joint: MODAL_ELEM, modal, MODAL_NODE,
        3, list, 1, 7, 9, # only use modes 1, 7 and 9 of a larger basis
        from file,
        "modal.fem",
        0;                # no fem nodes
\end{verbatim}
the output will look like
\begin{verbatim}
      99.1 0.000000e+00 0.000000e+00 0.000000e+00
      99.7 0.000000e+00 0.000000e+00 0.000000e+00
      99.9 0.000000e+00 0.000000e+00 0.000000e+00
\end{verbatim}

\subsubsection{Private Data}
The following data is available, for each mode:
\begin{enumerate}
\item \kw{"q[<m>]"} mode \kw{<m>} value
\item \kw{"qP[<m>]"} mode \kw{<m>} derivative value
\item \kw{"qPP[<m>]"} mode \kw{<m>} second derivative value
\item \kw{"x[<n>,<i>]"} FEM node \kw{<n>} position \kw{<i>} component value
\item \kw{"xP[<n>,<i>]"} FEM node \kw{<n>} velocity \kw{<i>} component value
\item \kw{"xPP[<n>,<i>]"} FEM node \kw{<n>} acceleration \kw{<i>} component value
\item \kw{"w[<n>,<i>]"} FEM node \kw{<n>} angular velocity \kw{<i>} component value
\item \kw{"wP[<n>,<i>]"} FEM node \kw{<n>} angular acceleration \kw{<i>} component value
\end{enumerate}
When \kw{<m>} is a number, the mode whose name is that number is used;
when \kw{<m>} is the character `\#' followed by a number,
the mode whose index is the number is used.
The two cases may differ when only a subset of the modes defined
in the FEM data file are actually used.

``FEM'' node means that the label of the FEM node must be used;
this allows to use the motion of nodes that are not attached
to a multibody node.
This motion is expressed in the global reference frame.




\subsection{Plane displacement}\label{sec:EL:STRUCT:JOINT:PLANE_DISPLACEMENT}
This joint allows two nodes to move in the common relative 1--2 plane 
and to rotate about the common relative axis 3.
\begin{verbatim}
    <joint_type> ::= plane displacement
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
\end{verbatim}
\emph{Note: this element is temporarily disabled;
combine an \kw{in plane} and a
\hyperref{\kw{revolute rotation}}{\kw{revolute rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_ROTATION}
joint instead.}

\subsection{Plane displacement pin}
This joint allows a node to move in the relative 1--2 plane 
and to rotate about the relative axis 3 with respect to an absolute point 
and plane.
See also Section~\ref{sec:EL:STRUCT:JOINT:PLANE_DISPLACEMENT}.
\begin{verbatim}
    <joint_type> ::= plane displacement pin
    <joint_arglist> ::= 
        <node> , (Vec3) <relative_offset>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix> ] ,
        (Vec3) <absolute_pin_position>
        [ , hinge , 
            (OrientationMatrix) <absolute_pin_orientation_matrix> ]
\end{verbatim}
\emph{Note: this element is temporarily disabled;
combine an \kw{in plane} and a
\hyperref{\kw{revolute rotation}}{\kw{revolute rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_ROTATION}
joint instead, using a grounded node.}


\subsection{Plane hinge}
This joint has been renamed
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE};
the old name has been deprecated and its support may be discontinued
in future versions.

\subsection{Plane pin}
This joint has been renamed
\hyperref{\kw{revolute pin}}{\kw{revolute pin} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_PIN};
the old name has been deprecated and its support may be discontinued
in future versions.

\subsection{Prismatic}
This joints constraints the relative orientation of two nodes, so that
their orientations remain parallel.
The relative position is not constrained.
The initial orientation of the joint must be
compatible: use the \kw{hinge} keyword to assign 
the joint initial orientation.
\begin{verbatim}
    <joint_type> ::= prismatic
    <joint_arglist> ::= 
        <node_1>
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> 
        [ , hinge , (OrientationMatrix) <relative_orientation_matrix_2> ] ,    
\end{verbatim}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the relative orientation of the joint
with respect to node 1 is reset;
\item \kw{hinge\{2\}} the relative orientation of the joint
with respect to node 2 is reset;
\end{itemize}

\subsection{Revolute hinge}
\label{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE}
This joint only allows the relative rotation of two nodes about
a given axis, which is axis 3 in the reference systems defined 
by the two \kw{hinge} statements.
\begin{verbatim}
    <joint_type> ::= revolute hinge
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
        [ , initial theta , <initial_theta> ]
        [ , friction , <average_radius> , 
                   [ preload , <const_value> , ]
                   <friction_model> , 
                   <shape_function> ]
\end{verbatim}

\emph{Note: this element can be thought of as the combination of a 
\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE},
that constrains the three components of the relative position
of the nodes, and of a
\hyperref{\kw{revolute rotation}}{\kw{revolute rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_ROTATION},
that constrains the relative orientation of the nodes so that only rotation
about a common axis is allowed.}

\subsubsection{Rationale}
The rationale for having two statements to indicate the position
and orientation of the same entity is that the joint is supposed
to constrain the position and orientation of two points,
each attached to a node.
This is what is typically known from the geometry of the components
of a mechanism.

\subsubsection{Output}
The output occurs in the \kw{.jnt} file, according to default joint output
for the first 13 columns; specific columns contain:
\begin{itemize}
\item columns 14--16: the so-called \emph{Euler} angles (in degrees)
	that describe the relative rotation; only the third component
	is relevant, the first two essentially indicate the accuracy
	of the rotation constraint;
\item column 17--19: the relative angular velocity;
\end{itemize}
If friction is present:
\begin{itemize}
\item column 20: the friction moment about the revolute axis;
\item subsequent columns: any friction model specific data.
\end{itemize}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rz"} relative rotation angle about revolute axis
\item \kw{"wz"} relative angular velocity about revolute axis
\item \kw{"Fx"} constraint reaction force in node 1 local direction 1
\item \kw{"Fy"} constraint reaction force in node 1 local direction 2
\item \kw{"Fz"} constraint reaction force in node 1 local direction 3
\item \kw{"Mx"} constraint reaction moment about node 1 local direction 1
\item \kw{"My"} constraint reaction moment about node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment about node 1 local direction 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the relative orientation of the joint
with respect to node 1 is reset;
\item \kw{hinge\{2\}} the relative orientation of the joint
with respect to node 2 is reset;
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset;
\item unrecognized hints are passed through to the friction model,
if any.
\end{itemize}




\subsection{Revolute pin}
\label{sec:EL:STRUCT:JOINT:REVOLUTE_PIN}
This joint only allows the absolute rotation of a node about
a given axis, which is axis 3 in the reference systems defined 
by the two \kw{hinge} statements.
\begin{verbatim}
    <joint_type> ::= revolute pin
    <joint_arglist> ::= 
        <node> , (Vec3) <relative_offset>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix> ] ,
        (Vec3) <absolute_pin_position>
        [ , hinge , 
            (OrientationMatrix) <absolute_pin_orientation_matrix> ]
        [ , initial theta , <initial_theta> ]
\end{verbatim}
{\em
Note: this is equivalent to a
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE}
when one node is grounded.
}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rz"} relative rotation angle about revolute axis
\item \kw{"wz"} relative angular velocity about revolute axis
\item \kw{"Fx"} constraint reaction force in node 1 local direction 1
\item \kw{"Fy"} constraint reaction force in node 1 local direction 2
\item \kw{"Fz"} constraint reaction force in node 1 local direction 3
\item \kw{"Mx"} constraint reaction moment about node 1 local direction 1
\item \kw{"My"} constraint reaction moment about node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment about node 1 local direction 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the relative orientation of the joint
with respect to the node is reset;
\item \kw{hinge\{0\}} the relative orientation of the joint
with respect to the absolute frame is reset;
\item \kw{offset\{1\}} the offset of the joint
with respect to the node is reset;
\item \kw{offset\{0\}} the offset of the joint
with respect to the absolute frame is reset;
\end{itemize}






\subsection{Revolute rotation}
\label{sec:EL:STRUCT:JOINT:REVOLUTE_ROTATION}
This joint allows the relative rotation of two nodes about
a given axis, which is axis 3 in the reference systems defined 
by the two \kw{hinge} statements.
The relative position is not constrained.
\begin{verbatim}
    <joint_type> ::= revolute rotation
    <joint_arglist> ::= 
        <node_1>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
\end{verbatim}

\subsubsection{Rationale}
A revolute joint without position constraints; this joint, in conjunction
with an \kw{inline} joint, should be used to constrain, for example,
the two nodes of a hydraulic actuator.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"rz"} relative rotation angle about revolute axis
\item \kw{"wz"} relative angular velocity about revolute axis
\item \kw{"Mx"} constraint reaction moment about node 1 local direction 1
\item \kw{"My"} constraint reaction moment about node 1 local direction 2
\item \kw{"Mz"} constraint reaction moment about node 1 local direction 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{hinge\{1\}} the relative orientation of the joint
with respect to node 1 is reset;
\item \kw{hinge\{2\}} the relative orientation of the joint
with respect to node 2 is reset;
\end{itemize}





\subsection{Rod}\label{sec:EL:STRUCT:JOINT:ROD}
The \kw{rod} element represents a force between two nodes that depends
on the relative position and velocity of two points, each rigidly attached
to a \htmlref{\kw{structural node}}{sec:NODE:STRUCTURAL}.
The direction of the force is also based on the relative position
of the points: it is the line that passes through them.
If no offset is defined, the points are the nodes themselves.

The syntax is:
\begin{verbatim}
    <joint_type> ::= rod 
    <joint_arglist> ::=
        <node_1> ,
            [ position , <relative_offset_1> , ]
        <node_2> , 
            [ position , <relative_offset_2> , ]
        (scalar) { <rod_length> | from nodes }
        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
Note: an alternative obsolete syntax is:
\begin{verbatim}
    <joint_type> ::= rod 
    <joint_arglist> ::=
        <node_1> , <node_2> , 
        (scalar) { <rod_length> | from nodes }
        [ , offset , (Vec3) <relative_offset_1> , 
                     (Vec3) <relative_offset_2> ] ,
        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
It will probably be discontinued.
See also
the \htmlref{\kw{rod with offset}}{sec:EL:STRUCT:JOINT:ROD_WITH_OFFSET}
element.

The constitutive law \kw{const\_law} receives as input the rod axial strain
\begin{equation}
	\varepsilon = \frac{l - l_0}{l_0} ,
\end{equation}
where $l_0=\kw{rod\_length}$ and $l$ is the distance between the two nodes,
and, in case of viscoelastic constitutive law, the axial strain derivative
\begin{equation}
	\dot{\varepsilon} = \frac{\dot{l}}{l_0} .
\end{equation}
It returns the corresponding rod axial force,
\begin{displaymath}
	F = F\plbr{\frac{l - l_0}{l_0}, \frac{\dot{l}}{l_0}} .
\end{displaymath}
If a \kw{prestrain} $\varepsilon_p$ is defined,
it consists in an imposed value of the axial strain
that is subtracted from the geometrical strain
before being passed to the constitutive law;
if a \kw{prestress} $F_p$ is defined,
it consists in an imposed axial force value
that is added to the one obtained from the constitutive law,
namely
\begin{displaymath}
	% F = F_p + F\plbr{\frac{l - l_0}{l_0} - \varepsilon_p, \frac{\dot{l}}{l_0} - \dot{\varepsilon}_p} .
	F = F_p + F\plbr{\frac{l - l_0}{l_0} - \varepsilon_p, \frac{\dot{l}}{l_0}} .
\end{displaymath}
% FIXME: - \dot{\varepsilon}_p is not currently implemented

For example, a linear elastic constitutive law for the rod element
is defined as
\begin{displaymath}
	F = EA \frac{l - l_0}{l_0} ,
\end{displaymath}
where $EA$ is the axial stiffness of the rod.

For further details on the supported constitutive laws, 
see Section~\ref{sec:CONSTITUTIVE-LAWS}.
If the optional \kw{offset} keyword is used, the element falls through
to the more general \kw{rod with offset};
see also \kw{rod with offset}
in Section~\ref{sec:EL:STRUCT:JOINT:ROD_WITH_OFFSET}.

\subsubsection{Output}
The output occurs in the \kw{.jnt} file, which contains:
\begin{itemize}
\item the label
\item the three components of the internal force in the reference frame
of the element (column 2, component $x$, contains the force)
\item the three components of the internal moment in the reference frame
of the element (always zero)
\item the three components of the internal force in the global
reference frame
\item the three components of the internal moment in the global
reference frame (always zero)
\item the length of the rod
\item the three components of the rod axis in the global reference frame
(a unit vector)
\item the length rate of the rod (derivative of length wrt/ time)
\item optional data appended by the constitutive law
\end{itemize}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"F"} constraint force between the two nodes/connection points
\item \kw{"L"} distance between the two nodes/connection points
\item \kw{"LPrime"} distance rate between the two nodes/connection points
\end{enumerate}
The rod joint can also access the private data provided 
by the constitutive law.
It is accessed by prefixing the name of the data with the string
\kw{"constitutiveLaw."}; see the specific constitutive law
description of the available data in Section~\ref{sec:CONSTITUTIVE-LAWS}.





\subsection{Rod with offset}
\label{sec:EL:STRUCT:JOINT:ROD_WITH_OFFSET}
The syntax is:
\begin{verbatim}
    <joint_type> ::= rod with offset
    <joint_arglist> ::= <node_1> , (Vec3) <relative_offset_1>
                        <node_2> , (Vec3) <relative_offset_2>
        (scalar) { <rod_length> | from nodes } ,
        (ConstitutiveLaw1D) <const_law>
\end{verbatim}
Analogous to the \kw{rod} joint with the optional arg \kw{offset};
see Section~\ref{sec:EL:STRUCT:JOINT:ROD} for details.



\subsection{Spherical hinge}
\label{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}
This joint constrains the relative position of two nodes;
the relative orientation is not constrained.
\begin{verbatim}
    <joint_type> ::= spherical hinge
    <joint_arglist> ::= 
        <node_1> , (Vec3) <relative_offset_1> 
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_1> ] ,
        <node_2> , (Vec3) <relative_offset_2>
        [ , hinge , 
            (OrientationMatrix) <relative_orientation_matrix_2> ]
\end{verbatim}
Note: the orientation matrix, set by means of the \kw{hinge} keyword,
is used for output purposes only. 
A default identity matrix is assumed.

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset;
\end{itemize}

\subsection{Spherical pin}
This joint constrains the absolute position of a node;
the relative orientation is not constrained.
\begin{verbatim}
    <joint_type> ::= spherical pin
    <joint_arglist> ::= <node> , (Vec3) <relative_offset> ,
                                 (Vec3) <absolute_pin_position>
\end{verbatim}
{\em
	Note: this is equivalent to a
	\hyperref{\kw{spherical hinge}}{\kw{spherical hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:SPHERICAL_HINGE}
	when one node is grounded.
	An alternative way to model a grounded spherical hinge requires
	the use of a static, clamped node.
}

\subsection{Total joint}
\label{sec:EL:STRUCT:JOINT:TOTAL_JOINT}
\emph{Original implementation: Alessandro Fumagalli; \\
Review: Pierangelo Masarati.}

This element allows to arbitrarily constrain specific components
of the relative position and orientation of two nodes.
The value of the constrained components of the relative position
and orientation can be imposed by means of drives.
As such, this element allows to mimic the behavior of most
ideal constraints that connect two nodes.
\begin{verbatim}
    <joint_type> ::= total joint
    <joint_arglist> ::=
        <node1> , [ position , ] (Vec3) <relative_offset>
        [ , position orientation , (Mat3x3) <relative_position_orientation> ]
        [ , rotation orientation , (Mat3x3) <relative_rotation_orientation> ]
        , <node2> , [ position , ] (Vec3) <relative_offset>
        [ , position orientation , (Mat3x3) <relative_position_orientation> ]
        [ , rotation orientation , (Mat3x3) <relative_rotation_orientation> ]
        [ , position constraint ,
            { active | inactive | <status> } ,
            { active | inactive | <status> } ,
            { active | inactive | <status> } ,
            (Vec3_tpl_drive_caller) <imposed_relative_position> ]
        [ , orientation constraint ,
            { active | inactive | <status> } ,
            { active | inactive | <status> } ,
            { active | inactive | <status> } ,
            (Vec3_tpl_drive_caller) <imposed_relative_rotation> ]
\end{verbatim}
The relative position imposed by the \kw{position constraint}
is imposed in a reference frame rigidly attached to the first node,
in the optional offset \kw{relative\_offset},
and optionally further oriented by the \kw{relative\_position\_orientation}
matrix.

The relative orientation imposed by the \kw{orientation constraint}
is imposed in a reference frame rigidly attached to the first node,
optionally further oriented by the \kw{relative\_rotation\_orientation}
matrix.
It consists in the Euler vector that expresses
the imposed relative orientation, in radian.

The keyword \kw{active} means that the constraint is active
with respect to that component of relative motion,
so the related motion component is constrained,
while \kw{inactive} means that the constraint is not active
with respect of that component of relative motion,
so the related motion component is not constrained.
Otherwise, a boolean can be provided in \kw{status} to indicate
that the degree of constraint is either inactive (0) or active (1);
this may be useful, for instance, to make constraint activation
conditional in parametric input files.
The same applies to the status of the components of the impose orientation.

If a component of relative position or orientation is active,
the corresponding component of the imposed position or orientation
is enforced, otherwise it is ignored;
however, the complete three-dimensional vectors of the imposed relative
position or orientation must be provided.

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"px"} relative position along node 1 position orientation axis 1
\item \kw{"py"} relative position along node 1 position orientation axis 2
\item \kw{"pz"} relative position along node 1 position orientation axis 3
\item \kw{"rx"} relative orientation about node 1 rotation orientation axis 1
\item \kw{"ry"} relative orientation about node 1 rotation orientation axis 2
\item \kw{"rz"} relative orientation about node 1 rotation orientation axis 3
\item \kw{"Fx"} reaction force about node 1 position orientation axis 1
\item \kw{"Fy"} reaction force about node 1 position orientation axis 2
\item \kw{"Fz"} reaction force about node 1 position orientation axis 3
\item \kw{"Mx"} reaction moment about node 1 rotation orientation axis 1
\item \kw{"My"} reaction moment about node 1 rotation orientation axis 2
\item \kw{"Mz"} reaction moment about node 1 rotation orientation axis 3
\item \kw{"dx"} imposed relative position along node 1 position orientation axis 1
\item \kw{"dy"} imposed relative position along node 1 position orientation axis 2
\item \kw{"dz"} imposed relative position along node 1 position orientation axis 3
\item \kw{"tx"} imposed relative orientation about node 1 rotation orientation axis 1
\item \kw{"ty"} imposed relative orientation about node 1 rotation orientation axis 2
\item \kw{"tz"} imposed relative orientation about node 1 rotation orientation axis 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to node 1 is reset;
\item \kw{offset\{2\}} the offset of the joint
with respect to node 2 is reset;
\item \kw{position-hinge\{1\}} the relative orientation
of the relative position constraint with respect to node 1 is reset;
\item \kw{position-hinge\{2\}} the relative orientation 
of the relative position constraint with respect to node 2 is reset;
\item \kw{orientation-hinge\{1\}} the relative orientation
of the relative orientation constraint with respect to node 1 is reset;
\item \kw{orientation-hinge\{2\}} the relative orientation 
of the relative orientation constraint with respect to node 2 is reset;
\item \kw{position-drive3} resets the relative position drive;
the hint is passed to the Vec3 drive hint parser.
\item \kw{orientation-drive3} resets the relative orientation drive;
the hint is passed to the Vec3 drive hint parser.
\end{itemize}



\subsection{Total pin joint}
This element allows to arbitrarily constrain specific components
of the absolute position and orientation of a node.
The value of the constrained components of the absolute position
and orientation can be imposed by means of drives.
As such, this element allows to mimic the behavior of most
ideal constraints that ground one node.
\label{sec:EL:STRUCT:JOINT:TOTAL_PIN_JOINT}
\begin{verbatim}
    <joint_type> ::= total pin joint
    <joint_arglist> ::=
        <node> , [ position , ] (Vec3) <relative_offset>
        [ , position orientation , (Mat3x3) <relative_position_orientation> ]
        [ , rotation orientation , (Mat3x3) <relative_rotation_orientation> ]
        , [ position , ] (Vec3) <absolute position>
        [ , position orientation , (Mat3x3) <absolute_position_orientation> ]
        [ , rotation orientation , (Mat3x3) <absolute_rotation_orientation> ]
        [ , position constraint ,
            { active | inactive } ,
            { active | inactive } ,
            { active | inactive } ,
            (Vec3_tpl_drive_caller) <imposed_absolute_position> ]
        [ , orientation constraint ,
            { active | inactive } ,
            { active | inactive } ,
            { active | inactive } ,
            (Vec3_tpl_drive_caller) <imposed_absolute_rotation> ]
\end{verbatim}

\subsubsection{Private Data}
The following data is available:
\begin{enumerate}
\item \kw{"px"} absolute position along absolute position orientation axis 1
\item \kw{"py"} absolute position along absolute position orientation axis 2
\item \kw{"pz"} absolute position along absolute position orientation axis 3
\item \kw{"rx"} absolute orientation about absolute rotation orientation axis 1
\item \kw{"ry"} absolute orientation about absolute rotation orientation axis 2
\item \kw{"rz"} absolute orientation about absolute rotation orientation axis 3
\item \kw{"Fx"} reaction force about absolute position orientation axis 1
\item \kw{"Fy"} reaction force about absolute position orientation axis 2
\item \kw{"Fz"} reaction force about absolute position orientation axis 3
\item \kw{"Mx"} reaction moment about absolute rotation orientation axis 1
\item \kw{"My"} reaction moment about absolute rotation orientation axis 2
\item \kw{"Mz"} reaction moment about absolute rotation orientation axis 3
\item \kw{"dx"} imposed absolute position along absolute position orientation axis 1
\item \kw{"dy"} imposed absolute position along absolute position orientation axis 2
\item \kw{"dz"} imposed absolute position along absolute position orientation axis 3
\item \kw{"tx"} imposed absolute orientation about absolute rotation orientation axis 1
\item \kw{"ty"} imposed absolute orientation about absolute rotation orientation axis 2
\item \kw{"tz"} imposed absolute orientation about absolute rotation orientation axis 3
\end{enumerate}

\subsubsection{Hints}
When wrapped by a \kw{driven} element, the following hints are honored:
\begin{itemize}
\item \kw{offset\{1\}} the offset of the joint
with respect to the node is reset;
\item \kw{offset\{0\}} the absolute position of the joint
is reset;
\item \kw{position-hinge\{1\}} the relative orientation
of the absolute position constraint with respect to the node is reset;
\item \kw{position-hinge\{0\}} the absolute orientation 
of the absolute position constraint is reset;
\item \kw{orientation-hinge\{1\}} the relative orientation
of the absolute orientation constraint with respect to the node is reset;
\item \kw{orientation-hinge\{0\}} the absolute orientation 
of the absolute orientation constraint is reset;
\item \kw{position-drive3} resets the absolute position drive;
the hint is passed to the Vec3 drive hint parser.
\item \kw{orientation-drive3} resets the absolute orientation drive;
the hint is passed to the Vec3 drive hint parser.
\end{itemize}




\subsection{Universal hinge}
\label{sec:EL:STRUCT:JOINT:UNIVERSAL_HINGE}
Deprecated in favour of the
\hyperref{\kw{cardano hinge}}{\kw{cardano hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_HINGE}.



\subsection{Universal pin}
\label{sec:EL:STRUCT:JOINT:UNIVERSAL_PIN}
Deprecated in favour of the
\hyperref{\kw{cardano pin}}{\kw{cardano pin} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_PIN}.



\subsection{Universal rotation}
\label{sec:EL:STRUCT:JOINT:UNIVERSAL_ROTATION}
Deprecated in favour of the
\hyperref{\kw{cardano rotation}}{\kw{cardano rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:CARDANO_ROTATION}.

\subsection{Viscous body}
\label{sec:EL:STRUCT:JOINT:VISCOUS_BODY}
\begin{verbatim}
    <joint_type> ::= viscous body
    <joint_arglist> ::=
        <node> ,
            [ position , ] (Vec3)<relative_offset> ,
            [ orientation, (Mat3x3)<relative_orientation> , ]
            (ConstitutiveLaw6D) <const_law>
\end{verbatim}
This element defines a force and a moment that depend on the absolute 
linear and angular velocity of a body, projected in the reference frame
of the node itself.
The force and moment are defined as a 6D viscous constitutive law.



\section{Joint Regularization}
The \kw{joint regularization} element is used to modify
algebraic constraint equations in order to improve ill-conditioned
problems.
\begin{comment}
%%% TODO
\begin{verbatim}
    <card> ::= <element_type> : <label> , <type> [ , <data> ] ;
    <element_type> ::= joint regularization
    <type> ::= { tikhonov | dynamic }
    <data> ::= { <coef> | list , <coef_1> [ , ... ] }
\end{verbatim}
\end{comment}
\begin{verbatim}
    <card> ::= <element_type> : <label> , <type> [ , <data> ] ;
    <element_type> ::= joint regularization
    <type> ::= tikhonov
    <data> ::= { <coef> | list , <coef_1> [ , ... ] }
\end{verbatim}
An element is instantiated, which requires
an underlying algebraic constraint ( a \kw{joint} element)
with the same label to exist.
In that case, the algebraic constraint equations are modified
in order to regularize the problem.
The \kw{joint} that is to be regularized must exist,
and it must have internal states.
If the keyword \kw{list} is used, the coefficients for each internal state
is expected; the number of coefficients is determined by the joint.

\subsection{Tikhonov}
The \kw{tikhonov} joint regularization type consists in modifying
a constraint, expressed by an algebraic equation $\T{\Phi}\plbr{\T{x}, t}$
and the corresponding Lagrangian multipliers $\T{\lambda}$, namely
\begin{align}
	\plbr{\T{\Phi}_{/\T{x}}^T \T{\lambda}}_{/\T{x}} \Delta\T{x}
	+ \T{\Phi}_{/\T{x}}^T \Delta\T{\lambda}
		&= \T{F} - \T{\Phi}_{/\T{x}}^T \T{\lambda} \\
	\T{\Phi}_{/\T{x}} \Delta\T{x} &= - \T{\Phi}\plbr{\T{x}, t}
\end{align}
by adding the multipliers to the constraint equation,
weighed by the coefficient \kw{coef} (or by the list of coefficients
\kw{coef\_i}, in case different coefficients are given):
\begin{align}
	\plbr{\T{\Phi}_{/\T{x}}^T \T{\lambda}}_{/\T{x}} \Delta\T{x}
	+ \T{\Phi}_{/\T{x}}^T \Delta\T{\lambda}
	&= \T{F} - \T{\Phi}_{/\T{x}}^T \T{\lambda} \\
	\T{\Phi}_{/\T{x}} \Delta\T{x}
	- \mathtt{<coef>} \cdot \Delta\T{\lambda}
	&= - \T{\Phi}\plbr{\T{x}, t} + \mathtt{<coef>} \cdot \T{\lambda}
\end{align}
The Tikhonov regularization allows the constraint to be violated
by an amount that depends on the multipliers.
In this sense, the coefficient \kw{coef} should be considered
sort of a compliance: the larger the coefficient,
the larger the constraint violation for a given value
of the reaction $\T{\lambda}$.

\begin{comment}
%%% TODO
\subsection{Dynamic}
The \kw{dynamic} regularization differs from that of Tikhonov
by the fact that the multiplers are intended as dynamical quantities
whose value varies, during the Newton-like iterations occurring
for the solution of the nonlinear problem, according to a pseudo-time.
As a consequence, the matrix condition is improved, but the equations,
at convergence, are not modified.

The equations become
\begin{align}
	\plbr{\T{\Phi}_{/\T{x}}^T \T{\lambda}}_{/\T{x}} \Delta\T{x}
	+ \T{\Phi}_{/\T{x}}^T \Delta\T{\lambda}
	&= \T{F} - \T{\Phi}_{/\T{x}}^T \T{\lambda} \\
	\T{\Phi}_{/\T{x}} \Delta\T{x}
	- \mathtt{<coef>} \cdot \Delta \T{\lambda}
	&= - \T{\Phi}\plbr{\T{x}, t} + \mathtt{<coef>} \cdot \Delta\T{\lambda}
\end{align}
so at convergence, when $\Delta\T{x}$ and $\Delta\T{\lambda}$ vanish,
the constraint equation is unmodified.
The pseudo-dynamics of the multiplier is added to the constraint equation
by using the $\Delta\T{\lambda}$ at the previous iteration
in the right hand-side of the above equation.
\end{comment}


\section{Loadable Element}\label{sec:EL:BASE:LOADABLE}
The \kw{loadable} element is a wrapper for a user-defined element that is
compiled in a separated module and linked run-time.
The module should provide a comprehensive set of functions with a specified
API; default functions are available if no special features are required.
Implementation of modules can be very easy, but a deep knowledge of the
internals of the code is required if special tasks are required. 
There are virtually no limits on what a loadable element can do.
The syntax is simply:
\begin{verbatim}
    <normal_arglist> ::= " <module_name> "
        [ , name, " <calls> " ] 
        [ , <module_data> ]
\end{verbatim}
where \kw{module\_name} is the name of the module file; as soon as the file
is checked and the binding of the structure with function bindings 
succeeded, a function called \kw{read} is invoked, and passed the input
stream.
This function is in charge of reading \kw{module\_data} following the
general syntax of the input file.

An alternative form is
\begin{verbatim}
    <normal_arglist> ::= reference , " <name> "
        [ , <module_data> ]
\end{verbatim}
where \kw{name} is the name by which the loadable element recorded itself
when registered via the \kw{module load} directive, as described
in Section~\ref{sec:GENERAL:MODULE-LOAD}.
As a consequence, the following forms are equivalent:
\begin{verbatim}
    # direct runtime loading
    loadable: 1, "/some/module.so";
    # "/some/module.so" registers itself as "some_module"
    module load: "/some/module.so";
    loadable: 2, reference, "some_module";
    # works also as joint (might obsolete loadable elements)
    joint: 3, some_module;
\end{verbatim}

It is advisable that the function \kw{read} prints some help message
when the first field of \kw{module\_data} is the keyword \kw{help}.
All the helpers and the high-level structures are available, such as
drivers, constitutive laws, reference frames.
Refer to each module for a description (if available) of the features and of
the input/output format.
\kw{module\_name} should be a full path to the module function.
If the name starts with a slash ``/'', the full path name is used.
Otherwise the module is searched in the colon-separated list of directories 
contained in the environment variable \kw{LD\_LIBRARY}, then among the
libraries listed in \kw{/etc/ld.so.cache}, and finally in
\kw{/usr/lib} and in \kw{/lib} (see \kw{dlopen(3)}).
At last, it is searched in the current directory, and the extension
\kw{.so} is added if missing.
The string \kw{calls} represents the name of the structure that contains
the bindings to the functions.
The default is \kw{calls}.

\noindent
Refer to \kw{\$(BASE)/mbdyn/base/loadable.h} for a description of the
functions that are allowed.
An example module is given in directory
\begin{verbatim}
    $(BASE)/modules/module-template/
\end{verbatim}
which can be used as a starting point for building a custom module.
% An analogous C/FORTRAN style interface is being planned, at the cost of
% possibly losing some of the fancy C++ features made available by the code.
The \kw{loadable element} interface allows to link modules in different
languages, e.g.\ C or FORTRAN77; simply use \kw{module-template}
as a guideline to providing callbacks to the \kw{loadable element}
interface and to collect required info from the main program
(e.g.\ node positions, equation indices and everything else that is
required for appropriate connection), then call the functions that
actually do the work in other languages from inside the callbacks.
Note that, in general, to call external functions from C++ one needs
to declare them as
\begin{verbatim}
    #include <sys/types.h>
    extern "C" {
        int a_C_function(int arg, double darg);
        int a_F77_subroutine(int32_t *iarg, double *darg);
    }
\end{verbatim}
The same applies to FORTRAN 77 functions; only, the naming convention
usually is compiler dependent; some compilers turn all the names to 
uppercase or lowercase (remember that FORTRAN 77 is case insensitive);
other compilers add underscores at the beginning or at the end of the
names.
Check what is the behavior of your compiler, by compiling a simple 
program with your favorite FORTRAN 77 compiler, then looking at it
with the utility \kw{nm(1)}, which will show how the symbols are represented 
internally.

\noindent
For instance, the code
\begin{verbatim}
C This is a compiler test
      SUBROUTINE F77SUB(I, D)
      INTEGER*4 I
      REAL*8 D(*)

      D(I) = 0.0

      END
\end{verbatim}
when compiled with \kw{g77(1)} on a GNU/Linux system, yields:
\begin{verbatim}
[masarati@mbdyn manual]$ g77 -c f77sub.f
[masarati@mbdyn manual]$ nm f77sub.o
00000000 T f77sub_
\end{verbatim}
That is, \kw{g77(1)} lowercases all symbols, and adds a trailing 
underscore.
Macros to automatically detect and take care of this behavior 
will be added.


\noindent
To compile loadable modules, one needs to configure
the package as follows:
\begin{verbatim}
    ./configure --with-module=<module_name>
\end{verbatim}
where \kw{module\_name} is the name of the directory the module
is placed in with the \kw{module-} part stripped; e.g.\ to compile
the tire module that resides in \kw{\$(BASE)/modules/module-wheel2} 
one must type
\begin{verbatim}
    ./configure --with-module=wheel2
\end{verbatim}
Multiple modules can be compiled by typing the list of the names
separated by blanks.
The modules need to resolve some of the symbols that are in the
main executable; until a full working libtool support is implemented,
this must be done by hand.
For the \kw{g++(1)} compiler one requires the switch \kw{-rdynamic} 
to be added to the loader flags, e.g.
\begin{verbatim}
    LDFLAGS="-rdynamic" ./configure --with-module=<module_name>
\end{verbatim}
with \kw{sh(1)} and compatible shells like \kw{bash(1)}, or
\begin{verbatim}
    env LDFLAGS="-rdynamic" ./configure --with-module=<module_name>
\end{verbatim}
with \kw{csh(1)} and compatible shells.





\section{Output Elements}
Output elements take care of inter-process communication.
These elements can use specific communication means,
depending on the type of simulation they are used for,
and can communicate specific types of data.

\subsection{Stream output}\label{sec:EL:OUTELEM:STREAM_OUTPUT}
This is a special element which takes care of sending output
to external processes by means of either \kw{local} or \kw{inet} sockets
during batch or real-time simulations.
This topic is under development, so expect frequent changes, and
please do not count too much on backward compatibility.

The syntax is:
\begin{verbatim}
    <elem_type> ::= stream output

    <arglist> ::=
        stream name , " <stream_name> " ,
        create , { yes | no } ,
        [ { local , " <socket_name> " , |
            [ port , <port_number> , ]
            [ host , " <host_name> " , ] } ]
        [ { [ no ] signal
            | [ non ] blocking
            | [ no ] send first
            | [ do not ] abort if broken } [ , ... ] , ]
        [ output every, <steps> , ]
        [ echo , <file_name>
            [ , precision , <precision> ]
            [ , shift , <shift> ] , ]
        <content>
\end{verbatim}
The stream output allows MBDyn to send streamed outputs 
to remote processes during both batch and real-time simulations,
using sockets either in the \kw{local} or in the \kw{inet} namespace.
If the simulation is run in real-time using RTAI, RTAI mailboxes
are used instead.

\begin{itemize}
\item \kw{stream\_name} is the name of the RTAI mailbox where 
the output is written  (a unique string no more than six characters long);
it is basically ignored by the \kw{stream output} element
except when using RTAI;

\item the \kw{create} keyword determines whether the socket
must be created or looked-up as already existing on the system;
if \kw{create} is set to \kw{no}, MBDyn will retry for 60 seconds
and then give up;

\item \kw{socket\_name} is the path of the \kw{local} socket 
that is used to communicate between processes;

\item \kw{port} is the port number to be used with a \kw{inet} socket.
The default port number is 9011 (intentionally unassigned by IANA).
If no \kw{host\_name} is given, \kw{localhost} will be used;

\item \kw{host\_name} is the name or the IP of the remote host where
the mailbox resides; note that if this field is given, \kw{create} must
be set to \kw{no}.
The simulation will not start until the socket is created on the remote host;

\item the flag \kw{no signal} requests that no \kw{SIGPIPE} be raised
when sending through a socket when the other end is broken
(by default, \kw{SIGPIPE} is raised);

\item the flag \kw{non blocking} requests that operations on the socket
do not block (or block, in case of \kw{blocking}, the default);

\item the flag \kw{no send first} requests that no send occurs before
the first time step (by default, data is always sent);

\item the flag \kw{do not abort if broken} requests that the simulation
continues in case the connection breaks.
No further data send will occur for the duration of the simulation
(the default);

\item the field \kw{output every} requests output to occur
only every \kw{steps};

\item the field \kw{echo} causes the content that is sent to the peer
to be echoed on file \kw{file\_name}; the optional parameter \kw{precision}
determines the number of digits used in the output; the optional parameter
\kw{shift} is currently unused;

\item the field \kw{content} is detailed in the next section.
\end{itemize}
This element, when used with the \kw{motion} content type,
obsoletes the \kw{stream motion output} element
(see Section~\ref{sec:EL:OUTELEM:STREAM_MOTION_OUTPUT}).
When the simulation is executed in real-time using RTAI,
this element obsoletes the \kw{RTAI output} element
(see Section~\ref{sec:EL:OUTELEM:RTAI_out}).



\subsubsection{Streamed output}
Different types of data can be sent.
The most general form is called \kw{values}, consisting
in an arbitrary set of independent scalar channels.
A form specifically intended to communicate the motion
of a mechanical system is called \kw{motion}, consisting
in a subset of the kinematics of a set of structural nodes:
\begin{verbatim}
    <content> ::= { <values> | <motion> }

    <values> ::= [ values , ]
        <channel_number> ,
            <value>
            [ , ... ]

    <value> ::= {
        [ nodedof , ] (node_dof) <output_dof>
        | drive , (DriveCaller) <drive_data>
    }

    <motion> ::= motion ,
        [ output flags ,
            { position
            | orientation matrix
            | orientation matrix transpose
            | velocity
            | angular velocity } [ , ... ] , ]
        { all | <struct_node_label> [ , ... ] }
\end{verbatim}
where
\begin{itemize}
\item the (optional) keyword \kw{values} indicates that a set
of independent scalar channels is output by the element;

\item the number of channels \kw{channel\_number} that are written
determines how many \kw{value} entries must be read.
In case of \kw{node\_dof} (the default, deprecated),
they must be valid scalar dof entries, which can be connected
in many ways to nodal degrees of freedom;
in case of \kw{drive\_data}, they can be arbitrary functions,
including node or element private data;

\item the keyword \kw{motion} indicates that a subset of the kinematic
parameters of a set of structural nodes is output by the element.
As opposed to the \kw{values} case, which is intended for generic
interprocess communication output, this content type is intended to ease
and optimize the output of the motion of structural nodes,
to be used for on-line visualization purposes.
By default, only the position of the selected nodes is sent.
This is intended for interoperability with a development version
of EasyAnim which can read the motion info (the so-called ``van'' file)
from a stream.
The optional keyword \kw{output flags} allows to request the output
of specific node kinematics: the node position, orientation matrix
(either row- or column-major), the velocity and the angular velocity.
The default is equivalent to \kw{output flags, position}.
\end{itemize}



\subsubsection{Non real-time simulation}
During non real-time simulations, streams operate in blocking mode.
The meaning of the parameters is:
\begin{itemize}
\item \kw{stream\_name} indicates the name the stream would be known as
by RTAI; it must be no more than 6 characters long, and mostly useless;

\item the instruction \kw{create} determines whether MBDyn will create
the socket, or try to connect to an existing one;

\item the keyword \kw{local} indicates that a socket 
in the local namespace will be used; if \kw{create} is set to \kw{yes},
the socket is created, otherwise it must exist.

\item either of the keywords \kw{port} or \kw{host} indicate that a socket
in the internet namespace will be used;

if \kw{create} is set to \kw{yes}, \kw{host\_name} indicates 
the host that is allowed to connect to the socket; it defaults 
to any host (\kw{0.0.0.0}); if \kw{create} is set to \kw{no},
\kw{host\_name} indicates what host to connect to; the default 
is localhost (\kw{127.0.0.1}); the default port is \kw{9011}
(intentionally unassigned by IANA);

\item the flag \kw{no signal} is honored;

\item the flag \kw{non blocking} is honored;

\item the flag \kw{no send first} is honored;

\item the flag \kw{do not abort if broken} is honored.
\end{itemize}
If no socket type is specified, i.e.\ none of the \kw{local}, \kw{port} 
and \kw{host} keywords are given, a socket is opened by default 
in the internet namespace with the default IP and port; the \kw{create}
keyword is mandatory.



\subsubsection{Real-time simulation}
During real-time simulations, streams wrap non-blocking RTAI mailboxes.
The meaning of the parameters is:
\begin{itemize}
\item the parameter \kw{stream\_name} indicates the name the stream
will be known as in RTAI's resource namespace; it must be exactly 6 characters long;

\item the instruction \kw{create} determines whether the mailbox will be
created or looked for by MBDyn;

\item the keyword \kw{local} is ignored;

\item the keyword \kw{host} indicates that a mailbox on a remote host 
will be used; it is useless when \kw{create} is set to \kw{yes}, because
RTAI does not provide the possibility to create remote resources;
if none is given, a local mailbox is assumed;

\item the keyword \kw{port} is ignored.

\item the flag \kw{no signal} is ignored;

\item the flag \kw{non blocking} is honored; however, blocking mailboxes
make little sense, and real-time synchronization using RTAI should not rely
on blocking mailboxes;

\item the flag \kw{no send first} is ignored (although it should be honored
when the mailbox is blocking);

\item the flag \kw{do not abort if broken} is ignored;
the program is always terminated if a mailbox is no longer available.
\end{itemize}





\subsection{RTAI output}\label{sec:EL:OUTELEM:RTAI_out}
This element is actually used only when the simulation is scheduled
using RTAI; otherwise, the corresponding \kw{stream output} element
is used (see Section~\ref{sec:EL:OUTELEM:STREAM_OUTPUT}).
As a consequence, its explicit use is discouraged and deprecated.
The \kw{stream output} element should be used instead.




\subsection{Stream motion output}\label{sec:EL:OUTELEM:STREAM_MOTION_OUTPUT}
This element type is obsoleted by the \kw{stream output} element
with the \kw{motion} content type
(see Section~\ref{sec:EL:OUTELEM:STREAM_MOTION_OUTPUT}).
The syntax is:
\begin{verbatim}
    <elem_type> ::= stream motion output

    <arglist> ::= 
        stream name , " <stream_name> " ,
        create , { yes | no } ,
        [ { local , " <socket_name> " , |
            [ port , <port_number> , ]
            [ host , " <host_name> " , ] } ]
        [ { [ no ] signal
            | [ non ] blocking
            | [ no ] send first
            | [ do not ] abort if broken } [ , ... ] , ]
        <motion>
\end{verbatim}
Its support may be discontinued in the future.



\subsection{Structural output}
\label{sec:EL:OUTELEM:STRUCTURAL_OUTPUT}
TODO.



\section{Miscellaneous}
This section lists some extra cards that do not correspond to any
specific simulation entity, but rather alter the behavior 
of existing entries or cause special operations to be undertaken
during model input.



\subsection{Driven Element}\label{sec:EL:BASE:DRIVEN}
The \kw{driven} type is not an element by itself. It is a wrapper that
masks another element and switches it on and off depending on the (boolean)
value of a drive. It can be used to emulate a variable topology model,
where some elements simply don't contribute to the residual
or to the Jacobian matrices when their drive has a certain value.
Since the drivers can be arbitrary functions of the time, 
or other parameters including the value of any degree of freedom, 
the driven elements can be ``driven'' in a very flexible way.
Every element can be driven, except those that can be instantiated once only.
The syntax for a driven element is:
\begin{verbatim}
    <normal_arglist> ::= (drive_caller) <element_driver> ,
        [ hint , " <hint> " , [ ... ] ]
        <driven_element>

    <driven_element> ::= existing : <elem_type> , <elem_label>
    <driven_element> ::= <element_card>
\end{verbatim}
When the first format is used, an existing element 
of type \kw{elem\_type} and label \kw{elem\_label} is looked for, 
and it is wrapped by the driven element.
In this case, no new element is instantiated.
The label of the element must match that of the driving element given 
at the beginning.
For consistency with the syntax, and for more flexibility, 
even when wrapping an existing element the output flags can be set
at the end of the card.
This flag overrides the one set when the driven element was instantiated.

When the second format is used, a new normal element is read 
after the driving element's declaration; it is then instantiated 
and wrapped by the \kw{driven} element wrapper.
Note that after the element type,
or after the keyword \kw{existing}, a colon is used as a separator.
This is one of the very few  exception to the rule that colons 
can only follow descriptions at the beginning of a card.
The label of the driven element must match that of the driving element 
given at the beginning of the card.

\paragraph{Example.} \
A pin constraint between two rigid bodies is released:
\begin{verbatim}
    set: integer body_1 = 1;
    set: integer body_2 = 2;
    # ...
    structural: body_1, dynamic,
        null, eye, null, null;
    structural: body_2, dynamic,
        null, eye, null, null;
    # ....
    rigid body: body_1, body_1,
        1000., null, diag, 100.,100.,1.;
    rigid body: body_2, body_2,
        10., null, diag, 1.e-1,1.e-1,1.e-3;
    # ...
    # this constraint will be released when t = 10 s
    driven: 1, string, "Time<10.",
    joint: 1, spherical hinge,
        body_1, null,
        body_2, null;
\end{verbatim}

\paragraph{Example.} \
an
\hyperref{\kw{axial rotation}}{\kw{axial rotation} (see Section~}{)}{sec:EL:STRUCT:JOINT:AXIAL_ROTATION}
joint is replaced by a
\hyperref{\kw{revolute hinge}}{\kw{revolute hinge} (see Section~}{)}{sec:EL:STRUCT:JOINT:REVOLUTE_HINGE}
when the desired spin velocity, measured as the angular velocity
of the second node (assuming, for instance, that the first one is fixed),
is reached.
The value of an abstract node is used to input the angular velocity 
to the \kw{axial rotation} joint.
\begin{verbatim}
    set: integer body_1 = 1;
    set: integer body_2 = 2;
    set: integer control_output = 3;
    # ...
    structural: body_1, static,
        null, eye, null, null;
    structural: body_2, dynamic,
        null, eye, null, null;
    abstract: control_output;
    # ....
    driven: 1, dof, body_2, structural, 6, differential,
        string, "Var<100.",
    joint: 1, axial rotation,
        body_1, null,
            hinge, 1, 1.,0.,0., 3, 0.,0.,1.,
        body_2, null,
            hinge, 1, 1.,0.,0., 3, 0.,0.,1.,
        dof, control_output, abstract, algebraic,
            linear, 0.,1.;
    driven: 2, dof, body_2, structural, 6, differential,
        string, "Var>=100.",
    joint: 2, revolute hinge,
        body_1, null,
            hinge, 1, 1.,0.,0., 3, 0.,0.,1.,
        body_2, null,
            hinge, 1, 1.,0.,0., 3, 0.,0.,1.;
\end{verbatim}

\subsubsection{Hint}
The \kw{hint} feature consists in allowing the setup of elements
to be computed when they are activated rather than at startup.
For example, a joint that is activated after some simulation time
may need to compute its relative position and orientation
from the parameters of the simulation; a drive that controls
the evolution of the relative configuration of a joint may need
to infer its parameters from the current configuration
of the overall system; and so on.

Currently, only few elements, significantly joints, support 
and honor hints.
The typical syntax is given by a keywork followed by some optional
parameters within curly brackets.
For instance, the hint that instructs a joint to compute the offset
with respect to the second node when it is activated is
\begin{verbatim}
    driven: 10, string, "Time>1.", hint, "offset{2}",
    joint: 10, ...
\end{verbatim}
A similar form is used to instruct a joint to compute the relative
orientation with respect to node 1:
\begin{verbatim}
    driven: 20, string, "Time>1.", hint, "hinge{1}",
    joint: 20, ...
\end{verbatim}
A \kw{distance} joint may be fed a new drive by using:
\begin{verbatim}
    driven: 30, string, "Time>1.",
        hint, "drive{cosine,0.,pi/.1,-.9/2.,half,model::distance(1,2)}",
    joint: 30, distance, ... 
\end{verbatim}
A \kw{drive hinge} joint may be fed a new drive by using:
\begin{verbatim}
    driven: 40, string, "Time>1.",
        # note: the lines wrap for typographical reasons
        # in the actual file, the string has to be a single line
        hint, "drive3{model::xdistance(1,2),\
            model::ydistance(1,2), model::zdistance(1,2),\
            cosine,0.,pi/.1,-.9/2.,half,model::distance(1,2)}",
    joint: 30, drive hinge, ... 
\end{verbatim}

This feature will likely be extended to other elements
and generalized as much as possible.


\subsection{Inertia}\label{sec:EL:MISC:INERTIA}
This card causes the equivalent inertia properties of a subset
of elements to be generated.
\begin{verbatim}
    <card> ::= inertia : <label>
        [ , name , " <inertia_name> " ]
        [ , position , (Vec3)<reference_position> ]
        [ , orientation , (Mat3x3)<reference_orientation> ]
        , <type_subset> [ , ... ]
        [ , output , { no | yes | log | both } ] ;

        <type_subset> ::= <type> , { all | <label_list> }
        <type> ::= { body | joint | loadable }
        <label_list> ::= <label> [ , <label_list> ]
\end{verbatim}
where \kw{type} currently can be \kw{body}, \kw{joint} and \kw{loadable}, 
although more elements associated to inertia might participate in the future.
All elements whose labels are listed must exist, and duplicates
are detected and considered errors.
The keyword \kw{all} causes all the elements of type \kw{type} 
to be included in the list.

\noindent
The only effect of the \kw{inertia} statement is to log
each \kw{inertia} entry in the \kw{.log} file in a self explanatory form,
referred both to the \kw{global} reference frame and to a reference frame
originating from \kw{reference\_position} and oriented 
as \kw{reference\_orientation}.
The optional parameter \kw{output} may be used to alter the default 
behavior:
\begin{itemize}
\item \kw{no} disables the output, making the \kw{inertia} 
statement essentially ineffective;
\item \kw{yes} enables output to standard output;
\item \kw{log} enables output to the \kw{.log} file (the default);
\item \kw{both} enables output to both standard output and \kw{.log} file.
\end{itemize}



\subsection{Output}\label{sec:EL:MISC:OUTPUT}
This card does not instantiate any \kw{element}; it rather enables
output of selected elements, and it is analogous to that of the
\hyperref{\kw{nodes}}{\kw{nodes} (see Section~}{)}{sec:NODE:MISC:OUTPUT}:
\begin{verbatim}
    <card> ::= output : <elem_type> , <elem_list> ;
    <elem_list> ::= { <elem_label>  [ , <elem_list> ]
        | range , <elem_start_label> , <elem_end_label> }
\end{verbatim}
\kw{elem\_type} is a valid element type that can be read 
as card name in the \kw{elements} block.
In case the keyword \kw{range} is used, all existing elements comprised
between \kw{elem\_start\_label} and \kw{elem\_end\_label}
are set; missing ones are silently ignored.





