% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2004
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\chapter{Data}
The \kw{data} section is read directly by the driver program. It is
included between the cards:
\begin{verbatim}
    begin: data;
        ...
    end: data;
\end{verbatim}
At present it is used only to select the integrator to be used in the
simulation. 
Since the only available integrator is the multistep one, the only active 
card (optional, at present), is:
\begin{verbatim}
    <card> ::= integrator: multistep;
\end{verbatim}
Anyway, the \kw{data} section \underline{must} be present.





\chapter{Integrators}
This section is used to insert all the data related to the integrator that
is to be used in the simulation. The section is included between the cards:
\begin{verbatim}
    begin : <integrator_name> ;
        ...
    end : <integrator_name> ;
\end{verbatim}





\section{Multi-Step Integrator}
At present, the only available \kw{integrator\_name} is \kw{multistep}.
The syntax of the module is:
\begin{verbatim}
    begin: multistep;
        ...
    end: multistep;
\end{verbatim}
At present, there are a number of cards that can be grouped as follows, 
based on the integration phase they refer to.

\subsection{General data}
those data that refer to the main integration phase or the simulation as a
whole. They are:

\subsubsection{Initial time}
\begin{verbatim}
    <card> ::= initial time : <time> ;
\end{verbatim}

\subsubsection{Final time}
\begin{verbatim}
    <card> ::= final time : <time> ;
\end{verbatim}

\subsubsection{Strategy}
\begin{verbatim}
    <card> ::= strategy : <strategy_data> ;
\end{verbatim}
where the available strategies are:
\begin{verbatim}
    <strategy_data> ::= no change 
\end{verbatim}
obviously the step is never changed;
\begin{verbatim}
    <strategy_data> ::= factor , 
                        <reduction_factor> ,
                        <steps_before_reduction> ,
                        <raise_factor> ,
                        <steps_before_raise> ,
                        <min_iterations>
\end{verbatim}
the time step is reduced or raised of the proper factor not before a
minimum number of time steps; it is reduced if more than 
\kw{max\_iterations} are performed at a time step, it is raised if less
than \kw{min\_iterations} are performed at a time step;
\begin{verbatim}
    <strategy_data> ::= change , 
                        (drive_caller) <time_step_change>
\end{verbatim}
the time step is change according to the \kw{time\_step\_change} law.

\subsubsection{Min time step}
\begin{verbatim}
    <card> ::= min time step : <time_step> ;
\end{verbatim}

\subsubsection{Max time step}
\begin{verbatim}
    <card> ::= max time step : <time_step> ;
\end{verbatim}
both are significant only if the time step can vary.

\subsubsection{Time step}
\begin{verbatim}
    <card> ::= time step : <time_step> ;
\end{verbatim}
The initial time step.

\subsubsection{Tolerance}
\begin{verbatim}
    <card> ::= tolerance : { null | <residual_tolerance> }
            [ , test , { none | norm | minmax } [ , scale ] ]
        [ , { null | <solution_tolerance> } 
            [ , test , { none | norm | minmax } ] ] ;
\end{verbatim}
The only mandatory value is \kw{residual\_tolerance}, 
the tolerance used for the residual test; the keyword \kw{null}
disables the residual testing, disabling the computation
of the test on the residual.
The \kw{test} mechanism is used to select what kind of test must
be performed; currently, only \kw{norm} (the default) 
and \kw{minmax} are supported.
The special value \kw{none} means that the test is not actually 
computed; it is the default when the test is disabled by setting
the tolerance to zero, or by using the keyword \kw{null};
however, it can be restored to any mechanism for output purposes.
The optional parameter \kw{scale} is used to enable the scaling
of the residual before performing the test; default scale factors 
can be set for each type of degree of freedom owner, and some
entities allow individual scaling; by default, no scaling takes place.
A tolerance \kw{solution\_tolerance} to test the solution 
(the difference between the states at two iterations) is allowed, 
and also in this case a test mechanism can be chosen;
by default, no test on the solution convergence is done.
Currently, no scaling is allowed in the solution test.

\noindent
Examples:
\begin{verbatim}
    # residual test by means of the norm
    tolerance: 1.e-6;
    # residual test with minmax method
    tolerance: 1.e-6, test, minmax;
    # residual test with norm method and scaling
    tolerance: 1.e-6, test, norm, scale;
    # solution test
    tolerance: null, 1.e-9;
    # residual and solution test
    # (the first that succeeds breaks the loop)
    tolerance: 1.e-6, 1.e-9;
    # residual test with computation of solution norm
    tolerance: 1.e-6, null, test, norm;
\end{verbatim}

\subsubsection{Max iterations}
\begin{verbatim}
    <card> ::= max iterations : <max_iterations> ;
\end{verbatim}

\subsubsection{Modify residual test}
\begin{verbatim}
    <card> ::= modify residual test;
\end{verbatim}
modify the residual test taking in account the rate of change of the status.

\subsubsection{Method}
\begin{verbatim}
    <card> ::= method : <method_data> ;
\end{verbatim}
there are four multistep methods at present. 
The first is Crank-Nicholson:
\begin{verbatim}
    <method_data> ::= crank nicholson
\end{verbatim}
the second and the third are original 
methods (the former is discussed in \cite{MASARATI-LANZ-MANTEGAZZA-2001}; 
see also 
\htmladdnormallink{\kw{http://www.aero.polimi.it/\~{}mbdyn/publications.html}}{http://www.aero.polimi.it/~mbdyn/publications.html}), 
that are unconditionally stable and can be tuned to give 
the desired algorithmic dissipation
by setting the value of the asymptotic spectral radius.
The radius can be set independently for the differential
and the algebraic variables, and a driver is used, to allow parameter 
dependent radius variation.
\begin{verbatim}
    <method_data> ::= { ms | hope } ,
        (drive_caller) <differential_radius>
        [ , (drive_caller) <algebraic_radius> ]
\end{verbatim}
The fourth method is experimental. It is a third-order,
two stage unconditionally stable method, which can be tuned to give 
the desired algorithmic dissipation by setting the value 
of the asymptotic spectral radius, which should not be 
too close to zero.
Currently it is not possible to independently set the radius 
for the differential and the algebraic variables.
\begin{verbatim}
    <method_data> ::= thirdorder ,
        (drive_caller) <differential_radius>
\end{verbatim}
The first method proved to be more accurate at high values of asymptotic
radius (low dissipation), while the second proved to be more accurate
at low values of the radius (high dissipation).
They look nearly equivalent at radii close to 0.4, with the former
giving the best compromise between algorithmic dissipation and accuracy 
at about 0.6.
The algebraic radius can be omitted, defaulting to the same 
as the differential one.
It is unclear whether a different spectral radius can help in increasing
accuracy or dissipation of the algebraic unknowns.

\noindent
The multistep method, when the asymptotic radius is zero, degenerates
in the Backward Differentiation Formulas of order two.
A shortcut to this case is provided as
\begin{verbatim}
    <method_data> ::= bdf
\end{verbatim}

\subsubsection{Nonlinear Solver}
The nonlinear solver solves a nonlinear problem $F(x)=0$.
The first nonlinear solver, a modified Newton-Rapson, 
is well tested. The second nonlinear solver, based on a
matrix-free algorithm, is experimental.
\begin{verbatim}
    <card> ::= nonlinear solver : <nonlinear_solver_data> ;
\end{verbatim}
\begin{verbatim}
    <nonlinear_solver_data> ::= newton raphson : { 
                     true | modified [ , <iterations> ] 
                                [ , honor element requests] } ;
\end{verbatim}
if \kw{modified}, the number of iterations the jacobian matrix will be
reused is expected; otherwise a default value is used.
If the option "honor element requests" is selected the preconditioned
is updated also when an element changes the structure of its equations.
The default behaiour is to ignore such requests.
\begin{verbatim}
    <nonlinear_solver_data> ::= matrix free, { bcgstab | gmres }
      [ , tolerance, < tolerance > ]
      [ , steps , <steps> ]
      [ , tau , <tau> ]
      [ , eta , <eta> ]
      [ , preconditioner, {
              full jacobian [ , steps, <steps> ] 
	                    [ , honor element requests]
      } ];
\end{verbatim}
Tolerance is the iterative linear solver tolerance;
steps is the maximum number of the linear solver iteration.
Tau is a measure of the configuration pertubation used
to obtain a matrix free approximation of the product
of the jacobian matrix times the solution vector;
it is seldom necessary to change the default value of this parameter,
mainly for very ``stiff'' problems.
Eta allows to change the convergence requirements; further reference for
this parameter may be found in \cite{KELLEY-1995}; do not change it
unless you know what you are doing.
The preconditioner steps fixes the maximum number of
iterations that can be performed without requiring
an update of the preconditioner; this parameter can heavily influence
the performance of the matrix free solver.
If the option "honor element requests" is selected the preconditioned
is updated also when an element changes the structure of its equations.
The default behaiour is to ignore such requests.

\subsubsection{Eigenanalysis}
Experimental, not available nor documented yet.

\subsubsection{Abort after}
\begin{verbatim}
    <card> ::= abort after : { input 
                             | assembly 
                             | derivatives 
                             | dummy steps } ;
\end{verbatim}
mainly used to cleanly check models and simulations at various phases.

\subsubsection{Solver}   
\begin{verbatim}
    <card> ::= solver :
            { umfpack | y12 | harwell | meschach | superlu | lapack}
        [ , { map | cc | dir } ]
        [ , mt , <threads> ]
        [ , workspace size , <workspace_size> ] 
        [ , pivot factor , <factor> ] ;
        [ , block size, <block_size> ] ;
\end{verbatim}
The default, if available, is \kw{umfpack} which dynamically
allocates memory as required, so the \kw{workspace size} 
parameter, if given, is ignored.
The \kw{umfpack} solver honors the \kw{block size} keyword,
which refers to an internal parameter.
The default value (32) is usually good for most problems; however,
it has been observed that alower value can slightly improve
performances on small problems (e.g.\ a rigid rotorcraft model
with some 180 degrees of freedom showed a 10\% speedup with 
a block size of 4, while a rigid robot showed eve higher speedups,
in the 30\%, with a block size between 4 and 16).
The \kw{y12} solver requires static allocation of the workspace;
the optimal size is between 3 and 5 times the number of nonzero 
coefficients.
By default, twice the size of the full matrix is allocated
(which sounds a bit nonsense, but is conservative enough);
then the solver automatically uses an optimal amount of memory
based on the results of the previous factorization; this could
result in a failure if the filling of the matrix changes 
dramatically between two factorizations.
Another solver, that is available mostly for historical reasons, 
is \kw{harwell}, with a \kw{workspace size}
of $ numdofs\times{numdofs} $, but in certain cases the user
might prefer a smaller workspace, since the matrix is handled as sparse,
while sometimes a larger space is required, since when the matrix is
full, a little more space is required, due to extra storage needs when
the matrix fills up.
Finally, \kw{superlu} is an experimental solver that is able to perform
the factorization in a multithreaded environment.
If more than one CPU is available, it automatically uses all the CPUs;
the keyword \kw{mt} allows to enforce the desired number of threads.
See also the \kw{threads} keyword for more details on multithreaded
solution.
The keywords \kw{map} (Sparse Map), \kw{cc} (Column Compressed)
and \kw{dir} (Direct Access) can be used to modify the way
the sparse matrix is handled:
\begin{itemize}
\item \kw{map} uses an array of binary trees to store the matrix,
coefficients; right before the factorization, the matrix is transformed
in the form required by each solver, usually Column Compressed
(also known as Harwell-Boieng format) or Index (as used by \kw{y12}).
The matrix is regenerated each time an assembly is required.
\item \kw{cc} uses the compact format resulting from the trasformation
required by the solver to store the coefficients in subsequent assemblies,
thus saving the tiem required to transform the matrix.
If the profile of the matrix changes, the compact form is invalidated,
and the matrix is reset to \kw{map} form.  As a consequence, this matrix
form allows faster access and reduced factorization cost, but in certain
cases may require an additional cost.
\item \kw{dir} uses a full index table to grant direct access time to
the actual location of each coefficient.
In principle it should be a bit faster than \kw{cc}, at the cost
of some memory waste.
However, in practical applications, the cost of these operations
is a very small fraction of the factorization time.
If the problem is quite large, the memory consumption might
become unacceptable; if the problem is quite small, the access time
of \kw{cc} is quite limited ($\log_2\plbr{\mathrm{<nz>}}$, where
\kw{<nz>} is the number of nonzeroes in a column) so it is definitely
comparable to that of \kw{cc}.
\end{itemize}
Only \kw{umfpack}, \kw{y12} and \kw{superlu} solvers allow these
settings.

\noindent
Pivot factor is a real, which in a heuristic sense can be regarded as
the treshold for the ratio between two coefficients below which they are
switched, so $ 0.0 $ means no pivoting, while $ 1.0 $ means switch as
soon as the norm of the ratio is less than unity.

\noindent
Table~\ref{tab:solvers} summarizes the properties of the solvers

\begin{table}
\centering
\caption{Properties of the solvers}\label{tab:solvers}
\begin{tabular}{lllll}
\hline\hline
	\multicolumn{1}{c}{\textbf{Solver}} &
	\multicolumn{1}{c}{\textbf{Pivot}} &
	\multicolumn{1}{c}{\textbf{Workspace}} &
	\multicolumn{1}{c}{\textbf{Memory}} &
	\multicolumn{1}{c}{\textbf{Block Size}} \\
	&
	&
	\multicolumn{1}{c}{\textbf{Size}} &
	\multicolumn{1}{c}{\textbf{Allocation}} \\
\hline
	Umfpack 3	& 0.0$\rightarrow$1.0 	& 			&
		dynamic		& default=32	\\
 			& default: 0.1 		&			&
				&		\\
	Y12m 		& none=0.0, 		& default=$2\times{n^2}$&
		static		&		\\
			& full=1.0		& $3nz \rightarrow 5nz$	&
				&		\\
	SuperLU		& 0.0$\rightarrow$1.0	&			&
		dynamic 	&		\\
	Harwell		& full: 1.0		& ?			&
		static		&		\\
	Meschach	& full: 1.0		& 			&
		dynamic		&		\\
\hline\hline
\end{tabular}
\end{table}


\subsubsection{Threads}   
\begin{verbatim}
    <card> ::= threads :
        { auto | disable | [ { assembly | solver } , ] <threads> }
\end{verbatim}
By default, if enabled at compile time, the assembly is performed
in a multithreaded environment if more than one CPU is available 
and the selected solver allows it (e.g.\ if it supports any form 
of compressed matrix handling, \kw{cc} or \kw{dir}).
However, this behavior can be influenced by the \kw{threads} directive.
The value \kw{auto} is the default; the value \kw{disable} reverts
to the usual scalar behavior; otherwise \kw{<threads>}, the desired 
number of threads, is read.
If it is prefixed by the keyword \kw{assembly}, the desired number
of threads is used only in assembly; if it is prefixed by the keyword
\kw{solver}, the desired number of threads is used only during 
factorization/solution, if the linear solver supports it (currently,
only the \kw{superlu} solver does).
As an example, on a 4 CPU architecture, to use 2 threads for assembly
and 4 threads for solution, use
\begin{verbatim}
    threads: assembly, 2;
    solver: superlu, cc, mt, 4;
\end{verbatim}





\subsection{Derivatives data}
Data related to the derivatives phase. They are:


\subsubsection{Derivatives tolerance}
\begin{verbatim}
    <card> ::= derivatives tolerance : <tolerance> ;
\end{verbatim}

\subsubsection{Derivatives max iterations}
\begin{verbatim}
    <card> ::= derivatives max iterations : <max_iterations> ;
\end{verbatim}

\subsubsection{Derivatives coefficient}
\begin{verbatim}
    <card> ::= derivatives coefficient : <coefficient> ;
\end{verbatim}
right after the initial assembly and before the simulation starts, the
so-called derivatives solution is performed. The system is solved with
the kinematic unknowns constrained, in order to properly determine the
dynamic unknowns, namely momenta and constraint reactions. For this
purpose, the coefficient that relates the state perturabtion to the
derivative perturbation must be set to a value that is small enough to
allow the determination of accurate derivatives with very small change
in the states. This coefficient should be zero, but this leads to matrix
singularity, so it must be chosen by the user, since it is highly
problem dependent. A rule-of-thumb is: if the system has small
stiffness and high inertia, the coefficient can be big, if the system
has high stiffness and small inertia, the coefficient must be small.


\subsection{Dummy steps data}
Data related to the dummy steps phase. They are:

\subsubsection{Dummy steps tolerance}
\begin{verbatim}
    <card> ::= dummy steps tolerance : <tolerance> ;
\end{verbatim}

\subsubsection{Dummy steps max iterations}
\begin{verbatim}
    <card> ::= dummy steps max iterations : <max iterations> ;
\end{verbatim}    
{\em
    Note: no step change, modified Newton-Raphson and so on is allowed
    during the dummy steps.
}

\subsubsection{Dummy steps number}
\begin{verbatim}
    <card> ::= dummy steps number : <number> ;
\end{verbatim}
number of dummy steps.

\subsubsection{Dummy steps ratio}
\begin{verbatim}
    <card> ::= dummy steps ratio : <ratio> ;
\end{verbatim}
ratio of the time step to be used in the dummy steps to the regular
time step.

\subsubsection{Dummy steps method}
\begin{verbatim}
    <card> ::= method : <method_data> ;
\end{verbatim}
Same as for the normal simulation method. 
The dummy steps are intended as a sort of numerical computation 
of the second order derivatives of the constraint equations. 
The displacement constraint equations in an index three 
Differential-Algebraic Equations system
(DAE) represent the second derivative effect of the constraints on the
kinematic unknowns. Thus, to ensure the proper initial conditions, the
constraint equations should be derivated twice. To simplify the code,
those equations have been derivated once only, in the initial assembly,
the second derivation being performed numerically by the dummy steps.
During these steps the system converges to a solution whose error from
the sought solution is bounded. For this reason, the dummy steps
should be performed with a very short time step, to seek accuracy, and
with a high numerical damping, to cancel as quickly as possible the high
frequency numerical noise.

\subsection{Output Data}
Model output, e.g.\ nodes and elements output, is handled
by the data manager; the integrator only deals with
simulation-related output, and takes care of some debug output.

\subsubsection{Output}
This command requests special output related to the solution phase.
\begin{verbatim}
    <card> ::= output : <item> [ , <item> [ , ... ] ] ;
    <item> ::= { iterations
               | residual
               | solution
               | jacobian
               | messages
               | none }
\end{verbatim}
The item \kw{iterations} logs a detailed output of the error
at each iteration inside a time step 
% in the \kw{.out} file.
on the standard output.
The items \kw{residual}, \kw{solution} and \kw{jacobian} log
the residual, the solution and the jacobian to standard output; they are
currently available only for the umfpack solver, and they are
mainly intended for last resort debugging purposes.
The item \kw{messages} refers to all messaging 
on the \kw{.out} file; by default, it is on.
The special item \kw{none} clears the output flags; the items
are additive, so, for instance, to clear out the default 
and add the iterations output, use:
\begin{verbatim}
    output: none, iterations;
\end{verbatim}

\chapter{Control Data}
This section is read by the manager of all the bulk simulation data, namely
the nodes, the drivers and the elements. It is used to set some global
parameters closely related to the behavior of these entities, to tailor the
initial assembly of the joints in case of structural simulations, and to
tell the data manager how many entities of every type it should expect from
the following sections. Historically this is due to the fact that the data
structure for nodes and elements is allocated at the beginning with fixed
size. This is going to change, giving raise to a ``free'' and resizable
structure. But this practice is to be considered reliable since it allows a
sort of double-check on the entities that are inserted.
The cards are: 

\subsubsection{Skip initial joint assembly}
\begin{verbatim}
    <card> ::= skip initial joint assembly ;
\end{verbatim}

\subsubsection{Use}
\begin{verbatim}
    <card> ::= use : <item_list> , in assembly ;
    <item_list> ::= <item> [ , <item_list> ]
    <item> ::= { rigid bodies 
               | gravity
               | forces
               | beams
               | aerodynamic elements } 
\end{verbatim}
\kw{joints} are used by default, and shouldn't be added to the list.
\kw{beams} are used by default, too, but can be added to the list
essentially for backwards compatibility.

\subsubsection{Initial stiffness}
\begin{verbatim}
    <card> ::= initial stiffness : <position_stiffness>
                                   [ , <velocity_stiffness> ] ;
\end{verbatim}

\subsubsection{Omega rotates}
\begin{verbatim}
    <card> ::= omega rotates : { yes | no } ;
\end{verbatim}
Sets whether the imposed angular velocity should be considered attached 
to the node or fixed in the global system during the initial assembly.

\subsubsection{Initial tolerance}
\begin{verbatim}
    <card> ::= initial tolerance : <tolerance> ;
\end{verbatim}

\subsubsection{Max initial iterations}
\begin{verbatim}
    <card> ::= max initial iterations : <max_iterations> ;
\end{verbatim}

\subsubsection{Title}
\begin{verbatim}
    <card> ::= title : " <simulation_title> " ;
\end{verbatim}

\subsubsection{Make restart file}
\begin{verbatim}
    <card> ::= make restart file
        [ : { iterations , <iterations_between_restarts>
            | time , <time_between_restarts> } ] ;
\end{verbatim}
The default (no arguments) is to make the restart file only at the end of
the simulation.

\subsubsection{Default output}
\begin{verbatim}
    <card> ::= default output : <output_list> ;
    <output_list> ::= { all | none | <output_item> } 
                      [ , <output_list> ]
    <output_item> ::= { structural nodes
                      | electric nodes
                      | abstract nodes
                      | gravity
                      | rigid bodies
                      | joints
                      | beams
                      | air properties
                      | rotors
                      | aerodynamic elements
                      | forces
                      | genels
                      | electric elements }
\end{verbatim}
Here the default output flag for a type of node or element can be set. It
can be overridden for every entity both when it is created or later in
each entity module.

\subsubsection{Output precision}
Sets the desired output precision for those file types that allow it
(currently, all the native output except the \kw{.out} file; the
\kw{ADAMS} output, \kw{.res} files, are not affected.
The default is 6; since the output is in formatted plain text, the higher
precision, the larger the files and the slower the simulation.
This will be fixed when a binary output is implemented.
\begin{verbatim}
    <card> ::= output precision : <number_of_digits> ;
\end{verbatim}





\chapter{Nodes}
The \kw{nodes} section is enclosed in the cards:
\begin{verbatim}
    begin: nodes;
        ...
    end: nodes;
\end{verbatim}
Every node card has the following format:
\begin{verbatim}
    <card> :: = <node_type> : <node_label> ,
                              <arglist>
                              [ , output , { yes | no } ] ;
\end{verbatim}
where \kw{node\_type} is one of the following:
\begin{itemize}
    \item \kw{structural}
    \item \kw{electric}
    \item \kw{abstract}
    \item \kw{parameter}
    \item \kw{hydraulic}
\end{itemize}
The data manager reads the node type and the label and checks for
duplication. If the node is not defined yet, the proper read function is
called, which parses the rest of the card and costructs the node.
The nodes are read as follows:




\section{Structural Node}\label{sec:NODE-STRUCT}
The historical 6 dof structural node can be \kw{static},
\kw{dynamic}, \kw{\bf modal} or \kw{dummy}.
The \kw{static} keyword means no inertia is related to that node, 
so it must be appropriately constrained or attached to elastic elements.
Static nodes are useful when there is no need to apply inertia
to them, thus saving 6 degrees of freedom.
The \kw{dynamic} keyword means inertia can be attached to the node, 
so it provides linear and angular momenta degrees of freedom, 
and automatically generates the so-called \kw{automatic structural}
elements.
The \kw{modal} node is a regular \kw{dynamic} node that must be used 
to describe the rigid reference motion of a \kw{modal} joint.
See Section~\ref{ELEMS-JOINT-MODAL} for further details.
\begin{verbatim}
    <arglist> ::= { static | dynamic | modal } ,
            (Vec3)              <absolute_position> ,
            (OrientationMatrix) <absolute_orientation_matrix> ,
            (Vec3)              <absolute_velocity> ,
            (Vec3)              <absolute_angular_velocity>
            [ , assembly
              , (scalar) <position_initial_stiffness>
              , (scalar) <velocity_initial_stiffness>
              , (flag)   <omega_rotates?> ]
\end{verbatim}
The \kw{omega\_rotates} parameter determines whether 
the initial angular velocity should follow or not the node 
as it is rotated by the initial assembly procedure; it may assume 
the values \kw{yes}/\kw{no} or 0/nonzero.

\noindent
The \kw{dummy} structural node has been added to ease the visualization of
the kinematics of arbitrary points of the system. 
It owns no dofs, and it must be attached to another node, possibly with an
offset and a relative orientation.
Two dummy structural node types are available.
\begin{verbatim}
    <arglist> ::= dummy , <base_node> , <type> , <dummy_node_data>
\end{verbatim}
{\em 
    Note: the \kw{static} and \kw{dynamic} type is optional; if not given,
    it defaults to \kw{dynamic}. 
    This practice is deprecated and could become unsupported in the future, 
    so it is a good practice to enforce the type of the structural node. \\
    The stiffness parameters, and the \kw{omega\_rotates} flag, 
    override the default values. 
    They are optional, but they must be supplied all together if at least
    one is to be input.
} \\
The \kw{omega\_rotates} flag can take values \kw{yes} or \kw{no};
a numerical value of 0 (no) or 1 (yes) is supported for backwards
compatibility, but its use is deprecated.

Dummy nodes take the label of the \kw{base\_node} they are attached to, 
followed by the type of dummy node, possibly followed by specific data.
The following dummy types are available:

\begin{itemize}

    \item offset:
    \begin{verbatim}
    <type> ::= offset
    <dummy_node_data> ::=
            (Vec3)              <relative_offset> ,
            (OrientationMatrix) <relative_orientation_matrix>
    \end{verbatim}
    It outputs the configuration of a point offset from the base node.
            
    \item relative frame:
    \begin{verbatim}
    <type> ::= relative frame
    <dummy_node_data> ::= <reference_node>
            [ , position, <reference_offset> ]
            [ , orientation, <reference_orientation_matrix> ]
    \end{verbatim}
    It outputs the configuration of the base node in the frame defined
    by the \kw{reference\_node}, optionally offset 
    by \kw{reference\_offset} and with relative orientation 
    \kw{reference\_orientation\_matrix}.\\
    Examples:
    \begin{verbatim}
    set: real Omega = 1.;
    structural: 1, static, null, eye, null, 0.,0.,Omega;
    structural: 1000, dummy, 1, offset, 1.,0.,0., eye;
    structural: 1001, dummy, 1, relative frame, 1000;
    \end{verbatim}

\end{itemize}

\subsection{Output}
Structural nodes generate two kinds of output files. 
The first refers to the kinematics of the node; its extension is \kw{.mov},
and for each time step it contains one row for each node whose output is
required.
The rows contain: \vspace{2mm} \\
\begin{tabular}{ll}
    \hline
    1      & the label of the node \\
    2--4   & the three components of the position of the node \\
    5--7   & the three Euler angles that define the orientation of the node \\
    8--10  & the three components of the velocity of the node \\
    11--13 & the three components of the angular velocity of the node \\
    \hline
\end{tabular}\vspace{2mm}\\
All of the quantities are expressed in the global frame, except in case of
the dummy \kw{relative frame} node, where the quantities are in the
relative frame.

\noindent
The second output file refers only to dynamic nodes, and contains their
inertia; its extension is \kw{.ine}.
For each time step, it contains information about the inertia of all the
nodes whose output is required.
Notice that more than one inertia body can be attached to one node; the
information in this file refers to the sum of all the inertia referring to
the node.
The rows contain:
\begin{itemize}
    \item the label of the node
    \item the three components of the momentum
    \item the three components of the momentum moment referred to the node
    coordinates, thus to a moving frame
    \item the three components of the derivative of the momentum
    \item the three components of the derivative of the momentum moment
\end{itemize}


\section{Electric Node}
\begin{verbatim}
    <arglist> ::= "value" , <initial_value> 
        [ , "derivative" , <derivative_initial_value> ]
\end{verbatim}
\emph{Note: the keywords \kw{value} and \kw{derivative}
have been introduced recently; \kw{value}is not mandatory,
resulting in a warning while \kw{derivative} is required.
The same applies to the \kw{abstract node} 
and to the \kw{hydraulic node}; the latter is an algebraic
node, so only \kw{value} is allowed.
}





\section{Abstract Node}
\begin{verbatim}
    <arglist> ::= "value" , <initial_value>
        [ , "derivative" , <derivative_initial_value> ]
\end{verbatim}
{\em
    Note: abstract and electric nodes are derived from the same class, the
    scalar differential node. Many \kw{genel} and \kw{electric} elements 
    can be connected to both of them since they directly use the ancestor
    class. 
}

\subsection{Output}
The value of abstract nodes is output with file extension \kw{.abs}; for
each time step the output of the required nodes is written.
The format of each row is
\begin{itemize}
    \item the label of the node
    \item the value of the node
    \item the value of the node derivative
\end{itemize}



\section{Hydraulic Node}
\begin{verbatim}
    <arglist> ::= "value" , <initial_value>
\end{verbatim}



\section{Parameter Node}
\begin{verbatim}
    <arglist> ::= { <initial_value>
                  | element 
                  | straingage , y , z }
\end{verbatim}
The parameter node is derived from the class scalar algebraic node, but it
is used in a rather peculiar way: it doesn't own any degree of freedom,
so it does not participate in the solution, but is used as a sort of
placeholder for those elements that require to be connected to a scalar node
that is not otherwise significant to the analysis.
Thanks to the availability of the \kw{parameter} node, these elements
do not need be reformulated with a grounded node, while the parameter
node value can be changed during the solution by means of a proper driving 
force.
When the argument list starts with the keyword \kw{element}, the parameter
node expects to be bound to an element, and to access bulk element data 
(see Section~\ref{sec:EL-BIND}).
When the argument list starts with the keyword \kw{straingage}, followed by
the coordinates of a point on the section of a beam, the \kw{parameter}
node expectes to be bound to a beam element, and to access the measure of
the axial strain at point \kw{x}, \kw{y} in the section plane as a
combination of section strains and curvatures.





\section{Miscellaneous}
There is an extra card, that is used to modify the output behaviour of nodes:  
\begin{verbatim}
    <card> ::= output : <node_type> , <node_list> ;
    <node_list> ::= <node_label>  [ , <node_list> ]
\end{verbatim}
\kw{node\_item} is a valid node type that can be read in the \kw{nodes}
module. \\
{\em
   Note: if a node should never (\kw{no}) or always (\kw{yes}) be output,
   its output flag should be set directly on the node card. 
   The global behaviour of all the nodes of a type can be set from the 
   \kw{control} module by adding the node type to the item list in the 
   \kw{default output} card. 
   Then, the specific output flag of sets of nodes can be altered by means 
   of the \kw{output} card in the \kw{nodes} module. 
   This allows a high flexibility in the selection of the desired output. 
   The same remarks apply to the output of the elements.
}



\chapter{Scalar functions}\label{sec:SCALARFUNCS}
A \kw{ScalarFunction} object allows to compute the value of a function.
Almost every scalar function is of type \kw{DifferentialbeScalarFunction},
derived from \kw{ScalarFunction}, and allows to compute the derivatives of
the function as well. Currently implemented scalar functions are
\begin{itemize}
\item \kw{const}: $f(x)=c$
\item \kw{log}: $f(x)=m\textrm{log}(x)$
\item \kw{pow}: $f(x)=x^p$
\item \kw{linear}: linear interpolation between the two points $(x_1,y_1)$
and $(x_1,y_1)$
\item \kw{cubicspline}: cubic natual spline interpolation between the 
set of points $\{(x_i,y_i), i\in[1,k\geq3]\}$
\item \kw{multilinear}: multilinear interpolation between the 
set of points $\{(x_i,y_i), i\in[1,k\geq2]\}$
\end{itemize}

\noindent
Every \kw{ScalarFunction} card has the following format:
\begin{verbatim}
    <card> :: = scalar function : <unique_scalar_func_name>, 
                    <scalar_func_type>,
                    <scalar_func_args>
\end{verbatim}
\begin{verbatim}
    <scalar_func_name> :: = string 
\end{verbatim}

\noindent
The type of scalar function,
\kw{scalar\_func\_type}, together 
with relevant arguments, \kw{scalar\_func\_type},
are as follows:
\subsubsection{Const scalar function}
\begin{verbatim}
    <scalar_func_type> ::= const
    <scalar_func_args> ::= <const_coef>
\end{verbatim}
\subsubsection{Log scalar function}
\begin{verbatim}
    <scalar_func_type> ::= log
    <scalar_func_args> ::= <multiplier_coef>
\end{verbatim}
\subsubsection{Pow scalar function}
\begin{verbatim}
    <scalar_func_type> ::= pow
    <scalar_func_args> ::= <exponent_coef>
\end{verbatim}
\subsubsection{Linear scalar function}
\begin{verbatim}
    <scalar_func_type> ::= linear
    <scalar_func_args> ::= <point>, <point>
    <point>            ::= <x>, <y>
\end{verbatim}
\subsubsection{Cubic natural spline scalar function}
\begin{verbatim}
    <scalar_func_type> ::= cubicspline
    <scalar_func_args> ::= <point>, 
                           <point>, 
                           <point>
                           [, ...]
    <point>            ::= <x>, <y>
\end{verbatim}
\subsubsection{Multilinear scalar function}
\begin{verbatim}
    <scalar_func_type> ::= multilinear
    <scalar_func_args> ::= <point>, 
                           <point>, 
                           [, ...]
    <point>            ::= <x>, <y>
\end{verbatim}


\chapter{Drivers}\label{sec:DRIVERS}
The \kw{drivers} section is enclosed in the cards:
\begin{verbatim}
    begin: drivers;
        ...
    end: drivers;
\end{verbatim}
Every \kw{driver} card has the following format:
\begin{verbatim}
    <card> ::= <driver_type> : <arglist> ;
\end{verbatim}
At present only \kw{file} drivers are supported.

\section{File Drivers}
A comprehensive family of \kw{file} drivers is being planned;
their syntax is:
\begin{verbatim}
    <arglist> ::= <label> , <normal_arglist>
\end{verbatim}
The following \kw{file} drivers are supported at present:


\subsection{Fixed Step}
\begin{verbatim}
    <normal_arglist> ::= fixed step , 
                         <steps_number> ,
                         <columns_number> ,
                         <initial_time> ,
                         <time_step> ,
                         " <file_name> "
\end{verbatim}
The value at an arbitrary time is linearly interpolated from the available
data; if the requested value is out of time bounds, zero is returned.

\subsection{Socket}
\begin{verbatim}
    <normal_arglist> ::= socket , 
                         <columns_number>
                         { , local, " <file_name> " 
                           | [ , port, <port_number> ] }
                         (AuthenticationMethod)<authentication>
\end{verbatim}
The driver binds to a socket listening on port \kw{port\_number} 
(defaults to 5555) or on the named pipe \kw{file\_name}; at the
beginning of each time step, in case of connection, the driver expects some
input data in text format, consisting in an authentication token 
(if required).
The authentication token is usually in the form
\begin{verbatim}
    user: <user_name> <new_line>
    password: <user_password> <new_line>
\end{verbatim}
{\em 
    Note: whitespaces may be significant in \kw{user\_name}, and surely are
    in \kw{user\_password}.
} \\    
It is followed by a label token, in the form
\begin{verbatim}
    label: <label> <new_line>
\end{verbatim}
indicating the column being edited, followed by the desired changes; 
the connection is terminated by a single mark followed by a newline:
\begin{verbatim}
    . <new_line>
\end{verbatim}
The permitted operations, at present, are:
\begin{verbatim}
    value: <value> <new_line>
\end{verbatim}
sets the value the drive will assume from the current step on
\begin{verbatim}
    inc: { yes | no } <new_line>
\end{verbatim}
tells whether to switch on or off the increment mode, resulting in
subsequent value commands being ``set'' rather than ``add''
\begin{verbatim}
    imp: { yes | no } <new_line>
\end{verbatim}
tells whether to switch on or off the impulse mode, resulting in subsequent
value commands to be applied for one step only. \\
{\em 
    Note: at present, impulse mode superseedes any incremental mode, namely
    the value of the drive is reset to zero after one step.
    This behaviour may change in the future.
}

