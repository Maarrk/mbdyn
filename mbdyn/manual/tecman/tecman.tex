% MBDyn (C) is a multibody analysis code.
% http://www.mbdyn.org
%
% Copyright (C) 1996-2003
%
% Pierangelo Masarati  <masarati@aero.polimi.it>
%
% Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
% via La Masa, 34 - 20156 Milano, Italy
% http://www.aero.polimi.it
%
% Changing this copyright notice is forbidden.
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation (version 2 of the License).
% 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

\documentclass[10pt,dvips]{report}

%\usepackage[pdftex]{graphicx}
\usepackage[T1]{fontenc}
\usepackage{ae,aecompl}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{html}

\input{stdmacro}
%poor man's bold symbol
\newcommand{\T}[1]{\boldsymbol{#1}}

\begin{document}

\begin{latexonly}
\title{\bf MBDyn Technical Manual \\
Version
\input{version}
}
\author{Pierangelo Masarati \vspace{5mm}\\
    \sc Dipartimento di Ingegneria Aerospaziale \\
    \sc Politecnico di Milano}
\date{\today}
\maketitle
\end{latexonly}

\begin{htmlonly}
\begin{center}
\textbf{\LARGE MBDyn Technical Manual}

\emph{\large Pierangelo Masarati}

\textsc{Dipartimento di Ingegneria Aerospaziale \\ Politecnico di Milano}

\today
\end{center}
\end{htmlonly}




\tableofcontents
\newpage

\chapter{Introduction}
This document describes details about the formulation MBDyn:
Multi-Body Dynamics relies on.

\chapter{Parsing}
The parser ... bla... bla.. 

\section{HighParser} ... 
The \texttt{HighParser} class and its descendants use a \texttt{KeyTable}
object containing a list of legal keywords to return a valid keyword index
when \texttt{HighParser::GetWord()}, and significantly 
\texttt{HighParser::GetDescription()} are invoked.
The \texttt{KeyTable} can be changed during parsing.
\texttt{KeyTable} is a class.
Its constructor takes a pointer to an array of strings and a reference 
to the \texttt{HighParser} object.
The last string in the array must be null.
The \texttt{KeyTable} class constructor keeps track 
of previous \texttt{KeyTable} objects in the \texttt{HighParser}, 
and restores them upon destruction.
The suggested usage inside a stacked call sequence of parsing functions is
\begin{verbatim}
Part *
read_part(HighParser& HP)
{
    /* prepare names */
    enum KeyWord { KEYWORD1, KEYWORD2, KEYWORD_LAST };
    char *key_table_array[] = { "keyword1", "keyword2", 0 };
    /* build KeyTable class */
    KeyTable k(HP, key_table_array);
    Part *returned_object = 0;
    /* parse input */
    do {
        switch (KeyWord(HP.GetWord())) {
        default:
            /* do something... */
            break;
        case KEYWORD1:
            /* ...and build returned_object  */
            return returned_object;
        }
    } while (true);
}

void
read_all(HighParser& HP)
{
    /* prepare names */
    enum KeyWord { KEY1, KEY2, PART, KEY_LAST };
    char *keytable[] = { "key1", "key2", "part", 0 };
    /* build KeyTable class */
    KeyTable k(HP, keytable);
    /* do something */
    Part *part = 0;
    do {
        switch (KeyWord(HP.GetWord())) {
        default:
            /* do something... */
            break;
        case PART:
            /* read part */
            Part *part = read_part(HP);
            break;
        }
    } while (true);
}

\end{verbatim}
Here the \texttt{KeyTable} set by function \texttt{read\_all()} 
is automatically restored after the call to \texttt{read\_part()}; 
\texttt{read\_part()} temporarily changes the \texttt{KeyTable}
used by the parser.

\section{LowParser} ... 
\section{MathParser} ...

\chapter{Solvers}
...
\section{Linear solvers}
...
\section{Non linear solvers}
...
\section{Parallel solver}
\subsection{Partitioning}
\texttt{iTotVertices} is equal to the sum of nodes and elements. 
It is made in this way because we want the partitioner 
to generate a twofold subdivision:
\begin{itemize}
\item a subdivision related to elements; 
this subdivision is done in order to share the computational 
load during the assembly phase;
\item a subdivision related to nodes, 
which is necessary for the solving phase with the substructuring method.
\end{itemize}
Of course this two partitions must be connected, 
so we build created a graph which is made of nodes and elements as vertex. 
The connection between vertexes are only between nodes and elements. 
There is no node to node or element to element connection.

\texttt{pVertexWgts} 
contains what we call the computational weight of each entity, 
so nodes have weight null while elements has a weight related to 
the dimension of the submatrix of the Jacobian assembled by each one of them.

\texttt{pCommWgts} contains the communication weights 
(see metis documentation) which are a measure of the quantity 
of data which needs to be sent if the i-th vertex is part 
of an interface between different partitions. 
This means that nodes have a \texttt{CommWgts} equal to the number 
of dofs while elements have a weight equal to eventual internal dofs of it.


\chapter{Integration}

\begin{itemize}

\item[differential variable:] a variable is declared differential
in \texttt{SimulationEntity::GetDofType()} 
by returning \texttt{DofOrder::DIFFERENTIAL}.
The increment of the value of a differential variable is equal 
to $\Delta x=d_{Coef}\Delta \dot{x}$.
When writing the jacobian, this must be considered;
as a consequence, for an equation $f=0$ (the residual is $-f$)
the linearization is 
$f_{/\dot{x}}+f_{/x}*d_{Coef})*\Delta \dot{x}=-f$, 
as $d_{Coef}*\Delta \dot{x}=\Delta x$.

\item[algebraic variable:] a variable is declared algebraic
in \texttt{SimulationEntity::GetDofType()}
by returning \texttt{DofOrder::ALGEBRAIC}.
The increment of the value of an algebraic variable is the increment 
of the variable.

\item[differential equation:] an equation is declared differential
in \texttt{SimulationEntity::GetEqType()}
by returning \texttt{DofOrder::DIFFERENTIAL}.
An equation $f=0$ must be declared differential if $f_{/\dot{x}}$ is not null.
The residual is $-f$, and its linearization is:
$\plbr{f_{/\dot{x}}+f_{/x}*d_{Coef}}*\Delta \dot{x}=-f$.

\item[algebraic equation:] an equation is declared algebraic
in \texttt{SimulationEntity::GetEqType()}
by returning \texttt{DofOrder::ALGEBRAIC}.
An equation $f=0$ can be declared algebraic iff $f_{/\dot{x}}$ 
is structurally null (e.g.\ regardless of the values the state may assume) 
and $x$ is not algebraic.
If an equation $f\plbr{x,t}=0$ is declared differential,
the residual is $-f$, and its linearization is:
$f_{/x}*d_{Coef}*\Delta \dot{x}=-f$.
If the equation can be declared algebraic, it can be divided by $d_{Coef}$:
$f/d_{Coef}=0$, with residual $-f/d_{Coef}$,
and linearization $f_{/x}*\Delta \dot{x} = -f/d_{Coef}$.
This helps scaling the equations.
Clearly, this has no sense if $x$ is algebraic,
or if $f_{/\dot{x}} \neq 0$.

\end{itemize}

\section{Nodal rotation}
The rotational gdl unknown during \texttt{AssRes()} and \texttt{AssJac()}
are the increment of (Gibbs-Rodriguez) rotation parameters
with respect to the reference configuration.
Of course the increment of the parameter is
$\Delta \T g=d_{Coef}\Delta \dot{\T g}$.
The increment of angular velocity is 
$\Delta \T \omega = \T G\Delta \dot{\T g}+ \Delta \T G \dot{\T g}-
\T \omega_{ref}\times \T G \Delta \T g$,
where $\T G(\T g)$ is the tensor relating $\T g_\delta$ to $\delta \T g$,
and $\T \omega_{ref}$ is the nodal referenc angular velocity (Wref).
We assume $\T G = \T I$ and $\Delta \T G = \T 0$,
so that $\Delta \T \omega = \Delta \dot{\T g}-\T \omega_{ref}\times\Delta \T g$
and so $\Delta \T \omega = \Delta \dot{\T g}-
\T \omega_{ref}\times\Delta \dot{\T g} * d_{Coef}$.

\chapter{Data Structure}

\chapter{Constraints}

\section{Algebraic Constraints}

\subsection{Distance Joint}

\subsubsection{Distance Joint Without Offsets}
Definitions
\begin{displaymath}
	u = \frac{1}{d}\plbr{x_2 - x_1}
\end{displaymath}
Limitations
\begin{displaymath}
	d > 0
\end{displaymath}
Constraint Equation
\begin{displaymath}
	d \sqrt{u^T u} = d
\end{displaymath}
Forces
\begin{eqnarray*}
	F_1 & = & \alpha u \\
	F_2 & = & -\alpha u
\end{eqnarray*}
Linearization
\begin{displaymath}
	\sqbr{\matr{ccc}{
		\frac{\alpha}{d}I & -\frac{\alpha}{d}I & -u \\
		-\frac{\alpha}{d}I & \frac{\alpha}{d}I & u \\
		-u^T & u^T & 0
	}}\cubr{\cvvect{
		\Delta{x_1} \\
		\Delta{x_2} \\
		\Delta{\alpha}
	}} = \cubr{\cvvect{
		\alpha u \\
		- \alpha u \\
		d\plbr{1 - \sqrt{u^T u}}
	}}
\end{displaymath}
Constraint Equation Derivative
\begin{displaymath}
	d u^T \dot{u} = 0
\end{displaymath}
Force Derivatives
\begin{eqnarray*}
	\dot{F}_1 & = & \alpha \dot{u} + \dot{\alpha} u \\
	\dot{F}_2 & = & -\alpha \dot{u} - \dot{\alpha} u
\end{eqnarray*}
Linearization
\begin{displaymath}
        \sqbr{\matr{cccccc}{
		\frac{\dot{\alpha}}{d}I & \frac{\alpha}{d}I &
			-\frac{\dot{\alpha}}{d}I & -\frac{\alpha}{d}I &
			-\dot{u} & -u \\
		-\frac{\dot{\alpha}}{d}I & -\frac{\alpha}{d}I &
			\frac{\dot{\alpha}}{d}I & \frac{\alpha}{d}I &
			\dot{u} & u \\
		-\dot{u}^T & -u^T & \dot{u}^T & u^T & 0 & 0
	}}\cubr{\cvvect{
		\Delta{x_1} \\
		\Delta{\dot{x}_1} \\
		\Delta{x_2} \\
		\Delta{\dot{x}_2} \\
		\Delta{\alpha} \\
		\Delta{\dot{\alpha}}
	}} = \cubr{\cvvect{
		\alpha \dot{u} + \dot{\alpha} u \\
		-\alpha \dot{u} - \dot{\alpha} u \\
		d u^T \dot{u}
	}}
\end{displaymath}




\subsubsection{Distance Joint With Offsets}
Definitions:
\begin{displaymath}
	u = \frac{1}{d}\plbr{x_2 + f_2 - x_1 - f_1}
\end{displaymath}
Limitations:
\begin{displaymath}
	d > 0
\end{displaymath}
Constraint equation 
\begin{displaymath}
	d \sqrt{u^T u} = d
\end{displaymath}
Forces:
\begin{eqnarray*}
	F_1 & = & \alpha u \\
	M_1 & = & \alpha f_1 \times u \\
	F_2 & = & -\alpha u \\
	M_2 & = & -\alpha f_2 \times u
\end{eqnarray*}
Linearization:
\begin{displaymath}
	\sqbr{\matr{ccccc}{
		\frac{\alpha}{d}I & -\frac{\alpha}{d}f_1\times{} &
			-\frac{\alpha}{d}I & \frac{\alpha}{d}f_2\times{} & -u \\
		\frac{\alpha}{d}f_1\times{} & 
			-\frac{\alpha}{d}\plbr{f_1 + u}\times{f_1\times{}} &
			-\frac{\alpha}{d}f_1\times{} & 
			\frac{\alpha}{d}f_1\times{f_2\times{}} & 
			-f_1\times{u} \\
		-\frac{\alpha}{d}I & \frac{\alpha}{d}f_1\times{} &
			\frac{\alpha}{d}I & -\frac{\alpha}{d}f_2\times{} & u \\
		-\frac{\alpha}{d}f_2\times{} &
			\frac{\alpha}{d}f_2\times{f_1\times{}} &
			\frac{\alpha}{d}f_2\times{} &
			- \frac{\alpha}{d}\plbr{f_2 - u}\times{f_2\times{}} &
			f_2\times{u} \\
		-u^T & - \plbr{f_1\times{u}}^T & 
			u^T & \plbr{f_2\times{u}}^T & 0
	}}\cubr{\cvvect{
		\Delta{x_1} \\
		\Delta{g_1} \\
		\Delta{x_2} \\
		\Delta{g_2} \\
		\Delta{\alpha}
	}}
\end{displaymath}
\begin{displaymath}
	\mbox{\hspace{100mm}} = \cubr{\cvvect{
		\alpha u \\
		\alpha f_1\times{u} \\
		-\alpha u \\
		-\alpha f_2\times{u} \\
		d\plbr{1 - \sqrt{u^T u}}
	}}
\end{displaymath}
Constraint Equation Derivative
\begin{displaymath}
	d u^T\dot{u} = 0
\end{displaymath}
Forces:
\begin{eqnarray*}
	\dot{F}_1 & = &  \alpha \dot{u} + \dot{\alpha} u \\
	\dot{M}_1 & = & \alpha \plbr{\omega_1\times{f_1}} \times u 
		+ \alpha f_1 \times \dot{u}
		+ \dot{\alpha} f_1 \times u \\
	\dot{F}_2 & = & -\alpha \dot{u} - \dot{\alpha} u \\
	\dot{M}_2 & = & -\alpha \plbr{\omega_2 \times{f_2}} \times u
		- \alpha f_2 \times \dot{u}
		- \dot{\alpha} f_2 \times u
\end{eqnarray*}
Linearization:

\subsection{Revolute hinge (PlaneHingeJoint)}
Joint data
\begin{displaymath}
\T d_1, \T d_2, \T R_{h1}, \T R_{h2}
\end{displaymath}
where:\\
$\T d_1$, $\T d_2$: offset of nodes 1,2 in node reference;\\
$\T R_{h1}$, $\T R_{h2}$: joint relative orientation wrt. nodes 1,2 (FIXME).\\

\noindent
Constraint equations (normalized by dCoef)
\begin{eqnarray*}
	(\T x_1+\T R_1\cdot \T d_1) - (\T x_2+\T R_1\cdot \T d_2)& = & 0 \\
	(\T R_1\cdot \T R_{h1})[3]\cdot (\T R_2\cdot \T R_{h2})[2] & = & 0 \\
	(\T R_1\cdot \T R_{h1})[3]\cdot (\T R_2\cdot \T R_{h2})[1] & = & 0 \\
\end{eqnarray*}
where:\\
$\T x_1$, $\T x_2$: positions of nodes 1,2;\\
$\T R_{1}$, $\T R_{2}$: orientation of nodes 1, 2.\\

\noindent
Residual vector:
\begin{eqnarray*}
	\mathrm{node1\ momentum}:\ 1-3& -= & \T F\\
	\mathrm{node1\ angular\ momentum}:\ 4-6& -= & 
		(\T R_1\cdot \T d_1) \times \T F + \\
	&&	(\T R_2\cdot \T R_{h2})[2]\times 
		(\T R_1\cdot \T R_{h1})[3]*\T M[1] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]\times
		(\T R_2\cdot \T R_{h2})[1]*\T M[2]\\
	\mathrm{node2\ momentum}:\ 7-9& += & \T F\\
	\mathrm{node2\ angular\ momentum}:\ 10-12& += & 
		(\T R_2\cdot \T d_2) \times \T F + \\
	&&	(\T R_2\cdot \T R_{h2})[2]\times 
		(\T R_1\cdot \T R_{h1})[3]*\T M[1] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]\times
		(\T R_2\cdot \T R_{h2})[1]*\T M[2]\\
	\mathrm{constraint}:\ 13-15& = &  ((\T x_1+\T R_1\cdot \T d_1) - 
			(\T x_2+\T R_1\cdot \T d_2))/dCoef\\
	\mathrm{constraint}:\ 16& = &  ((\T R_1\cdot \T R_{h1})[3]\cdot 
			(\T R_2\cdot \T R_{h2})[2])/dCoef\\
	\mathrm{constraint}:\ 17& = &  ((\T R_1\cdot \T R_{h1})[3]\cdot 
			(\T R_2\cdot \T R_{h2})[1])/dCoef\\
\end{eqnarray*}
where:\\
$\T F$: constraint reaction force;\\
$\T M$: constraint moment reaction (third component null).\\

\noindent
Friction:
\begin{itemize}
\item add third component of constraint moment $\T M$
\item add a costraint equation; this could be one of the following:
	\begin{itemize}
	\item direct definition of $\T M[3]$ in function of relative velocity,
		friction coeff and $\T F$
	\item impose null relative velocity
	\end{itemize}
\item optionally add internal states dynamic $z$ (for friction)
\end{itemize}
\subsubsection{add third component of constraint moment $\T M$}
Residual vector:
\begin{eqnarray*}
	\mathrm{node1\ momentum}:\ 1-3& -= & \T F\\
	\mathrm{node1\ angular\ momentum}:\ 4-6& -= & 
		(\T R_1\cdot \T d_1) \times \T F + \\
	&&	(\T R_2\cdot \T R_{h2})[2]\times 
		(\T R_1\cdot \T R_{h1})[3]*\T M[1] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]\times
		(\T R_2\cdot \T R_{h2})[1]*\T M[2] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]*\T M[3]\\
	\mathrm{node2\ momentum}:\ 7-9& += & \T F\\
	\mathrm{node2\ angular\ momentum}:\ 10-12& += & 
		(\T R_2\cdot \T d_2) \times \T F + \\
	&&	(\T R_2\cdot \T R_{h2})[2]\times 
		(\T R_1\cdot \T R_{h1})[3]*\T M[1] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]\times
		(\T R_2\cdot \T R_{h2})[1]*\T M[2] +\\
	&&	(\T R_1\cdot \T R_{h1})[3]*\T M[3]\\
	\mathrm{constraint}:\ 13-15& = &  ((\T x_1+\T R_1\cdot \T d_1) - 
			(\T x_2+\T R_1\cdot \T d_2))/dCoef\\
	\mathrm{constraint}:\ 16& = &  ((\T R_1\cdot \T R_{h1})[3]\cdot 
			(\T R_2\cdot \T R_{h2})[2])/dCoef\\
	\mathrm{constraint}:\ 17& = &  ((\T R_1\cdot \T R_{h1})[3]\cdot 
			(\T R_2\cdot \T R_{h2})[1])/dCoef\\
	\mathrm{friction:}\ 18& = &  \T M[3] -f(\T F, v, 
			\mathrm{friction\ coef})\\
		& = &  (\mathrm{rel\ velocity})[3]\\
	\mathrm{(optional)\ friction\ states:}\ 19...& = &  \dot{z} - g(z,v)
\end{eqnarray*}
where $v$ is the relative velocity
$v = r * (\T \omega_{1}-\T \omega_{2})\cdot(\T R_1\cdot \T R_{h1})[3]$.
The constraint is based on positions. This means that during integration 
$(\T \omega_{1}-\T \omega_{2})$ will NOT have exactly the
direction $(\T R_1\cdot \T R_{h1})[3]$. We choose to disregard this error.
The friction moment should be along $(\T R_1\cdot \T R_{h1})[3]$.\\
$r$ is the joint radius.\\
CHECK THIS!!!\\
Explicit form of friction moment contribution 
(FIXME: remove vector $(\T R_1\cdot \T R_{h1})[3]$ and write scalar equation???):\\
$f(\T F, \mathrm{rel\ velocity})$:
$\T M[3] = \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z})) * (\T R_1\cdot \T R_{h1})[3] * 
	||\T F|| * f_{\mathrm{c}}(v,z,\dot{z})$,\\
with $\T R_{h1}$ constant.\\
Variation of friction moment contribution:
\begin{eqnarray*}
\delta (\T M[3] (\T R_1\cdot \T R_{h1})[3])
	&=& \T M[3] * (\T R_{\delta 1} \times \T R_1)[3]+\\
	&& (\T R_1\cdot \T R_{h1})[3]) * \delta \T M[3]\\
	&=& \T M[3] * \T R_1^T \cdot (\T R_{\delta 1} \times )[3]+\\
	&& (\T R_1\cdot \T R_{h1})[3]) * \delta \T M[3]
\end{eqnarray*}
Variation of friction moment contribution component:
\begin{eqnarray*}
\delta \T M[3] &=& \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z})) * 
		f_{\mathrm{c}}(v,z,\dot{z}) *
		\frac{\displaystyle\T F}{\displaystyle||\T F||} 
		\cdot \delta \T F+\\
	&& \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z})) * (\T R_1\cdot \T R_{h1})[3] * 
		||\T F|| *
		\frac{\displaystyle \partial f_{\mathrm{c}}}
			{\displaystyle \partial v} * \delta v+\\
	&&	||\T F|| * f_{\mathrm{c}}(v,z,\dot{z}) *
			\frac{\displaystyle \partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
			{\displaystyle \partial ||\T F||} 
			\frac{\displaystyle \partial ||\T F||}{\displaystyle\partial\T F}
			\cdot \delta \T F+\\
	&&	||\T F|| * f_{\mathrm{c}}(v,z,\dot{z}) *
			\frac{\displaystyle \partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
			{\displaystyle \partial f_{\mathrm{c}}(v,z,\dot{z})} *
			\frac{\displaystyle \partial f_{\mathrm{c}}}
				{\displaystyle \partial v} * \delta v\\
	&=& \left (\begin{array}{l}
		\mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z})) * 
			f_{\mathrm{c}}(v,z,\dot{z})
			\frac{\displaystyle\T F}{\displaystyle||\T F||}\\
		||\T F|| * f_{\mathrm{c}}(v,z,\dot{z}) *
			\frac{\displaystyle \partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
			{\displaystyle \partial ||\T F||}
		\end{array} 
		\right )\cdot \delta \T F+\\
	&& \left ( \begin{array}{l}
		\mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z})) * ||\T F||\\
		||\T F|| * f_{\mathrm{c}}(v,z,\dot{z}) *
			\frac{\displaystyle \partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
			{\displaystyle \partial f_{\mathrm{c}}(v,z,\dot{z})}
		\end{array} \right ) *
		\left\{\begin{array}{l}
			\frac{\displaystyle \partial f_{\mathrm{c}}}
				{\displaystyle \partial v} * \delta v\\
			\frac{\displaystyle \partial f_{\mathrm{c}}}
				{\displaystyle \partial z} * \delta z\\
			\frac{\displaystyle \partial f_{\mathrm{c}}}
				{\displaystyle \partial \dot{z}} * \delta \dot{z}\\			
		\end{array}\right\}
\end{eqnarray*}
dove 
\begin{itemize}
\item
$v=r * (\T \omega_{1}-\T \omega_{2})\cdot(\T R_1\cdot \T R_{h1})[3]$
e quindi
\begin{eqnarray*}
\delta v &=& d * (\T R_1\cdot \T R_{h1})[3] \cdot (\delta \T \omega_{1}- \delta \T \omega_{2}) +\\
	&& d * (\T \omega_{1}-\T \omega_{2})\cdot (\T R_{\delta 1} \times \T R_1 \cdot \T R_{h1})[3]\\
	&=& d * (\T R_1\cdot \T R_{h1})[3] \cdot (\delta \T \omega_{1}- \delta \T \omega_{2}) +\\
	&& d * (\T \omega_{1}-\T \omega_{2})\cdot \T R_{h1}^T \cdot \T R_1^T \cdot (\T R_{\delta 1} \times )[3]
\end{eqnarray*}
\item
$
\mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))=
r * 
C_\alpha(
	\alpha(\mathrm{costants},
		f_{\mathrm{c}}(v,z,\dot{z}),
		||\T F||,
		f_{\mathrm{c}}(v,z,\dot{z})
	)
) 
\frac{\displaystyle 1}{\displaystyle \sqrt{1+f_{\mathrm{c}}^2(v,z,\dot{z})}}
$
\item
$
\alpha(\mathrm{costants},
	f_{\mathrm{c}}(v,z,\dot{z}),
	||\T F||,
	f_{\mathrm{c}}(v,z,\dot{z})
) =
\sin^{-1}\left(
	\sqrt{
		\frac{\displaystyle 2*31*||\T F||}
			{\displaystyle E*b*\sqrt{1+f_{\mathrm{c}}^2(v,z,\dot{z})}}
		\frac{\displaystyle r'/r}
			{\displaystyle r'-r}
	}
\right)
$
\item for very low joint loads (angle of contact $\alpha< 20^{\mathrm{o}}$,
i.e. about less that 1\% of the joint allowable load)
we can safely assume $C_\alpha\approx 1$
so that\\ 
$
\mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))\approx
r * 
\frac{\displaystyle 1}{\displaystyle \sqrt{1+f_{\mathrm{c}}^2(v,z,\dot{z})}}
$,\\

$
\frac{\displaystyle\partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
	{\displaystyle \partial ||\T F||} = \T 0
$\\
and\\
$
\frac{\displaystyle\partial \mathrm{sh\_c}(||\T F||, f_{\mathrm{c}}(v,z,\dot{z}))}
	{\displaystyle\partial \mathrm{f_{\mathrm{c}}(v,z,\dot{z})}} =
	-r * (1+f_{\mathrm{c}}^2(v,z,\dot{z}))^{-3/2}*f_{\mathrm{c}}(v,z,\dot{z})
$
\end{itemize}

\section{Deformable Constraints}

\subsection{Deformable Hinge}



\bibliographystyle{unsrt}
\bibliography{mybib}


\pagebreak
\noindent
Pierangelo Masarati \\
Dipartimento di Ingegneria Aerospaziale, Politecnico di Milano \\
via La Masa 34, 20156 Milano, Italy \\
Tel.: ++39 02 2399 8309 \\
Fax: ++39 02 2399 8334 \\
E-mail: \htmladdnormallink{\texttt{masarati@aero.polimi.it}}{mailto:masarati@aero.polimi.it} \\
Web: \htmladdnormallink{\texttt{http://www.aero.polimi.it/\~{}mbdyn/}}{http://www.aero.polimi.it/~mbdyn/} \\
Web: \htmladdnormallink{\texttt{http://www.aero.polimi.it/\~{}masarati/}}{http://www.aero.polimi.it/~masarati/} \\
Web: \htmladdnormallink{\texttt{http://mbdyn.aero.polimi.it/\~{}masarati/MBDyn-input/manual/index.html}}{http://mbdyn.aero.polimi.it/~masarati/MBDyn-input/manual/index.html}

\end{document}
