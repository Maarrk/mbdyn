C MBDyn (C) is a multibody analysis code. 
C http://www.mbdyn.org
C 
C Copyright (C) 1996-2000
C 
C Pierangelo Masarati	<masarati@aero.polimi.it>
C Paolo Mantegazza	<mantegazza@aero.polimi.it>
C 
C Dipartimento di Ingegneria Aerospaziale - Politecnico di Milano
C via La Masa, 34 - 20156 Milano, Italy
C http://www.aero.polimi.it
C 
C Changing this copyright notice is forbidden.
C 
C This program is free software; you can redistribute it and/or modify
C it under the terms of the GNU General Public License as published by
C the Free Software Foundation; either version 2 of the License, or
C any later version.
C 
C This program is distributed in the hope that it will be useful,
C but WITHOUT ANY WARRANTY; without even the implied warranty of
C MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C GNU General Public License for more details.
C 
C You should have received a copy of the GNU General Public License
C along with this program; if not, write to the Free Software
C Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
C
C
C NOTE: This code comes from Harwell; it cannot be freely distributed.
C       You are urged to download it from netlib:
C               http://www.netlib.org/harwell/index.html
C       and to add it by yourself to the MBDyn distribution.
C       Few changes need be done to accommodate
C       the library into the code. Unfortunately, until Harwell releases
C       the code for free you are on your own. You can still compile the 
C       code only with Meshcach:
C               http://www.netlib.org/c/meschach/
C       but it will run much slower.
C
C 
*######DATE 13 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MA28AD MA28BD MA28CD
C###### CALLS   MA30    MC20    MC22    MC23    MC24
	SUBROUTINE MA28AD(N,NZ,A,LICN,IRN,LIRN,ICN,U,IKEEP,IW,W,IFLAG)
C THIS SUBROUTINE PERFORMS THE LU FACTORIZATION OF A.
C
C THE PARAMETERS ARE AS FOLLOWS.....
C N     ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ    NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED BY SUBROUTINE.
C A IS A  REAL ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF MATRIX ON ENTRY
C     AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY MC20A/AD AND
C     MC23A/AD AND ALTERED BY MA30A/AD.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY SUBROUTINE.
C IRN   INTEGER ARRAY OF LENGTH LIRN.  HOLDS ROW INDICES ON INPUT.
C     USED AS WORKSPACE BY MA30A/AD TO HOLD COLUMN ORIENTATION OF
C     MATRIX.
C LIRN  INTEGER  LENGTH OF ARRAY IRN. NOT ALTERED BY THE SUBROUTINE.
C ICN   INTEGER ARRAY OF LENGTH LICN.  HOLDS COLUMN INDICES ON ENTRY
C     AND COLUMN INDICES OF DECOMPOSED MATRIX ON EXIT. REORDERED BY
C     MC20A/AD AND MC23A/AD AND ALTERED BY MA30A/AD.
C U     REAL VARIABLE  SET BY USER TO CONTROL BIAS TOWARDS NUMERIC OR
C     SPARSITY PIVOTING.  U=1.0 GIVES PARTIAL PIVOTING WHILE U=0. DOES
C     NOT CHECK MULTIPLIERS AT ALL.  VALUES OF U GREATER THAN ONE ARE
C     TREATED AS ONE WHILE NEGATIVE VALUES ARE TREATED AS ZERO.  NOT
C     ALTERED BY SUBROUTINE.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N  USED AS WORKSPACE BY MA28A/AD
C     (SEE LATER COMMENTS).  IT IS NOT REQUIRED TO BE SET ON ENTRY
C     AND, ON EXIT, IT CONTAINS INFORMATION ABOUT THE DECOMPOSITION.
C     IT SHOULD BE PRESERVED BETWEEN THIS CALL AND SUBSEQUENT CALLS
C     TO MA28B/BD OR MA28C/CD.
C     IKEEP(I,1),I=1,N  HOLDS THE TOTAL LENGTH OF THE PART OF ROW I
C     IN THE DIAGONAL BLOCK.
C     ROW IKEEP(I,2),I=1,N  OF THE INPUT MATRIX IS THE ITH ROW IN
C     PIVOT ORDER.
C     COLUMN IKEEP(I,3),I=1,N  OF THE INPUT MATRIX IS THE ITH COLUMN
C     IN PIVOT ORDER.
C     IKEEP(I,4),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN
C     THE L PART OF THE L/U DECOMPOSITION.
C     IKEEP(I,5),I=1,N  HOLDS THE LENGTH OF THE PART OF ROW I IN THE
C     OFF-DIAGONAL BLOCKS.  IF THERE IS ONLY ONE DIAGONAL BLOCK,
C     IKEEP(1,5) WILL BE SET TO -1.
C IW    INTEGER ARRAY OF LENGTH 8*N.  IF THE OPTION NSRCH.LE.N IS
C     USED, THEN THE LENGTH OF ARRAY IW CAN BE REDUCED TO 7*N.
C W REAL ARRAY  LENGTH N.  USED BY MC24A/AD BOTH AS WORKSPACE AND TO
C     RETURN GROWTH ESTIMATE IN W(1).  THE USE OF THIS ARRAY BY MA28A/AD
C     IS THUS OPTIONAL DEPENDING ON COMMON BLOCK LOGICAL VARIABLE GROW.
C IFLAG  INTEGER VARIABLE  USED AS ERROR FLAG BY ROUTINE.  A POSITIVE
C     OR ZERO VALUE ON EXIT INDICATES SUCCESS.  POSSIBLE NEGATIVE
C     VALUES ARE -1 THROUGH -14.
C
C
C COMMON AND PRIVATE VARIABLES.
C     COMMON BLOCK MA28F/FD IS USED MERELY
C     TO COMMUNICATE WITH COMMON BLOCK MA30F/FD  SO THAT THE USER
C     NEED NOT DECLARE THIS COMMON BLOCK IN HIS MAIN PROGRAM.
C THE COMMON BLOCK VARIABLES ARE AS FOLLOWS ...
C LP,MP  INTEGER  DEFAULT VALUE 6 (LINE PRINTER).  UNIT NUMBER
C     FOR ERROR MESSAGES AND DUPLICATE ELEMENT WARNING RESP.
C NLP,MLP  INTEGER  UNIT NUMBER FOR MESSAGES FROM MA30A/AD AND
C     MC23A/AD RESP.  SET BY MA28A/AD TO VALUE OF LP.
C LBLOCK  LOGICAL  DEFAULT VALUE TRUE.  IF TRUE MC23A/AD IS USED
C     TO FIRST PERMUTE THE MATRIX TO BLOCK LOWER TRIANGULAR FORM.
C GROW    LOGICAL  DEFAULT VALUE TRUE.  IF TRUE THEN AN ESTIMATE
C     OF THE INCREASE IN SIZE OF MATRIX ELEMENTS DURING L/U
C     DECOMPOSITION IS GIVEN BY MC24A/AD.
C EPS,RMIN,RESID  REAL/DOUBLE PRECISION VARIABLES NOT REFERENCED
C     BY MA28A/AD.
C IRNCP,ICNCP  INTEGER  SET TO NUMBER OF COMPRESSES ON ARRAYS IRN AND
C     ICN/A RESPECTIVELY.
C MINIRN,MINICN  INTEGER  MINIMUM LENGTH OF ARRAYS IRN AND ICN/A
C     RESPECTIVELY, FOR SUCCESS ON FUTURE RUNS.
C IRANK  INTEGER   ESTIMATED RANK OF MATRIX.
C MIRNCP,MICNCP,MIRANK,MIRN,MICN INTEGER VARIABLES.  USED TO
C     COMMUNICATE BETWEEN MA30F/FD AND MA28F/FD VALUES OF ABOVENAMED
C     VARIABLES WITH SOMEWHAT SIMILAR NAMES.
C ABORT1,ABORT2  LOGICAL VARIABLES WITH DEFAULT VALUE TRUE.  IF FALSE
C     THEN DECOMPOSITION WILL BE PERFORMED EVEN IF THE MATRIX IS
C     STRUCTURALLY OR NUMERICALLY SINGULAR RESPECTIVELY.
C ABORTA,ABORTB  LOGICAL VARIABLES USED TO COMMUNICATE VALUES OF
C     ABORT1 AND ABORT2 TO MA30A/AD.
C ABORT  LOGICAL  USED TO COMMUNICATE VALUE OF ABORT1 TO MC23A/AD.
C ABORT3  LOGICAL VARIABLE NOT REFERENCED BY MA28A/AD.
C IDISP   INTEGER ARRAY  LENGTH 2.  USED TO COMMUNICATE INFORMATION
C     ON DECOMPOSITION BETWEEN THIS CALL TO MA28A/AD AND SUBSEQUENT
C     CALLS TO MA28B/BD AND MA28C/CD.  ON EXIT, IDISP(1) AND
C     IDISP(2) INDICATE POSITION IN ARRAYS A AND ICN OF THE
C     FIRST AND LAST ELEMENTS IN THE L/U DECOMPOSITION OF THE
C     DIAGONAL BLOCKS, RESPECTIVELY.
C NUMNZ  INTEGER  STRUCTURAL RANK OF MATRIX.
C NUM    INTEGER  NUMBER OF DIAGONAL BLOCKS.
C LARGE  INTEGER  SIZE OF LARGEST DIAGONAL BLOCK.
C
C SEE BLOCK DATA FOR FURTHER COMMENTS ON COMMON BLOCK VARIABLES.
C SEE CODE FOR COMMENTS ON PRIVATE VARIABLES.
C
C     .. Scalar Arguments ..
	DOUBLE PRECISION U
	INTEGER IFLAG,LICN,LIRN,N,NZ
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),W(N)
	INTEGER ICN(LICN),IKEEP(N,5),IRN(LIRN),IW(N,8)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION UPRIV,ZERO
	INTEGER I,I1,IEND,II,J,J1,J2,JAY,JJ,KNUM,LENGTH,MOVE,NEWJ1,NEWPOS
C     ..
C     .. External Subroutines ..
	EXTERNAL MA28JD,MA30AD,MC20AD,MC22AD,MC23AD,MC24AD
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1,MAX0
C     ..
C     .. Common blocks ..
	COMMON /MA28ED/LP,MP,LBLOCK,GROW
	COMMON /MA28FD/EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,IRANK,
     +       ABORT1,ABORT2
	COMMON /MA28GD/IDISP
	COMMON /MA28HD/TOL,THEMAX,BIG,DXMAX,ERRMAX,DRES,CGCE,NDROP,MAXIT,
     +       NOITER,NSRCH,ISTART,LBIG
	COMMON /MA30ED/NLP,ABORTA,ABORTB,ABORT3
	COMMON /MA30FD/MIRNCP,MICNCP,MIRANK,MIRN,MICN
	COMMON /MA30ID/TOL1,BIG1,NDROP1,NSRCH1,LBIG1
	COMMON /MC23BD/MLP,NUMNZ,NUM,LARGE,ABORT
	DOUBLE PRECISION BIG,BIG1,CGCE,DRES,DXMAX,EPS,ERRMAX,RESID,RMIN,
     +                 THEMAX,TOL,TOL1
	INTEGER ICNCP,IRANK,IRNCP,ISTART,LARGE,LP,MAXIT,MICN,MICNCP,
     +        MINICN,MINIRN,MIRANK,MIRN,MIRNCP,MLP,MP,NDROP,NDROP1,NLP,
     +        NOITER,NSRCH,NSRCH1,NUM,NUMNZ
	LOGICAL ABORT,ABORT1,ABORT2,ABORT3,ABORTA,ABORTB,GROW,LBIG,LBIG1,
     +        LBLOCK
	INTEGER IDISP(2)
C     ..
C     .. Data statements ..
C
C SOME  INITIALIZATION AND TRANSFER OF INFORMATION BETWEEN
C     COMMON BLOCKS (SEE EARLIER COMMENTS).
	DATA  ZERO/0.0D0/
C     ..
	IFLAG  = 0
	ABORTA = ABORT1
	ABORTB = ABORT2
	ABORT  = ABORT1
	MLP    = LP
	NLP    = LP
	TOL1   = TOL
	LBIG1  = LBIG
	NSRCH1 = NSRCH
C UPRIV PRIVATE COPY OF U IS USED IN CASE IT IS OUTSIDE
C     RANGE  ZERO TO ONE  AND  IS THUS ALTERED BY MA30A/AD.
	UPRIV  = U
C SIMPLE DATA CHECK ON INPUT VARIABLES AND ARRAY DIMENSIONS.
	IF (N.GT.0) GO TO 10
	IFLAG  = -8
        IF (LP.NE.0) CALL W28AD9(LP,N)
	GO TO 210

   10 IF (NZ.GT.0) GO TO 20
	IFLAG  = -9
        IF (LP.NE.0) CALL W28AD8(LP,NZ)
	GO TO 210

   20 IF (LICN.GE.NZ) GO TO 30
	IFLAG  = -10
        IF (LP.NE.0) CALL W28AD7(LP,LICN)
	GO TO 210

   30 IF (LIRN.GE.NZ) GO TO 40
	IFLAG  = -11
        IF (LP.NE.0) CALL W28AD6(LP,LIRN)
	GO TO 210
C
C DATA CHECK TO SEE IF ALL INDICES LIE BETWEEN 1 AND N.
   40 DO 50 I = 1,NZ
	   IF (IRN(I).GT.0 .AND. IRN(I).LE.N .AND. ICN(I).GT.0 .AND.
     +       ICN(I).LE.N) GO TO 50
           IF (IFLAG.EQ.0 .AND. LP.NE.0) CALL W28AD5(LP)
	   IFLAG  = -12
           IF (LP.NE.0) CALL W28AD4(LP,I,A(I),IRN(I),ICN(I))
   50 CONTINUE
	IF (IFLAG.LT.0) GO TO 220
C
C SORT MATRIX INTO ROW ORDER.
	CALL MC20AD(N,NZ,A,ICN,IW,IRN,0)
C PART OF IKEEP IS USED HERE AS A WORK-ARRAY.  IKEEP(I,2) IS
C     THE LAST ROW TO HAVE A NON-ZERO IN COLUMN I.  IKEEP(I,3)
C     IS THE OFF-SET OF COLUMN I FROM THE START OF THE ROW.
	DO 60 I = 1,N
	   IKEEP(I,2) = 0
	   IKEEP(I,1) = 0
   60 CONTINUE
C
C CHECK FOR DUPLICATE ELEMENTS .. SUMMING ANY SUCH ENTRIES AND
C     PRINTING A WARNING MESSAGE ON UNIT MP.
C MOVE IS EQUAL TO THE NUMBER OF DUPLICATE ELEMENTS FOUND.
	MOVE   = 0
C THE LOOP ALSO CALCULATES THE LARGEST ELEMENT IN THE MATRIX, THEMAX.
	THEMAX = ZERO
C J1 IS POSITION IN ARRAYS OF FIRST NON-ZERO IN ROW.
	J1     = IW(1,1)
	DO 130 I = 1,N
	   IEND   = NZ + 1
	   IF (I.NE.N) IEND   = IW(I+1,1)
	   LENGTH = IEND - J1
	   IF (LENGTH.EQ.0) GO TO 130
	   J2     = IEND - 1
	   NEWJ1  = J1 - MOVE
	   DO 120 JJ = J1,J2
		J      = ICN(JJ)
		THEMAX = DMAX1(THEMAX,DABS(A(JJ)))
		IF (IKEEP(J,2).EQ.I) GO TO 110
C FIRST TIME COLUMN HAS OCURRED IN CURRENT ROW.
		IKEEP(J,2) = I
		IKEEP(J,3) = JJ - MOVE - NEWJ1
		IF (MOVE.EQ.0) GO TO 120
C SHIFT NECESSARY BECAUSE OF  PREVIOUS DUPLICATE ELEMENT.
		NEWPOS = JJ - MOVE
		A(NEWPOS) = A(JJ)
		ICN(NEWPOS) = ICN(JJ)
		GO TO 120
C DUPLICATE ELEMENT.
  110       MOVE   = MOVE + 1
		LENGTH = LENGTH - 1
		JAY    = IKEEP(J,3) + NEWJ1
                IF (MP.NE.0) CALL W28AD3(MP,I,J,A(JJ))
		A(JAY) = A(JAY) + A(JJ)
		THEMAX = DMAX1(THEMAX,DABS(A(JAY)))
  120    CONTINUE
	   IKEEP(I,1) = LENGTH
	   J1     = IEND
  130 CONTINUE
C
C KNUM IS ACTUAL NUMBER OF NON-ZEROS IN MATRIX WITH ANY MULTIPLE
C     ENTRIES COUNTED ONLY ONCE.
	KNUM   = NZ - MOVE
	IF (.NOT.LBLOCK) GO TO 140
C
C PERFORM BLOCK TRIANGULARISATION.
	CALL MC23AD(N,ICN,A,LICN,IKEEP,IDISP,IKEEP(1,2),IKEEP(1,3),
     +           IKEEP(1,5),IW(1,3),IW)
	IF (IDISP(1).GT.0) GO TO 170
	IFLAG  = -7
	IF (IDISP(1).EQ.-1) IFLAG  = -1
        IF (LP.NE.0) CALL W28AD2(LP)
	GO TO 210
C
C BLOCK TRIANGULARIZATION NOT REQUESTED.
C MOVE STRUCTURE TO END OF DATA ARRAYS IN PREPARATION FOR
C     MA30A/AD.
C ALSO SET LENOFF(1) TO -1 AND SET PERMUTATION ARRAYS.
  140 DO 150 I = 1,KNUM
	   II     = KNUM - I + 1
	   NEWPOS = LICN - I + 1
	   ICN(NEWPOS) = ICN(II)
	   A(NEWPOS) = A(II)
  150 CONTINUE
	IDISP(1) = 1
	IDISP(2) = LICN - KNUM + 1
	DO 160 I = 1,N
	   IKEEP(I,2) = I
	   IKEEP(I,3) = I
  160 CONTINUE
	IKEEP(1,5) = -1
  170 IF (LBIG) BIG1   = THEMAX
	IF (NSRCH.LE.N) GO TO 180
C
C PERFORM L/U DECOMOSITION ON DIAGONAL BLOCKS.
	CALL MA30AD(N,ICN,A,LICN,IKEEP,IKEEP(1,4),IDISP,IKEEP(1,2),
     +           IKEEP(1,3),IRN,LIRN,IW(1,2),IW(1,3),IW(1,4),IW(1,5),
     +           IW(1,6),IW(1,7),IW(1,8),IW,UPRIV,IFLAG)
	GO TO 190
C THIS CALL IF USED IF NSRCH HAS BEEN SET LESS THAN OR EQUAL N.
C     IN THIS CASE, TWO INTEGER WORK ARRAYS OF LENGTH CAN BE SAVED.
  180 CALL MA30AD(N,ICN,A,LICN,IKEEP,IKEEP(1,4),IDISP,IKEEP(1,2),
     +           IKEEP(1,3),IRN,LIRN,IW(1,2),IW(1,3),IW(1,4),IW(1,5),
     +           IW,IW,IW(1,6),IW,UPRIV,IFLAG)
C
C TRANSFER COMMON BLOCK INFORMATION.
  190 MINIRN = MAX0(MIRN,NZ)
	MINICN = MAX0(MICN,NZ)
	IRNCP  = MIRNCP
	ICNCP  = MICNCP
	IRANK  = MIRANK
	NDROP  = NDROP1
	IF (LBIG) BIG    = BIG1
	IF (IFLAG.GE.0) GO TO 200
        IF (LP.NE.0) CALL W28AD1(LP)
	GO TO 210
C
C REORDER OFF-DIAGONAL BLOCKS ACCORDING TO PIVOT PERMUTATION.
  200 I1     = IDISP(1) - 1
	IF (I1.NE.0) CALL MC22AD(N,ICN,A,I1,IKEEP(1,5),IKEEP(1,2),
     +                         IKEEP(1,3),IW,IRN)
	I1     = IDISP(1)
	IEND   = LICN - I1 + 1
C
C OPTIONALLY CALCULATE ELEMENT GROWTH ESTIMATE.
	IF (GROW) CALL MC24AD(N,ICN,A(I1),IEND,IKEEP,IKEEP(1,4),W)
C INCREMENT GROWTH ESTIMATE BY ORIGINAL MAXIMUM ELEMENT.
	IF (GROW) W(1)   = W(1) + THEMAX
	IF (GROW .AND. N.GT.1) W(2)   = THEMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
	IF (IFLAG.GE.0 .AND. MOVE.NE.0) IFLAG  = -14
	GO TO 220

  210 CONTINUE
  220 RETURN

C 99999 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'N OUT OF RANGE = ',I10)
C 99998 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'NZ NON POSITIVE = ',I10)
C 99997 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'LICN TOO SMALL = ',I10)
C 99996 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'LIRN TOO SMALL = ',I10)
C 99995 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE INDICES FOUND OUT ',
C      +       'OF RANGE')
C 99994 FORMAT (1X,I6,'TH ELEMENT WITH VALUE ',1P,D12.4,/,20X,
C      +       ' IS OUT OF RANGE WITH INDICES ',I8,' ,',I8)
C 99993 FORMAT (' DUPLICATE ELEMENT IN POSITION ',I8,',',I8,
C      +       ' WITH VALUE ',1P,D12.4)
C 99992 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'ERROR RETURN FROM MC23A/AD')
C 99991 FORMAT (' ERROR RETURN FROM MA28A/AD BECAUSE ',
C      +       'ERROR RETURN FROM MA30A/AD')

	END
	SUBROUTINE MA28BD(N,NZ,A,LICN,IVECT,JVECT,ICN,IKEEP,IW,W,IFLAG)
C THIS SUBROUTINE FACTORIZES A MATRIX OF A SIMILAR SPARSITY
C     PATTERN TO THAT PREVIOUSLY FACTORIZED BY MA28A/AD.
C THE PARAMETERS ARE AS FOLLOWS ...
C N      INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C NZ     INTEGER  NUMBER OF NON-ZEROS IN INPUT MATRIX  NOT ALTERED
C     BY SUBROUTINE.
C A      REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  HOLDS NON-ZEROS OF
C     MATRIX ON ENTRY AND NON-ZEROS OF FACTORS ON EXIT.  REORDERED BY
C     MA28D/DD AND ALTERED BY SUBROUTINE MA30B/BD.
C LICN   INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C IVECT,JVECT  INTEGER ARRAYS OF LENGTH NZ.  HOLD ROW AND COLUMN
C     INDICES OF NON-ZEROS RESPECTIVELY.  NOT ALTERED BY SUBROUTINE.
C ICN    INTEGER ARRAY OF LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28B/BD.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28B/BD.
C IW     INTEGER ARRAY  LENGTH 5*N.  USED AS WORKSPACE BY MA28D/DD AND
C     MA30B/BD.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N.  USED AS WORKSPACE
C     BY MA28D/DD,MA30B/BD AND (OPTIONALLY) MC24A/AD.
C IFLAG  INTEGER  USED AS ERROR FLAG WITH POSITIVE OR ZERO VALUE
C     INDICATING SUCCESS.
C
C
C PRIVATE AND COMMON VARIABLES.
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A/AD.
C     THOSE VARIABLES REFERENCED BY MA28B/BD ARE MENTIONED BELOW.
C LP,MP  INTEGERS  USED AS IN MA28A/AD AS UNIT NUMBER FOR ERROR AND
C     WARNING MESSAGES, RESPECTIVELY.
C NLP    INTEGER VARIABLE USED TO GIVE VALUE OF LP TO MA30E/ED.
C EPS    REAL/DOUBLE PRECISION  MA30B/BD WILL OUTPUT A POSITIVE VALUE
C     FOR IFLAG IF ANY MODULUS OF THE RATIO OF PIVOT ELEMENT TO THE
C     LARGEST ELEMENT IN ITS ROW (U PART ONLY) IS LESS THAN EPS (UNLESS
C     EPS IS GREATER THAN 1.0 WHEN NO ACTION TAKES PLACE).
C RMIN   REAL/DOUBLE PRECISION  VARIABLE EQUAL TO THE VALUE OF THIS
C     MINIMUM RATIO IN CASES WHERE EPS IS LESS THAN OR EQUAL TO 1.0.
C MEPS,MRMIN  REAL/DOUBLE PRECISION VARIABLES USED BY THE SUBROUTINE
C     TO COMMUNICATE BETWEEN COMMON BLOCKS MA28F/FD AND MA30G/GD.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A/AD.
C     IT IS UNCHANGED BY MA28B/BD.
C
C SEE BLOCK DATA OR MA28A/AD FOR FURTHER COMMENTS ON VARIABLES
C     IN COMMON.
C SEE CODE FOR COMMENTS ON PRIVATE VARIABLES.
C
C
C
C CHECK TO SEE IF ELEMENTS WERE DROPPED IN PREVIOUS MA28A/AD CALL.
C     .. Scalar Arguments ..
	INTEGER IFLAG,LICN,N,NZ
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),W(N)
	INTEGER ICN(LICN),IKEEP(N,5),IVECT(NZ),IW(N,5),JVECT(NZ)
C     ..
C     .. Local Scalars ..
	INTEGER I1,IDUP,IEND
C     ..
C     .. External Subroutines ..
	EXTERNAL MA28DD,MA30BD,MC24AD
C     ..
C     .. Common blocks ..
	COMMON /MA28ED/MP,LP,LBLOCK,GROW
	COMMON /MA28FD/EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,IRANK,
     +       ABORT1,ABORT2
	COMMON /MA28GD/IDISP
	COMMON /MA28HD/TOL,THEMAX,BIG,DXMAX,ERRMAX,DRES,CGCE,NDROP,MAXIT,
     +       NOITER,NSRCH,ISTART,LBIG
	COMMON /MA30ED/NLP,ABORTA,ABORTB,ABORT3
	COMMON /MA30GD/MEPS,MRMIN
	COMMON /MA30ID/TOL1,BIG1,NDROP1,NSRCH1,LBIG1
	DOUBLE PRECISION BIG,BIG1,CGCE,DRES,DXMAX,EPS,ERRMAX,MEPS,MRMIN,
     +                 RESID,RMIN,THEMAX,TOL,TOL1
	INTEGER ICNCP,IRANK,IRNCP,ISTART,LP,MAXIT,MINICN,MINIRN,MP,NDROP,
     +        NDROP1,NLP,NOITER,NSRCH,NSRCH1
	LOGICAL ABORT1,ABORT2,ABORT3,ABORTA,ABORTB,GROW,LBIG,LBIG1,LBLOCK
	INTEGER IDISP(2)
C     ..
	IF (NDROP.EQ.0) GO TO 10
	IFLAG  = -15
        CALL W28BD9(6,IFLAG,NDROP)
	GO TO 70

   10 IFLAG  = 0
	MEPS   = EPS
	NLP    = LP
C SIMPLE DATA CHECK ON VARIABLES.
	IF (N.GT.0) GO TO 20
	IFLAG  = -11
        IF (LP.NE.0) CALL W28BD8(LP,N)
	GO TO 60

   20 IF (NZ.GT.0) GO TO 30
	IFLAG  = -10
        IF (LP.NE.0) CALL W28BD7(LP,NZ)
	GO TO 60

   30 IF (LICN.GE.NZ) GO TO 40
	IFLAG  = -9
        IF (LP.NE.0) CALL W28BD6(LP,LICN)
	GO TO 60
C
   40 CALL MA28DD(N,A,LICN,IVECT,JVECT,NZ,ICN,IKEEP,IKEEP(1,4),
     +            IKEEP(1,5),IKEEP(1,2),IKEEP(1,3),IW(1,3),IW,W(1),
     +            IFLAG)
C THEMAX IS LARGEST ELEMENT IN MATRIX.
	THEMAX = W(1)
	IF (LBIG) BIG1   = THEMAX
C IDUP EQUALS ONE IF THERE WERE DUPLICATE ELEMENTS, ZERO OTHERWISE.
	IDUP   = 0
	IF (IFLAG.EQ. (N+1)) IDUP   = 1
	IF (IFLAG.LT.0) THEN
          IF (LP.NE.0) CALL W28BD4(LP)
	   GO TO 60

	END IF
C
C PERFORM ROW-GAUSS ELIMINATION ON THE STRUCTURE RECEIVED FROM MA28D/DD
	CALL MA30BD(N,ICN,A,LICN,IKEEP,IKEEP(1,4),IDISP,IKEEP(1,2),
     +            IKEEP(1,3),W,IW,IFLAG)
C
C TRANSFER COMMON BLOCK INFORMATION.
	IF (LBIG) BIG1   = BIG
	RMIN   = MRMIN
	IF (IFLAG.GE.0) GO TO 50
	IFLAG  = -2
        IF (LP.NE.0) CALL W28BD5(LP)
	GO TO 60
C
C OPTIONALLY CALCULATE THE GROWTH PARAMETER.
   50 I1     = IDISP(1)
	IEND   = LICN - I1 + 1
	IF (GROW) CALL MC24AD(N,ICN,A(I1),IEND,IKEEP,IKEEP(1,4),W)
C INCREMENT ESTIMATE BY LARGEST ELEMENT IN INPUT MATRIX.
	IF (GROW) W(1)   = W(1) + THEMAX
	IF (GROW .AND. N.GT.1) W(2)   = THEMAX
C SET FLAG IF THE ONLY ERROR IS DUE TO DUPLICATE ELEMENTS.
	IF (IDUP.EQ.1 .AND. IFLAG.GE.0) IFLAG  = -14
	GO TO 70

   60 CONTINUE
   70 RETURN

C 99999 FORMAT (' ERROR RETURN FROM MA28B/BD WITH IFLAG=',I4,/,I7,
C      +       ' ENTRIES DROPPED FROM STRUCTURE BY MA28A/AD')
C 99998 FORMAT (' ERROR RETURN FROM MA28B/BD BECAUSE ',
C      +       'N OUT OF RANGE = ',I10)
C 99997 FORMAT (' ERROR RETURN FROM MA28B/BD BECAUSE ',
C      +       'NZ NON POSITIVE = ',I10)
C 99996 FORMAT (' ERROR RETURN FROM MA28B/BD BECAUSE ',
C      +       'LICN TOO SMALL = ',I10)
C 99995 FORMAT (' ERROR RETURN FROM MA28B/BD BECAUSE ',
C      +       'ERROR RETURN FROM MA30B/BD')
C 99994 FORMAT (' ERROR RETURN FROM MA28B/BD ')

	END
	SUBROUTINE MA28CD(N,A,LICN,ICN,IKEEP,RHS,W,MTYPE)
C
C THIS SUBROUTINE USES THE FACTORS FROM MA28A/AD OR MA28B/BD TO
C     SOLVE A SYSTEM OF EQUATIONS WITHOUT ITERATIVE REFINEMENT.
C THE PARAMETERS ARE ...
C N   INTEGER  ORDER OF MATRIX  NOT ALTERED BY SUBROUTINE.
C A   REAL/DOUBLE PRECISION ARRAY  LENGTH LICN.  THE SAME ARRAY AS
C     WAS USED IN THE MOST RECENT CALL TO MA28A/AD OR MA28B/BD.
C LICN  INTEGER  LENGTH OF ARRAYS A AND ICN.  NOT ALTERED BY
C     SUBROUTINE.
C ICN    INTEGER ARRAY OF LENGTH LICN.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28C/CD.
C IKEEP  INTEGER ARRAY OF LENGTH 5*N.  SAME ARRAY AS OUTPUT FROM
C     MA28A/AD.  UNCHANGED BY MA28C/CD.
C RHS    REAL/DOUBLE PRECISION ARRAY  LENGTH N.  ON ENTRY, IT HOLDS THE
C     RIGHT HAND SIDE.  ON EXIT, THE SOLUTION VECTOR.
C W      REAL/DOUBLE PRECISION ARRAY  LENGTH N. USED AS WORKSPACE BY
C     MA30C/CD.
C MTYPE  INTEGER  USED TO TELL MA30C/CD TO SOLVE THE DIRECT EQUATION
C     (MTYPE=1) OR ITS TRANSPOSE (MTYPE.NE.1).
C
C COMMON BLOCK VARIABLES.
C UNLESS OTHERWISE STATED COMMON BLOCK VARIABLES ARE AS IN MA28A/AD.
C     THOSE VARIABLES REFERENCED BY MA28C/CD ARE MENTIONED BELOW.
C RESID  REAL/DOUBLE PRECISION  VARIABLE RETURNS MAXIMUM RESIDUAL OF
C     EQUATIONS WHERE PIVOT WAS ZERO.
C MRESID  REAL/DOUBLE PRECISION VARIABLE USED BY MA28C/CD TO
C     COMMUNICATE BETWEEN MA28F/FD AND MA30H/HD.
C IDISP  INTEGER ARRAY  LENGTH 2  THE SAME AS THAT USED BY MA28A/AD.
C     IT IS UNCHANGED BY MA28B/BD.
C
C FURTHER INFORMATION ON COMMON BLOCK VARIABLES CAN BE FOUND IN BLOCK
C     DATA OR MA28A/AD.
C
C THIS CALL PERFORMS THE SOLUTION OF THE SET OF EQUATIONS.
C     .. Scalar Arguments ..
	INTEGER LICN,MTYPE,N
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),RHS(N),W(N)
	INTEGER ICN(LICN),IKEEP(N,5)
C     ..
C     .. External Subroutines ..
	EXTERNAL MA30CD
C     ..
C     .. Common blocks ..
	COMMON /MA28FD/EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,IRANK,
     +       ABORT1,ABORT2
	COMMON /MA28GD/IDISP
	COMMON /MA30HD/MRESID
	DOUBLE PRECISION EPS,MRESID,RESID,RMIN
	INTEGER ICNCP,IRANK,IRNCP,MINICN,MINIRN
	LOGICAL ABORT1,ABORT2
	INTEGER IDISP(2)
C     ..
	CALL MA30CD(N,ICN,A,LICN,IKEEP,IKEEP(1,4),IKEEP(1,5),IDISP,
     +            IKEEP(1,2),IKEEP(1,3),RHS,W,MTYPE)
C TRANSFER COMMON BLOCK INFORMATION.
	RESID  = MRESID
	RETURN

	END
	SUBROUTINE MA28DD(N,A,LICN,IVECT,JVECT,NZ,ICN,LENR,LENRL,LENOFF,
     +                  IP,IQ,IW1,IW,W1,IFLAG)
C THIS SUBROUTINE NEED NEVER BE CALLED BY THE USER DIRECTLY.
C     IT SORTS THE USER'S MATRIX INTO THE STRUCTURE OF THE DECOMPOSED
C     FORM AND CHECKS FOR THE PRESENCE OF DUPLICATE ENTRIES OR
C     NON-ZEROS LYING OUTSIDE THE SPARSITY PATTERN OF THE DECOMPOSITION
C     IT ALSO CALCULATES THE LARGEST ELEMENT IN THE INPUT MATRIX.
C     .. Scalar Arguments ..
	DOUBLE PRECISION W1
	INTEGER IFLAG,LICN,N,NZ
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN)
	INTEGER ICN(LICN),IP(N),IQ(N),IVECT(NZ),IW(N,2),IW1(N,3),
     +        JVECT(NZ),LENOFF(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION AA,ZERO
	INTEGER I,IBLOCK,IDISP2,IDUMMY,II,INEW,IOLD,J1,J2,JCOMP,JDUMMY,JJ,
     +        JNEW,JOLD,MIDPT
	LOGICAL BLOCKL
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1,IABS
C     ..
C     .. Common blocks ..
	COMMON /MA28ED/LP,MP,LBLOCK,GROW
	COMMON /MA28GD/IDISP
	INTEGER LP,MP
	LOGICAL GROW,LBLOCK
	INTEGER IDISP(2)
C     ..
C     .. Data statements ..
	DATA  ZERO/0.0D0/
C     ..
	BLOCKL = LENOFF(1) .GE. 0
C IW1(I,3)  IS SET TO THE BLOCK IN WHICH ROW I LIES AND THE
C     INVERSE PERMUTATIONS TO IP AND IQ ARE SET IN IW1(.,1) AND
C     IW1(.,2) RESP.
C POINTERS TO BEGINNING OF THE PART OF ROW I IN DIAGONAL AND
C   OFF-DIAGONAL BLOCKS ARE SET IN IW(I,2) AND IW(I,1) RESP.
	IBLOCK = 1
	IW(1,1) = 1
	IW(1,2) = IDISP(1)
	DO 10 I = 1,N
	   IW1(I,3) = IBLOCK
	   IF (IP(I).LT.0) IBLOCK = IBLOCK + 1
	   II     = IABS(IP(I)+0)
	   IW1(II,1) = I
	   JJ     = IQ(I)
	   JJ     = IABS(JJ)
	   IW1(JJ,2) = I
	   IF (I.EQ.1) GO TO 10
	   IF (BLOCKL) IW(I,1) = IW(I-1,1) + LENOFF(I-1)
	   IW(I,2) = IW(I-1,2) + LENR(I-1)
   10 CONTINUE
C PLACE EACH NON-ZERO IN TURN INTO ITS CORRECT LOCATION
C    IN THE A/ICN ARRAY.
	IDISP2 = IDISP(2)
	DO 170 I = 1,NZ
C NECESSARY TO AVOID REFERENCE TO UNASSIGNED ELEMENT OF ICN.
	   IF (I.GT.IDISP2) GO TO 20
	   IF (ICN(I).LT.0) GO TO 170
   20    IOLD   = IVECT(I)
	   JOLD   = JVECT(I)
	   AA     = A(I)
C THIS IS A DUMMY LOOP FOR FOLLOWING A CHAIN OF INTERCHANGES.
C   IT WILL BE EXECUTED NZ TIMES IN TOTAL.
	   DO 140 IDUMMY = 1,NZ
C PERFORM SOME VALIDITY CHECKS ON IOLD AND JOLD.
		IF (IOLD.LE.N .AND. IOLD.GT.0 .AND. JOLD.LE.N .AND.
     +          JOLD.GT.0) GO TO 30
		IF (LP.NE.0) WRITE (LP,FMT=99999) I,A(I),IOLD,JOLD
		IFLAG  = -12
		GO TO 180

   30       INEW   = IW1(IOLD,1)
		JNEW   = IW1(JOLD,2)
C ARE WE IN A VALID BLOCK AND IS IT DIAGONAL OR OFF-DIAGONAL?
		IF (IW1(INEW,3)-IW1(JNEW,3)) 40,60,50
   40       IFLAG  = -13
		IF (LP.NE.0) WRITE (LP,FMT=99998) IOLD,JOLD
		GO TO 180

   50       J1     = IW(INEW,1)
		J2     = J1 + LENOFF(INEW) - 1
		GO TO 110
C ELEMENT IS IN DIAGONAL BLOCK.
   60       J1     = IW(INEW,2)
		IF (INEW.GT.JNEW) GO TO 70
		J2     = J1 + LENR(INEW) - 1
		J1     = J1 + LENRL(INEW)
		GO TO 110

   70       J2     = J1 + LENRL(INEW)
C BINARY SEARCH OF ORDERED LIST  .. ELEMENT IN L PART OF ROW.
		DO 100 JDUMMY = 1,N
		   MIDPT  = (J1+J2)/2
		   JCOMP  = IABS(ICN(MIDPT)+0)
		   IF (JNEW-JCOMP) 80,130,90
   80          J2     = MIDPT
		   GO TO 100

   90          J1     = MIDPT
  100       CONTINUE
		IFLAG  = -13
		IF (LP.NE.0) WRITE (LP,FMT=99997) IOLD,JOLD
		GO TO 180
C LINEAR SEARCH ... ELEMENT IN L PART OF ROW OR OFF-DIAGONAL BLOCKS.
  110       DO 120 MIDPT = J1,J2
		   IF (IABS(ICN(MIDPT)+0).EQ.JNEW) GO TO 130
  120       CONTINUE
		IFLAG  = -13
		IF (LP.NE.0) WRITE (LP,FMT=99997) IOLD,JOLD
		GO TO 180
C EQUIVALENT ELEMENT OF ICN IS IN POSITION MIDPT.
  130       IF (ICN(MIDPT).LT.0) GO TO 160
		IF (MIDPT.GT.NZ .OR. MIDPT.LE.I) GO TO 150
		W1     = A(MIDPT)
		A(MIDPT) = AA
		AA     = W1
		IOLD   = IVECT(MIDPT)
		JOLD   = JVECT(MIDPT)
		ICN(MIDPT) = -ICN(MIDPT)
  140    CONTINUE
  150    A(MIDPT) = AA
	   ICN(MIDPT) = -ICN(MIDPT)
	   GO TO 170

  160    A(MIDPT) = A(MIDPT) + AA
C SET FLAG FOR DUPLICATE ELEMENTS.
	   IFLAG  = N + 1
  170 CONTINUE
C RESET ICN ARRAY  AND ZERO ELEMENTS IN L/U BUT NOT IN A.
C ALSO CALCULATE MAXIMUM ELEMENT OF A.
  180 W1     = ZERO
	DO 200 I = 1,IDISP2
	   IF (ICN(I).LT.0) GO TO 190
	   A(I)   = ZERO
	   GO TO 200

  190    ICN(I) = -ICN(I)
	   W1     = DMAX1(W1,DABS(A(I)))
  200 CONTINUE
	RETURN

99999 FORMAT (' ELEMENT ',I6,' WITH VALUE ',1P,D12.4,/,10X,
     +       ' HAS INDICES ',I8,' ,',I8,' INDICES OUT OF RANGE')
99998 FORMAT (' NON-ZERO',I7,' ,',I6,' IN ZERO OFF-DIAGONAL BLOCK')
99997 FORMAT (' ELEMENT',I6,' ,',I6,' WAS NOT IN L/U PATTERN')

	END
	SUBROUTINE MA28ID(N,NZ,AORG,IRNORG,ICNORG,LICN,A,ICN,IKEEP,RHS,X,
     +                  R,W,MTYPE,PREC,IFLAG)
C THIS SUBROUTINE USES THE FACTORS FROM AN EARLIER CALL TO MA28A/AD
C     OR MA28B/BD TO SOLVE THE SYSTEM OF EQUATIONS WITH ITERATIVE
C     REFINEMENT.
C
C THE PARAMETERS ARE...
C
C N IS EQUAL TO THE ORDER OF THE MATRIX. IT IS NOT ALTERED BY THE
C     SUBROUTINE.
C NZ IS EQUAL TO THE NUMBER OF ENTRIES IN THE ORIGINAL MATRIX.  IT IS
C     NOT ALTERED BY THE SUBROUTINE.
C FOR THIS ENTRY THE ORIGINAL MATRIX MUST HAVE BEEN SAVED IN
C     AORG,IRNORG,ICNORG WHERE ENTRY AORG(K) IS IN ROW IRNORG(K) AND
C     COLUMN ICNORG(K), K=1,...NZ.  INFORMATION ABOUT THE FACTORS OF A
C     IS COMMUNICATED TO THIS SUBROUTINE VIA THE PARAMETERS LICN, A, ICN
C     AND IKEEP WHERE:
C AORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C IRNORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C ICNORG IS AN ARRAY OF LENGTH NZ.  NOT ALTERED BY MA28I/ID.
C LICN IS EQUAL TO THE LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY
C     THE SUBROUTINE.
C A IS AN ARRAY OF LENGTH LICN. IT MUST BE UNCHANGED SINCE THE LAST CALL
C     TO MA28A/AD OR MA28B/BD. IT IS NOT ALTERED BY THE SUBROUTINE.
C ICN, IKEEP ARE THE ARRAYS (OF LENGTHS LICN AND 5*N, RESPECTIVELY) OF
C     THE SAME NAMES AS IN THE PREVIOUS ALL TO MA28A/AD. THEY SHOULD BE
C     UNCHANGED SINCE THIS EARLIER CALL AND    THEY ARE NOT ALTERED BY
C     MA28I/ID.
C THE  OTHER PARAMETERS ARE AS FOLLOWS:
C RHS IS AN ARRAY OF LENGTH N. THE USER MUST SET RHS(I) TO CONTAIN THE
C     VALUE OF THE I TH COMPONENT OF THE RIGHT HAND SIDE. IT IS NOT
C     ALTERED BY MA28I/ID.
C X IS AN ARRAY OF LENGTH N. IF AN INITIAL GUESS OF THE SOLUTION IS
C     GIVEN (ISTART EQUAL TO 1), THEN THE USER MUST SET X(I) TO CONTAIN
C     THE VALUE OF THE I TH COMPONENT OF THE ESTIMATED SOLUTION.  ON
C     EXIT, X(I) CONTAINS THE I TH COMPONENT OF THE SOLUTION VECTOR.
C R IS AN ARRAY OF LENGTH N. IT NEED NOT BE SET ON ENTRY.  ON EXIT, R(I)
C     CONTAINS THE I TH COMPONENT OF AN ESTIMATE OF THE ERROR IF MAXIT
C     IS GREATER THAN 0.
C W IS AN ARRAY OF LENGTH N. IT IS USED AS WORKSPACE BY MA28I/ID.
C MTYPE MUST BE SET TO DETERMINE WHETHER MA28I/ID WILL SOLVE A*X=RHS
C     (MTYPE EQUAL TO 1) OR AT*X=RHS (MTYPE NE 1, ZERO SAY). IT IS NOT
C     ALTERED BY MA28I/ID.
C PREC SHOULD BE SET BY THE USER TO THE RELATIVE ACCURACY REQUIRED. THE
C     ITERATIVE REFINEMENT WILL TERMINATE IF THE MAGNITUDE OF THE
C     LARGEST COMPONENT OF THE ESTIMATED ERROR RELATIVE TO THE LARGEST
C     COMPONENT IN THE SOLUTION IS LESS THAN PREC.  IT IS NOT ALTERED BY
C     MA28I/ID.
C IFLAG IS A DIAGNOSTIC FLAG WHICH WILL BE SET TO ZERO ON SUCCESSFUL
C     EXIT FROM MA28I/ID, OTHERWISE IT WILL HAVE A NON-ZERO VALUE. THE
C     NON-ZERO VALUE IFLAG CAN HAVE ON EXIT FROM MA28I/ID ARE ...
C     -16    INDICATING THAT MORE THAN MAXIT ITEARTIONS ARE REQUIRED.
C     -17    INDICATING THAT MORE CONVERGENCE WAS TOO SLOW.
C
C
C PRIVATE AND COMMON VARIABLES.
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C SEE COMMENTS IN CODE FOR USE OF PRIVATE VARIABLES.
C
C     .. Scalar Arguments ..
	DOUBLE PRECISION PREC
	INTEGER IFLAG,LICN,MTYPE,N,NZ
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),AORG(NZ),R(N),RHS(N),W(N),X(N)
	INTEGER ICN(LICN),ICNORG(NZ),IKEEP(N,5),IRNORG(NZ)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION CONVER,D,DD,ZERO
	INTEGER I,ITERAT,NCOL,NROW
C     ..
C     .. External Subroutines ..
	EXTERNAL MA28CD
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1
C     ..
C     .. Common blocks ..
	COMMON /MA28ED/LP,MP,LBLOCK,GROW
	COMMON /MA28HD/TOL,THEMAX,BIG,DXMAX,ERRMAX,DRES,CGCE,NDROP,MAXIT,
     +       NOITER,NSRCH,ISTART,LBIG
	DOUBLE PRECISION BIG,CGCE,DRES,DXMAX,ERRMAX,THEMAX,TOL
	INTEGER ISTART,LP,MAXIT,MP,NDROP,NOITER,NSRCH
	LOGICAL GROW,LBIG,LBLOCK
C     ..
C     .. Data statements ..
C
	DATA  ZERO/0.0D0/
C     ..
C
C   INITIALIZATION OF NOITER, ERRMAX AND IFLAG.
C
	NOITER = 0
	ERRMAX = ZERO
	DRES   = ZERO
	IFLAG  = 0
C
C  JUMP IF A STARTING VECTOR HAS BEEN SUPPLIED BY THE USER.
C
	IF (ISTART.EQ.1) GO TO 20
C
C  MAKE A COPY OF THE RIGHT-HAND SIDE VECTOR.
C
	DO 10 I = 1,N
	   X(I)   = RHS(I)
   10 CONTINUE
C
C  FIND THE FIRST SOLUTION.
C
	CALL MA28CD(N,A,LICN,ICN,IKEEP,X,W,MTYPE)
C
C  STOP THE COMPUTATIONS IF   MAXIT=0.
C
   20 IF (MAXIT.EQ.0) GO TO 160
C
C  CALCULATE THE MAX-NORM OF THE FIRST SOLUTION.
C
	DD     = 0.0
	DO 30 I = 1,N
	   DD     = DMAX1(DD,DABS(X(I)))
   30 CONTINUE
	DXMAX  = DD
C
C  BEGIN THE ITERATIVE PROCESS.
C
	DO 120 ITERAT = 1,MAXIT
	   D      = DD
C
C  CALCULATE THE RESIDUAL VECTOR.
C
	   DO 40 I = 1,N
		R(I)   = RHS(I)
   40    CONTINUE
	   IF (MTYPE.EQ.1) GO TO 60
	   DO 50 I = 1,NZ
		NROW   = IRNORG(I)
		NCOL   = ICNORG(I)
		R(NCOL) = R(NCOL) - AORG(I)*X(NROW)
   50    CONTINUE
	   GO TO 80
C MTYPE=1.
   60    DO 70 I = 1,NZ
		NROW   = IRNORG(I)
		NCOL   = ICNORG(I)
		R(NROW) = R(NROW) - AORG(I)*X(NCOL)
   70    CONTINUE
   80    DRES   = 0.0
C
C  FIND THE MAX-NORM OF THE RESIDUAL VECTOR.
C
	   DO 90 I = 1,N
		DRES   = DMAX1(DRES,DABS(R(I)))
   90    CONTINUE
C
C  STOP THE CALCULATIONS IF THE MAX-NORM OF
C  THE RESIDUAL VECTOR IS ZERO.
C
	   IF (DRES.EQ.0.0) GO TO 150
C
C  CALCULATE THE CORRECTION VECTOR.
C
	   NOITER = NOITER + 1
	   CALL MA28CD(N,A,LICN,ICN,IKEEP,R,W,MTYPE)
C
C  FIND THE MAX-NORM OF THE CORRECTION VECTOR.
C
	   DD     = 0.0
	   DO 100 I = 1,N
		DD     = DMAX1(DD,DABS(R(I)))
  100    CONTINUE
C
C  CHECK THE CONVERGENCE.
C
	   IF (DD.GT.D*CGCE .AND. ITERAT.GE.2) GO TO 130
	   IF (DXMAX*10.0+DD.EQ.DXMAX*10.0) GO TO 140
C
C  ATTEMPT TO IMPROVE THE SOLUTION.
C
	   DXMAX  = 0.0
	   DO 110 I = 1,N
		X(I)   = X(I) + R(I)
		DXMAX  = DMAX1(DXMAX,DABS(X(I)))
  110    CONTINUE
C
C  CHECK THE STOPPING CRITERION.
C
	   IF (DD.LT.PREC*DXMAX) GO TO 140
  120 CONTINUE
C MORE THAN MAXIT ITERATIONS REQUIRED.
	IFLAG  = -16
	WRITE (LP,FMT=99999) IFLAG,MAXIT
	GO TO 140
C CONVERGENCE RATE UNACCEPTABLY SLOW.
  130 IFLAG  = -17
	CONVER = DD/D
	WRITE (LP,FMT=99998) IFLAG,CONVER,CGCE
C
C  THE ITERATIVE PROCESS IS TERMINATED.
C
  140 ERRMAX = DD
  150 CONTINUE
  160 RETURN

99999 FORMAT (' ERROR RETURN FROM MA28I/ID WITH IFLAG = ',I3,/,' MORE ',
     +       'THAN',I5,' ITERATIONS REQUIRED')
99998 FORMAT (' ERROR RETURN FROM MA28I WITH IFLAG = ',I3,/,' CONVERGE',
     +       'NCE RATE OF ',1P,E9.2,' TOO SLOW',/,
     +       ' MAXIMUM ACCEPTABLE RATE',' SET TO ',1P,E9.2)

	END
	BLOCK DATA MA28JD
C
C COMMENTS ON ALL THE COMMON BLOCK VARIABLES ARE GIVEN HERE EVEN
C     THOUGH SOME ARE NOT INITIALIZED BY BLOCK DATA.
C LP,MP ARE USED BY THE SUBROUTINE AS THE UNIT NUMBERS FOR ITS WARNING
C     AND DIAGNOSTIC MESSAGES. DEFAULT VALUE FOR BOTH IS 6 (FOR LINE
C     PRINTER OUTPUT). THE USER CAN EITHER RESET THEM TO A DIFFERENT
C     STREAM NUMBER OR SUPPRESS THE OUTPUT BY SETTING THEM TO ZERO.
C     WHILE LP DIRECTS THE OUTPUT OF ERROR DIAGNOSTICS FROM THE
C     PRINCIPAL SUBROUTINES AND INTERNALLY CALLED SUBROUTINES, MP
C     CONTROLS ONLY THE OUTPUT OF A MESSAGE WHICH WARNS THE USER THAT HE
C     HAS INPUT TWO OR MORE NON-ZEROS A(I), . . ,A(K) WITH THE SAME ROW
C     AND COLUMN INDICES.  THE ACTION TAKEN IN THIS CASE IS TO PROCEED
C     USING A NUMERICAL VALUE OF A(I)+...+A(K). IN THE ABSENCE OF OTHER
C     ERRORS, IFLAG WILL EQUAL -14 ON EXIT.
C LBLOCK IS A LOGICAL VARIABLE WHICH CONTROLS AN OPTION OF FIRST
C     PREORDERING THE MATRIX TO BLOCK LOWER TRIANGULAR FORM (USING
C     HARWELL SUBROUTINE MC23A). THE PREORDERING IS PERFORMED IF LBLOCK
C     IS EQUAL TO ITS DEFAULT VALUE OF .TRUE. IF LBLOCK IS SET TO
C     .FALSE. , THE OPTION IS NOT INVOKED AND THE SPACE ALLOCATED TO
C     IKEEP CAN BE REDUCED TO 4*N+1.
C GROW IS A LOGICAL VARIABLE. IF IT IS LEFT AT ITS DEFAULT VALUE OF
C     .TRUE. , THEN ON RETURN FROM MA28A/AD OR MA28B/BD, W(1) WILL GIVE
C     AN ESTIMATE (AN UPPER BOUND) OF THE INCREASE IN SIZE OF ELEMENTS
C     ENCOUNTERED DURING THE DECOMPOSITION. IF THE MATRIX IS WELL
C     SCALED, THEN A HIGH VALUE FOR W(1), RELATIVE TO THE LARGEST ENTRY
C     IN THE INPUT MATRIX, INDICATES THAT THE LU DECOMPOSITION MAY BE
C     INACCURATE AND THE USER SHOULD BE WARY OF HIS RESULTS AND PERHAPS
C     INCREASE U FOR SUBSEQUENT RUNS.  WE WOULD LIKE TO EMPHASISE THAT
C     THIS VALUE ONLY RELATES TO THE ACCURACY OF OUR LU DECOMPOSITION
C     AND GIVES NO INDICATION AS TO THE SINGULARITY OF THE MATRIX OR THE
C     ACCURACY OF THE SOLUTION.  THIS UPPER BOUND CAN BE A SIGNIFICANT
C     OVERESTIMATE PARTICULARLY IF THE MATRIX IS BADLY SCALED. IF AN
C     ACCURATE VALUE FOR THE GROWTH IS REQUIRED, LBIG (Q.V.) SHOULD BE
C     SET TO .TRUE.
C EPS,RMIN ARE REAL VARIABLES. IF, ON ENTRY TO MA28B/BD, EPS IS LESS
C     THAN ONE, THEN RMIN WILL GIVE THE SMALLEST RATIO OF THE PIVOT TO
C     THE LARGEST ELEMENT IN THE CORRESPONDING ROW OF THE UPPER
C     TRIANGULAR FACTOR THUS MONITORING THE STABILITY OF SUCCESSIVE
C     FACTORIZATIONS. IF RMIN BECOMES VERY LARGE AND W(1) FROM
C     MA28B/BD IS ALSO VERY LARGE, IT MAY BE ADVISABLE TO PERFORM A
C     NEW DECOMPOSITION USING MA28A/AD.
C RESID IS A REAL VARIABLE WHICH ON EXIT FROM MA28C/CD GIVES THE VALUE
C     OF THE MAXIMUM RESIDUAL OVER ALL THE EQUATIONS UNSATISFIED BECAUSE
C     OF DEPENDENCY (ZERO PIVOTS).
C IRNCP,ICNCP ARE INTEGER VARIABLES WHICH MONITOR THE ADEQUACY OF "ELBOW
C     ROOM" IN IRN AND A/ICN RESPECTIVELY. IF EITHER IS QUITE LARGE (SAY
C     GREATER THAN N/10), IT WILL PROBABLY PAY TO INCREASE THE SIZE OF
C     THE CORRESPONDING ARRAY FOR SUBSEQUENT RUNS. IF EITHER IS VERY LOW
C     OR ZERO THEN ONE CAN PERHAPS SAVE STORAGE BY REDUCING THE SIZE OF
C     THE CORRESPONDING ARRAY.
C MINIRN,MINICN ARE INTEGER VARIABLES WHICH, IN THE EVENT OF A
C     SUCCESSFUL RETURN (IFLAG GE 0 OR IFLAG=-14) GIVE THE MINIMUM SIZE
C     OF IRN AND A/ICN RESPECTIVELY WHICH WOULD ENABLE A SUCCESSFUL RUN
C     ON AN IDENTICAL MATRIX. ON AN EXIT WITH IFLAG EQUAL TO -5, MINICN
C     GIVES THE MINIMUM VALUE OF ICN FOR SUCCESS ON SUBSEQUENT RUNS ON
C     AN IDENTICAL MATRIX. IN THE EVENT OF FAILURE WITH IFLAG= -6, -4,
C     -3, -2, OR -1, THEN MINICN AND MINIRN GIVE THE MINIMUM VALUE OF
C     LICN AND LIRN RESPECTIVELY WHICH WOULD BE REQUIRED FOR A
C     SUCCESSFUL DECOMPOSITION UP TO THE POINT AT WHICH THE FAILURE
C     OCCURRED.
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN UPPER BOUND ON THE RANK OF
C     THE MATRIX.
C ABORT1 IS A LOGICAL VARIABLE WITH DEFAULT VALUE .TRUE.  IF ABORT1 IS
C     SET TO .FALSE.  THEN MA28A/AD WILL DECOMPOSE STRUCTURALLY SINGULAR
C     MATRICES (INCLUDING RECTANGULAR ONES).
C ABORT2 IS A LOGICAL VARIABLE WITH DEFAULT VALUE .TRUE.  IF ABORT2 IS
C     SET TO .FALSE. THEN MA28A/AD WILL DECOMPOSE NUMERICALLY SINGULAR
C     MATRICES.
C IDISP IS AN INTEGER ARRAY OF LENGTH 2. ON OUTPUT FROM MA28A/AD, THE
C     INDICES OF THE DIAGONAL BLOCKS OF THE FACTORS LIE IN POSITIONS
C     IDISP(1) TO IDISP(2) OF A/ICN. THIS ARRAY MUST BE PRESERVED
C     BETWEEN A CALL TO MA28A/AD AND SUBSEQUENT CALLS TO MA28B/BD,
C     MA28C/CD OR MA28I/ID.
C TOL IS A REAL VARIABLE.  IF IT IS SET TO A POSITIVE VALUE, THEN ANY
C     NON-ZERO WHOSE MODULUS IS LESS THAN TOL WILL BE DROPPED FROM THE
C     FACTORIZATION.  THE FACTORIZATION WILL THEN REQUIRE LESS STORAGE
C     BUT WILL BE INACCURATE.  AFTER A RUN OF MA28A/AD WITH TOL POSITIVE
C     IT IS NOT POSSIBLE TO USE MA28B/BD AND THE USER IS RECOMMENDED TO
C     USE MA28I/ID TO OBTAIN THE SOLUTION.  THE DEFAULT VALUE FOR TOL IS
C     0.0.
C THEMAX IS A REAL VARIABLE.  ON EXIT FROM MA28A/AD, IT WILL HOLD THE
C     LARGEST ENTRY OF THE ORIGINAL MATRIX.
C BIG IS A REAL VARIABLE. IF LBIG HAS BEEN SET TO .TRUE., BIG WILL HOLD
C     THE LARGEST ENTRY ENCOUNTERED DURING THE FACTORIZATION BY MA28A/AD
C     OR MA28B/BD.
C DXMAX IS A REAL VARIABLE. ON EXIT FROM MA28I/ID, DXMAX WILL BE SET TO
C     THE LARGEST COMPONENT OF THE SOLUTION.
C ERRMAX IS A REAL VARIABLE.  ON EXIT FROM MA28I/ID, IF MAXIT IS
C     POSITIVE, ERRMAX WILL BE SET TO THE LARGEST COMPONENT IN THE
C     ESTIMATE OF THE ERROR.
C DRES IS A REAL VARIABLE.  ON EXIT FROM MA28I/ID, IF MAXIT IS POSITIVE,
C     DRES WILL BE SET TO THE LARGEST COMPONENT OF THE RESIDUAL.
C CGCE IS A REAL VARIABLE. IT IS USED BY MA28I/ID TO CHECK THE
C     CONVERGENCE RATE.  IF THE RATIO OF SUCCESSIVE CORRECTIONS IS
C     NOT LESS THAN CGCE THEN WE TERMINATE SINCE THE CONVERGENCE
C     RATE IS ADJUDGED TOO SLOW.
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT
C     FROM MA28A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED FROM
C     THE DATA STRUCTURE.
C MAXIT IS AN INTEGER VARIABLE. IT IS THE MAXIMUM NUMBER OF ITERATIONS
C     PERFORMED BY MA28I/ID. IT HAS A DEFAULT VALUE OF 16.
C NOITER IS AN INTEGER VARIABLE. IT IS SET BY MA28I/ID TO THE NUMBER OF
C     ITERATIVE REFINEMENT ITERATIONS ACTUALLY USED.
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN N,
C     THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY MA28A/AD.  THIS
C     MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION TIME FOR MA28A/AD.
C     IF NSRCH IS LESS THAN OR EQUAL TO N, THE WORKSPACE ARRAY IW CAN BE
C     REDUCED IN LENGTH.  THE DEFAULT VALUE FOR NSRCH IS 32768.
C ISTART IS AN INTEGER VARIABLE. IF ISTART IS SET TO A VALUE OTHER THAN
C     ZERO, THEN THE USER MUST SUPPLY AN ESTIMATE OF THE SOLUTION TO
C     MA28I/ID.  THE DEFAULT VALUE FOR ISTART IS ZERO.
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF THE
C     LARGEST ELEMENT ENCOUNTERED IN THE FACTORIZATION BY MA28A/AD OR
C     MA28B/BD IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL
C     INCREASE THE TIME FOR MA28A/AD MARGINALLY AND THAT FOR MA28B/BD
C     BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS .FALSE.
C
C     COMMON /MA28GD/ IDISP(2)
C     .. Common blocks ..
	COMMON /MA28ED/LP,MP,LBLOCK,GROW
	COMMON /MA28FD/EPS,RMIN,RESID,IRNCP,ICNCP,MINIRN,MINICN,IRANK,
     +       ABORT1,ABORT2
	COMMON /MA28HD/TOL,THEMAX,BIG,DXMAX,ERRMAX,DRES,CGCE,NDROP,MAXIT,
     +       NOITER,NSRCH,ISTART,LBIG
	DOUBLE PRECISION BIG,CGCE,DRES,DXMAX,EPS,ERRMAX,RESID,RMIN,THEMAX,
     +                 TOL
	INTEGER ICNCP,IRANK,IRNCP,ISTART,LP,MAXIT,MINICN,MINIRN,MP,NDROP,
     +        NOITER,NSRCH
	LOGICAL ABORT1,ABORT2,GROW,LBIG,LBLOCK
C     ..
C     .. Data statements ..
	DATA  EPS/1.0D-4/,TOL/0.0D0/,CGCE/0.5D0/
	DATA  MAXIT/16/
	DATA  LP/6/,MP/6/,NSRCH/32768/,ISTART/0/
	DATA  LBLOCK/.TRUE./,GROW/.TRUE./,LBIG/.FALSE./
	DATA  ABORT1/.TRUE./,ABORT2/.TRUE./
C     ..
	END
*######DATE 13 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MA30AD
	SUBROUTINE MA30AD(NN,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,IRN,LIRN,
     +                  LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC,IPTR,IPC,U,
     +                  IFLAG)
C IF  THE USER REQUIRES A MORE CONVENIENT DATA INTERFACE THEN THE MA28
C     PACKAGE SHOULD BE USED.  THE MA28 SUBROUTINES CALL THE MA30
C     SUBROUTINES AFTER CHECKING THE USER'S INPUT DATA AND OPTIONALLY
C     USING MC23A/AD TO PERMUTE THE MATRIX TO BLOCK TRIANGULAR FORM.
C THIS PACKAGE OF SUBROUTINES (MA30A/AD, MA30B/BD, MA30C/CD AND
C     MA30D/DD) PERFORMS OPERATIONS PERTINENT TO THE SOLUTION OF A
C     GENERAL SPARSE N BY N SYSTEM OF LINEAR EQUATIONS (I.E. SOLVE
C     AX=B). STRUCTUALLY SINGULAR MATRICES ARE PERMITTED INCLUDING
C     THOSE WITH ROW OR COLUMNS CONSISTING ENTIRELY OF ZEROS (I.E.
C     INCLUDING RECTANGULAR MATRICES).  IT IS ASSUMED THAT THE
C     NON-ZEROS OF THE MATRIX A DO NOT DIFFER WIDELY IN SIZE.  IF
C     NECESSARY A PRIOR CALL OF THE SCALING SUBROUTINE MC19A/AD MAY BE
C     MADE.
C A DISCUSSION OF THE DESIGN OF THESE SUBROUTINES IS GIVEN BY DUFF AND
C     REID (ACM TRANS MATH SOFTWARE 5 PP 18-35,1979 (CSS 48)) WHILE
C     FULLER DETAILS OF THE IMPLEMENTATION ARE GIVEN IN DUFF (HARWELL
C     REPORT AERE-R 8730,1977).  THE ADDITIONAL PIVOTING OPTION IN
C     MA30A/AD AND THE USE OF DROP TOLERANCES (SEE COMMON BLOCK
C     MA30I/ID) WERE ADDED TO THE PACKAGE AFTER JOINT WORK WITH REID,
C     SCHAUMBURG, WASNIEWSKI AND ZLATEV (DUFF, REID, SCHAUMBURG,
C     WASNIEWSKI AND ZLATEV, HARWELL REPORT CSS 135, 1983).
C
C MA30A/AD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF THE
C     PERMUTATION PAQ OF A SPARSE MATRIX A, WHERE INPUT PERMUTATIONS
C     P1 AND Q1 ARE USED TO DEFINE THE DIAGONAL BLOCKS.  THERE MAY BE
C     NON-ZEROS IN THE OFF-DIAGONAL BLOCKS BUT THEY ARE UNAFFECTED BY
C     MA30A/AD. P AND P1 DIFFER ONLY WITHIN BLOCKS AS DO Q AND Q1. THE
C     PERMUTATIONS P1 AND Q1 MAY BE FOUND BY CALLING MC23A/AD OR THE
C     MATRIX MAY BE TREATED AS A SINGLE BLOCK BY USING P1=Q1=I. THE
C     MATRIX NON-ZEROS SHOULD BE HELD COMPACTLY BY ROWS, ALTHOUGH IT
C     SHOULD BE NOTED THAT THE USER CAN SUPPLY THE MATRIX BY COLUMNS
C     TO GET THE LU DECOMPOSITION OF A TRANSPOSE.
C
C THE PARAMETERS ARE...
C THIS DESCRIPTION SHOULD ALSO BE CONSULTED FOR FURTHER INFORMATION ON
C     MOST OF THE PARAMETERS OF MA30B/BD AND MA30C/CD.
C
C N  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE ORDER
C     OF THE MATRIX.  IT IS NOT ALTERED BY MA30A/AD.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. POSITIONS IDISP(2) TO
C     LICN MUST BE SET BY THE USER TO CONTAIN THE COLUMN INDICES OF
C     THE NON-ZEROS IN THE DIAGONAL BLOCKS OF P1*A*Q1. THOSE BELONGING
C     TO A SINGLE ROW MUST BE CONTIGUOUS BUT THE ORDERING OF COLUMN
C     INDICES WITH EACH ROW IS UNIMPORTANT. THE NON-ZEROS OF ROW I
C     PRECEDE THOSE OF ROW I+1,I=1,...,N-1 AND NO WASTED SPACE IS
C     ALLOWED BETWEEN THE ROWS.  ON OUTPUT THE COLUMN INDICES OF THE
C     LU DECOMPOSITION OF PAQ ARE HELD IN POSITIONS IDISP(1) TO
C     IDISP(2), THE ROWS ARE IN PIVOTAL ORDER, AND THE COLUMN INDICES
C     OF THE L PART OF EACH ROW ARE IN PIVOTAL ORDER AND PRECEDE THOSE
C     OF U. AGAIN THERE IS NO WASTED SPACE EITHER WITHIN A ROW OR
C     BETWEEN THE ROWS. ICN(1) TO ICN(IDISP(1)-1), ARE NEITHER
C     REQUIRED NOR ALTERED. IF MC23A/AD BEEN CALLED, THESE WILL HOLD
C     INFORMATION ABOUT THE OFF-DIAGONAL BLOCKS.
C A IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN WHOSE ENTRIES
C     IDISP(2) TO LICN MUST BE SET BY THE USER TO THE  VALUES OF THE
C     NON-ZERO ENTRIES OF THE MATRIX IN THE ORDER INDICATED BY  ICN.
C     ON OUTPUT A WILL HOLD THE LU FACTORS OF THE MATRIX WHERE AGAIN
C     THE POSITION IN THE MATRIX IS DETERMINED BY THE CORRESPONDING
C     VALUES IN ICN. A(1) TO A(IDISP(1)-1) ARE NEITHER REQUIRED NOR
C     ALTERED.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS ICN AND A. IT MUST BE BIG ENOUGH FOR A AND ICN
C     TO HOLD ALL THE NON-ZEROS OF L AND U AND LEAVE SOME "ELBOW
C     ROOM".  IT IS POSSIBLE TO CALCULATE A MINIMUM VALUE FOR LICN BY
C     A PRELIMINARY RUN OF MA30A/AD. THE ADEQUACY OF THE ELBOW ROOM
C     CAN BE JUDGED BY THE SIZE OF THE COMMON BLOCK VARIABLE ICNCP. IT
C     IS NOT ALTERED BY MA30A/AD.
C LENR  IS AN INTEGER ARRAY OF LENGTH N.  ON INPUT, LENR(I) SHOULD
C     EQUAL THE NUMBER OF NON-ZEROS IN ROW I, I=1,...,N OF THE
C     DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT, LENR(I) WILL EQUAL THE
C     TOTAL NUMBER OF NON-ZEROS IN ROW I OF L AND ROW I OF U.
C LENRL  IS AN INTEGER ARRAY OF LENGTH N. ON OUTPUT FROM MA30A/AD,
C     LENRL(I) WILL HOLD THE NUMBER OF NON-ZEROS IN ROW I OF L.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. THE USER SHOULD SET IDISP(1)
C     TO BE THE FIRST AVAILABLE POSITION IN A/ICN FOR THE LU
C     DECOMPOSITION WHILE IDISP(2) IS SET TO THE POSITION IN A/ICN OF
C     THE FIRST NON-ZERO IN THE DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT,
C     IDISP(1) WILL BE UNALTERED WHILE IDISP(2) WILL BE SET TO THE
C     POSITION IN A/ICN OF THE LAST NON-ZERO OF THE LU DECOMPOSITION.
C IP  IS AN INTEGER ARRAY OF LENGTH N WHICH HOLDS A PERMUTATION OF
C     THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, THE ABSOLUTE VALUE OF
C     IP(I) MUST BE SET TO THE ROW OF A WHICH IS ROW I OF P1*A*Q1. A
C     NEGATIVE VALUE FOR IP(I) INDICATES THAT ROW I IS AT THE END OF A
C     DIAGONAL BLOCK.  ON OUTPUT FROM MA30A/AD, IP(I) INDICATES THE ROW
C     OF A WHICH IS THE I TH ROW IN PAQ. IP(I) WILL STILL BE NEGATIVE
C     FOR THE LAST ROW OF EACH BLOCK (EXCEPT THE LAST).
C IQ IS AN INTEGER ARRAY OF LENGTH N WHICH AGAIN HOLDS A
C     PERMUTATION OF THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, IQ(J)
C     MUST BE SET TO THE COLUMN OF A WHICH IS COLUMN J OF P1*A*Q1. ON
C     OUTPUT FROM MA30A/AD, THE ABSOLUTE VALUE OF IQ(J) INDICATES THE
C     COLUMN OF A WHICH IS THE J TH IN PAQ.  FOR ROWS, I SAY, IN WHICH
C     STRUCTURAL OR NUMERICAL SINGULARITY IS DETECTED IQ(I) IS
C     NEGATED.
C IRN  IS AN INTEGER ARRAY OF LENGTH LIRN USED AS WORKSPACE BY
C     MA30A/AD.
C LIRN  IS AN INTEGER VARIABLE. IT SHOULD BE GREATER THAN THE
C     LARGEST NUMBER OF NON-ZEROS IN A DIAGONAL BLOCK OF P1*A*Q1 BUT
C     NEED NOT BE AS LARGE AS LICN. IT IS THE LENGTH OF ARRAY IRN AND
C     SHOULD BE LARGE ENOUGH TO HOLD THE ACTIVE PART OF ANY BLOCK,
C     PLUS SOME "ELBOW ROOM", THE  A POSTERIORI  ADEQUACY OF WHICH CAN
C     BE ESTIMATED BY EXAMINING THE SIZE OF COMMON BLOCK VARIABLE
C     IRNCP.
C LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC ARE ALL INTEGER ARRAYS OF
C     LENGTH N WHICH ARE USED AS WORKSPACE BY MA30A/AD.  IF NSRCH IS
C     SET TO A VALUE LESS THAN OR EQUAL TO N, THEN ARRAYS LASTC AND
C     NEXTC ARE NOT REFERENCED BY MA30A/AD AND SO CAN BE DUMMIED IN
C     THE CALL TO MA30A/AD.
C IPTR,IPC ARE INTEGER ARRAYS OF LENGTH N WHICH ARE USED AS WORKSPACE
C     BY MA30A/AD.
C U  IS A REAL/DOUBLE PRECISION VARIABLE WHICH SHOULD BE SET BY THE
C     USER TO A VALUE BETWEEN 0. AND 1.0. IF LESS THAN ZERO IT IS
C     RESET TO ZERO AND IF ITS VALUE IS 1.0 OR GREATER IT IS RESET TO
C     0.9999 (0.999999999 IN D VERSION).  IT DETERMINES THE BALANCE
C     BETWEEN PIVOTING FOR SPARSITY AND FOR STABILITY, VALUES NEAR
C     ZERO EMPHASIZING SPARSITY AND VALUES NEAR ONE EMPHASIZING
C     STABILITY. WE RECOMMEND U=0.1 AS A POSIBLE FIRST TRIAL VALUE.
C     THE STABILITY CAN BE JUDGED BY A LATER CALL TO MC24A/AD OR BY
C     SETTING LBIG TO .TRUE.
C IFLAG  IS AN INTEGER VARIABLE. IT WILL HAVE A NON-NEGATIVE VALUE IF
C     MA30A/AD IS SUCCESSFUL. NEGATIVE VALUES INDICATE ERROR
C     CONDITIONS WHILE POSITIVE VALUES INDICATE THAT THE MATRIX HAS
C     BEEN SUCCESSFULLY DECOMPOSED BUT IS SINGULAR. FOR EACH NON-ZERO
C     VALUE, AN APPROPRIATE MESSAGE IS OUTPUT ON UNIT LP.  POSSIBLE
C     NON-ZERO VALUES FOR IFLAG ARE ...
C
C -1  THE MATRIX IS STRUCTUALLY SINGULAR WITH RANK GIVEN BY IRANK IN
C     COMMON BLOCK MA30F/FD.
C +1  IF, HOWEVER, THE USER WANTS THE LU DECOMPOSITION OF A
C     STRUCTURALLY SINGULAR MATRIX AND SETS THE COMMON BLOCK VARIABLE
C     ABORT1 TO .FALSE., THEN, IN THE EVENT OF SINGULARITY AND A
C     SUCCESSFUL DECOMPOSITION, IFLAG IS RETURNED WITH THE VALUE +1
C     AND NO MESSAGE IS OUTPUT.
C -2  THE MATRIX IS NUMERICALLY SINGULAR (IT MAY ALSO BE STRUCTUALLY
C     SINGULAR) WITH ESTIMATED RANK GIVEN BY IRANK IN COMMON BLOCK
C     MA30F/FD.
C +2  THE  USER CAN CHOOSE TO CONTINUE THE DECOMPOSITION EVEN WHEN A
C     ZERO PIVOT IS ENCOUNTERED BY SETTING COMMON BLOCK VARIABLE
C     ABORT2 TO .FALSE.  IF A SINGULARITY IS ENCOUNTERED, IFLAG WILL
C     THEN RETURN WITH A VALUE OF +2, AND NO MESSAGE IS OUTPUT IF THE
C     DECOMPOSITION HAS BEEN COMPLETED SUCCESSFULLY.
C -3  LIRN HAS NOT BEEN LARGE ENOUGH TO CONTINUE WITH THE
C     DECOMPOSITION.  IF THE STAGE WAS ZERO THEN COMMON BLOCK VARIABLE
C     MINIRN GIVES THE LENGTH SUFFICIENT TO START THE DECOMPOSITION ON
C     THIS BLOCK.  FOR A SUCCESSFUL DECOMPOSITION ON THIS BLOCK THE
C     USER SHOULD MAKE LIRN SLIGHTLY (SAY ABOUT N/2) GREATER THAN THIS
C     VALUE.
C -4  LICN NOT LARGE ENOUGH TO CONTINUE WITH THE DECOMPOSITION.
C -5  THE DECOMPOSITION HAS BEEN COMPLETED BUT SOME OF THE LU FACTORS
C     HAVE BEEN DISCARDED TO CREATE ENOUGH ROOM IN A/ICN TO CONTINUE
C     THE DECOMPOSITION. THE VARIABLE MINICN IN COMMON BLOCK MA30F/FD
C     THEN GIVES THE SIZE THAT LICN SHOULD BE TO ENABLE THE
C     FACTORIZATION TO BE SUCCESSFUL.  IF THE USER SETS COMMON BLOCK
C     VARIABLE ABORT3 TO .TRUE., THEN THE SUBROUTINE WILL EXIT
C     IMMEDIATELY INSTEAD OF DESTROYING ANY FACTORS AND CONTINUING.
C -6  BOTH LICN AND LIRN ARE TOO SMALL. TERMINATION HAS BEEN CAUSED BY
C     LACK OF SPACE IN IRN (SEE ERROR IFLAG= -3), BUT ALREADY SOME OF
C     THE LU FACTORS IN A/ICN HAVE BEEN LOST (SEE ERROR IFLAG= -5).
C     MINICN GIVES THE MINIMUM AMOUNT OF SPACE REQUIRED IN A/ICN FOR
C     DECOMPOSITION UP TO THIS POINT.
C
C FOR COMMENTS OF COMMON BLOCK VARIABLES SEE BLOCK DATA SUBPROGRAM.
C     .. Scalar Arguments ..
	DOUBLE PRECISION U
	INTEGER IFLAG,LICN,LIRN,NN
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN)
	INTEGER ICN(LICN),IDISP(2),IFIRST(NN),IP(NN),IPC(NN),IPTR(NN),
     +        IQ(NN),IRN(LIRN),LASTC(NN),LASTR(NN),LENC(NN),LENR(NN),
     +        LENRL(NN),NEXTC(NN),NEXTR(NN)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION AANEW,AMAX,ANEW,AU,PIVR,PIVRAT,SCALE,UMAX,ZERO
	INTEGER COLUPD,DISPC,I,I1,I2,IACTIV,IBEG,IDISPC,IDROP,IDUMMY,IEND,
     +        IFILL,IFIR,II,III,IJFIR,IJP1,IJPOS,ILAST,INDROW,IOP,IPIV,
     +        IPOS,IROWS,ISING,ISRCH,ISTART,ISW,ISW1,ITOP,J,J1,J2,JBEG,
     +        JCOST,JCOUNT,JDIFF,JDUMMY,JEND,JJ,JMORE,JNEW,JNPOS,JOLD,
     +        JPIV,JPOS,JROOM,JVAL,JZER,JZERO,K,KCOST,KDROP,L,LC,LENPIV,
     +        LL,LR,MOREI,MSRCH,N,NBLOCK,NC,NNM1,NR,NUM,NZ,NZ2,NZCOL,
     +        NZMIN,NZPC,NZROW,OLDEND,OLDPIV,PIVEND,PIVOT,PIVROW,ROWI
C     ..
C     .. External Subroutines ..
	EXTERNAL MA30DD,MA30JD
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1,DMIN1,IABS,MAX0,MIN0
C     ..
C     .. Common blocks ..
	COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
	COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
	COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
	DOUBLE PRECISION BIG,TOL
	INTEGER ICNCP,IRANK,IRNCP,LP,MINICN,MINIRN,NDROP,NSRCH
	LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
C
	DATA  UMAX/.999999999D0/
	DATA  ZERO/0.0D0/
C     ..
	MSRCH  = NSRCH
	NDROP  = 0
	MINIRN = 0
	MINICN = IDISP(1) - 1
	MOREI  = 0
	IRANK  = NN
	IRNCP  = 0
	ICNCP  = 0
	IFLAG  = 0
C RESET U IF NECESSARY.
	U      = DMIN1(U,UMAX)
C IBEG IS THE POSITION OF THE NEXT PIVOT ROW AFTER ELIMINATION STEP
C     USING IT.
	U      = DMAX1(U,ZERO)
	IBEG   = IDISP(1)
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE ACTIVE PART OF A/ICN.
	IACTIV = IDISP(2)
C NZROW IS CURRENT NUMBER OF NON-ZEROS IN ACTIVE AND UNPROCESSED PART
C     OF ROW FILE ICN.
	NZROW  = LICN - IACTIV + 1
	MINICN = NZROW + MINICN
C
C COUNT THE NUMBER OF DIAGONAL BLOCKS AND SET UP POINTERS TO THE
C     BEGINNINGS OF THE ROWS.
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
	NUM    = 1
	IPTR(1) = IACTIV
	IF (NN.EQ.1) GO TO 20
	NNM1   = NN - 1
	DO 10 I = 1,NNM1
	   IF (IP(I).LT.0) NUM    = NUM + 1
	   IPTR(I+1) = IPTR(I) + LENR(I)
   10 CONTINUE
C ILAST IS THE LAST ROW IN THE PREVIOUS BLOCK.
   20 ILAST  = 0
C
C ***********************************************
C ****    LU DECOMPOSITION OF BLOCK NBLOCK   ****
C ***********************************************
C
C EACH PASS THROUGH THIS LOOP PERFORMS LU DECOMPOSITION ON ONE
C     OF THE DIAGONAL BLOCKS.
	DO 1000 NBLOCK = 1,NUM
	   ISTART = ILAST + 1
	   DO 30 IROWS = ISTART,NN
		IF (IP(IROWS).LT.0) GO TO 40
   30    CONTINUE
	   IROWS  = NN
   40    ILAST  = IROWS
C N IS THE NUMBER OF ROWS IN THE CURRENT BLOCK.
C ISTART IS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
C ILAST IS THE INDEX OF THE LAST ROW IN THE CURRENT BLOCK.
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE BLOCK.
C ITOP IS THE POSITION OF THE LAST ENTRY IN THE BLOCK.
	   N      = ILAST - ISTART + 1
	   IF (N.NE.1) GO TO 90
C
C CODE FOR DEALING WITH 1X1 BLOCK.
	   LENRL(ILAST) = 0
	   ISING  = ISTART
	   IF (LENR(ILAST).NE.0) GO TO 50
C BLOCK IS STRUCTURALLY SINGULAR.
	   IRANK  = IRANK - 1
	   ISING  = -ISING
	   IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG  = 1
	   IF (.NOT.ABORT1) GO TO 80
	   IDISP(2) = IACTIV
	   IFLAG  = -1
	   IF (LP.NE.0) WRITE (LP,FMT=99999)
C     RETURN
	   GO TO 1120

   50    SCALE  = DABS(A(IACTIV))
	   IF (SCALE.EQ.ZERO) GO TO 60
	   IF (LBIG) BIG    = DMAX1(BIG,SCALE)
	   GO TO 70

   60    ISING  = -ISING
	   IRANK  = IRANK - 1
	   IPTR(ILAST) = 0
	   IF (IFLAG.NE.-5) IFLAG  = 2
	   IF (.NOT.ABORT2) GO TO 70
	   IDISP(2) = IACTIV
	   IFLAG  = -2
	   IF (LP.NE.0) WRITE (LP,FMT=99998)
	   GO TO 1120

   70    A(IBEG) = A(IACTIV)
	   ICN(IBEG) = ICN(IACTIV)
	   IACTIV = IACTIV + 1
	   IPTR(ISTART) = 0
	   IBEG   = IBEG + 1
	   NZROW  = NZROW - 1
   80    LASTR(ISTART) = ISTART
	   IPC(ISTART) = -ISING
	   GO TO 1000
C
C NON-TRIVIAL BLOCK.
   90    ITOP   = LICN
	   IF (ILAST.NE.NN) ITOP   = IPTR(ILAST+1) - 1
C
C SET UP COLUMN ORIENTED STORAGE.
	   DO 100 I = ISTART,ILAST
		LENRL(I) = 0
		LENC(I) = 0
  100    CONTINUE
	   IF (ITOP-IACTIV.LT.LIRN) GO TO 110
	   MINIRN = ITOP - IACTIV + 1
	   PIVOT  = ISTART - 1
	   GO TO 1100
C
C CALCULATE COLUMN COUNTS.
  110    DO 120 II = IACTIV,ITOP
		I      = ICN(II)
		LENC(I) = LENC(I) + 1
  120    CONTINUE
C SET UP COLUMN POINTERS SO THAT IPC(J) POINTS TO POSITION AFTER END
C     OF COLUMN J IN COLUMN FILE.
	   IPC(ILAST) = LIRN + 1
	   J1     = ISTART + 1
	   DO 130 JJ = J1,ILAST
		J      = ILAST - JJ + J1 - 1
		IPC(J) = IPC(J+1) - LENC(J+1)
  130    CONTINUE
	   DO 150 INDROW = ISTART,ILAST
		J1     = IPTR(INDROW)
		J2     = J1 + LENR(INDROW) - 1
		IF (J1.GT.J2) GO TO 150
		DO 140 JJ = J1,J2
		   J      = ICN(JJ)
		   IPOS   = IPC(J) - 1
		   IRN(IPOS) = INDROW
		   IPC(J) = IPOS
  140       CONTINUE
  150    CONTINUE
C DISPC IS THE LOWEST INDEXED ACTIVE LOCATION IN THE COLUMN FILE.
	   DISPC  = IPC(ISTART)
	   NZCOL  = LIRN - DISPC + 1
	   MINIRN = MAX0(NZCOL,MINIRN)
	   NZMIN  = 1
C
C INITIALIZE ARRAY IFIRST.  IFIRST(I) = +/- K INDICATES THAT ROW/COL
C     K HAS I NON-ZEROS.  IF IFIRST(I) = 0, THERE IS NO ROW OR COLUMN
C     WITH I NON ZEROS.
	   DO 160 I = 1,N
		IFIRST(I) = 0
  160    CONTINUE
C
C COMPUTE ORDERING OF ROW AND COLUMN COUNTS.
C FIRST RUN THROUGH COLUMNS (FROM COLUMN N TO COLUMN 1).
	   DO 180 JJ = ISTART,ILAST
		J      = ILAST - JJ + ISTART
		NZ     = LENC(J)
		IF (NZ.NE.0) GO TO 170
		IPC(J) = 0
		GO TO 180

  170       IF (NSRCH.LE.NN) GO TO 180
		ISW    = IFIRST(NZ)
		IFIRST(NZ) = -J
		LASTC(J) = 0
		NEXTC(J) = -ISW
		ISW1   = IABS(ISW)
		IF (ISW.NE.0) LASTC(ISW1) = J
  180    CONTINUE
C NOW RUN THROUGH ROWS (AGAIN FROM N TO 1).
	   DO 210 II = ISTART,ILAST
		I      = ILAST - II + ISTART
		NZ     = LENR(I)
		IF (NZ.NE.0) GO TO 190
		IPTR(I) = 0
		LASTR(I) = 0
		GO TO 210

  190       ISW    = IFIRST(NZ)
		IFIRST(NZ) = I
		IF (ISW.GT.0) GO TO 200
		NEXTR(I) = 0
		LASTR(I) = ISW
		GO TO 210

  200       NEXTR(I) = ISW
		LASTR(I) = LASTR(ISW)
		LASTR(ISW) = I
  210    CONTINUE
C
C
C **********************************************
C ****    START OF MAIN ELIMINATION LOOP    ****
C **********************************************
	   DO 980 PIVOT = ISTART,ILAST
C
C FIRST FIND THE PIVOT USING MARKOWITZ CRITERION WITH STABILITY
C     CONTROL.
C JCOST IS THE MARKOWITZ COST OF THE BEST PIVOT SO FAR,.. THIS
C     PIVOT IS IN ROW IPIV AND COLUMN JPIV.
		NZ2    = NZMIN
		JCOST  = N*N
C
C EXAMINE ROWS/COLUMNS IN ORDER OF ASCENDING COUNT.
		DO 340 L = 1,2
		   PIVRAT = ZERO
		   ISRCH  = 1
		   LL     = L
C A PASS WITH L EQUAL TO 2 IS ONLY PERFORMED IN THE CASE OF SINGULARITY.
		   DO 330 NZ = NZ2,N
			IF (JCOST.LE. (NZ-1)**2) GO TO 420
			IJFIR  = IFIRST(NZ)
			IF (IJFIR) 230,220,240
  220             IF (LL.EQ.1) NZMIN  = NZ + 1
			GO TO 330

  230             LL     = 2
			IJFIR  = -IJFIR
			GO TO 290

  240             LL     = 2
C SCAN ROWS WITH NZ NON-ZEROS.
			DO 270 IDUMMY = 1,N
			   IF (JCOST.LE. (NZ-1)**2) GO TO 420
			   IF (ISRCH.GT.MSRCH) GO TO 420
			   IF (IJFIR.EQ.0) GO TO 280
C ROW IJFIR IS NOW EXAMINED.
			   I      = IJFIR
			   IJFIR  = NEXTR(I)
C FIRST CALCULATE MULTIPLIER THRESHOLD LEVEL.
			   AMAX   = ZERO
			   J1     = IPTR(I) + LENRL(I)
			   J2     = IPTR(I) + LENR(I) - 1
			   DO 250 JJ = J1,J2
				AMAX   = DMAX1(AMAX,DABS(A(JJ)))
  250                CONTINUE
			   AU     = AMAX*U
			   ISRCH  = ISRCH + 1
C SCAN ROW FOR POSSIBLE PIVOTS
			   DO 260 JJ = J1,J2
				IF (DABS(A(JJ)).LE.AU .AND. L.EQ.1) GO TO 260
				J      = ICN(JJ)
				KCOST  = (NZ-1)* (LENC(J)-1)
				IF (KCOST.GT.JCOST) GO TO 260
				PIVR   = ZERO
				IF (AMAX.NE.ZERO) PIVR   = DABS(A(JJ))/AMAX
				IF (KCOST.EQ.JCOST .AND.
     +                      (PIVR.LE.PIVRAT.OR.NSRCH.GT.NN+1)) GO TO 260
C BEST PIVOT SO FAR IS FOUND.
				JCOST  = KCOST
				IJPOS  = JJ
				IPIV   = I
				JPIV   = J
				IF (MSRCH.GT.NN+1 .AND.
     +                      JCOST.LE. (NZ-1)**2) GO TO 420
				PIVRAT = PIVR
  260                CONTINUE
  270             CONTINUE
C
C COLUMNS WITH NZ NON-ZEROS NOW EXAMINED.
  280             IJFIR  = IFIRST(NZ)
			IJFIR  = -LASTR(IJFIR)
  290             IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
			IF (MSRCH.LE.NN) GO TO 330
			DO 320 IDUMMY = 1,N
			   IF (IJFIR.EQ.0) GO TO 330
			   J      = IJFIR
			   IJFIR  = NEXTC(IJFIR)
			   I1     = IPC(J)
			   I2     = I1 + NZ - 1
C SCAN COLUMN J.
			   DO 310 II = I1,I2
				I      = IRN(II)
				KCOST  = (NZ-1)* (LENR(I)-LENRL(I)-1)
				IF (KCOST.GE.JCOST) GO TO 310
C PIVOT HAS BEST MARKOWITZ COUNT SO FAR ... NOW CHECK ITS
C     SUITABILITY ON NUMERIC GROUNDS BY EXAMINING THE OTHER NON-ZEROS
C     IN ITS ROW.
				J1     = IPTR(I) + LENRL(I)
				J2     = IPTR(I) + LENR(I) - 1
C WE NEED A STABILITY CHECK ON SINGLETON COLUMNS BECAUSE OF POSSIBLE
C     PROBLEMS WITH UNDERDETERMINED SYSTEMS.
				AMAX   = ZERO
				DO 300 JJ = J1,J2
				   AMAX   = DMAX1(AMAX,DABS(A(JJ)))
				   IF (ICN(JJ).EQ.J) JPOS   = JJ
  300                   CONTINUE
				IF (DABS(A(JPOS)).LE.AMAX*U .AND.
     +                      L.EQ.1) GO TO 310
				JCOST  = KCOST
				IPIV   = I
				JPIV   = J
				IJPOS  = JPOS
				IF (AMAX.NE.ZERO) PIVRAT = DABS(A(JPOS))/AMAX
				IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
  310                CONTINUE
C
  320             CONTINUE
C
  330          CONTINUE
C IN THE EVENT OF SINGULARITY, WE MUST MAKE SURE ALL ROWS AND COLUMNS
C ARE TESTED.
		   MSRCH  = N
C
C MATRIX IS NUMERICALLY OR STRUCTURALLY SINGULAR  ... WHICH IT IS WILL
C     BE DIAGNOSED LATER.
		   IRANK  = IRANK - 1
  340       CONTINUE
C ASSIGN REST OF ROWS AND COLUMNS TO ORDERING ARRAY.
C MATRIX IS STRUCTURALLY SINGULAR.
		IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG  = 1
		IRANK  = IRANK - ILAST + PIVOT + 1
		IF (.NOT.ABORT1) GO TO 350
		IDISP(2) = IACTIV
		IFLAG  = -1
		IF (LP.NE.0) WRITE (LP,FMT=99999)
		GO TO 1120

  350       K      = PIVOT - 1
		DO 390 I = ISTART,ILAST
		   IF (LASTR(I).NE.0) GO TO 390
		   K      = K + 1
		   LASTR(I) = K
		   IF (LENRL(I).EQ.0) GO TO 380
		   MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENRL(I))
		   IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
		   CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
		   IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
		   MOREI  = MOREI + IBEG - IDISP(1)
		   IBEG   = IDISP(1)
		   IF (LP.NE.0) WRITE (LP,FMT=99997)
		   IFLAG  = -5
		   IF (ABORT3) GO TO 1090
  360          J1     = IPTR(I)
		   J2     = J1 + LENRL(I) - 1
		   IPTR(I) = 0
		   DO 370 JJ = J1,J2
			A(IBEG) = A(JJ)
			ICN(IBEG) = ICN(JJ)
			ICN(JJ) = 0
			IBEG   = IBEG + 1
  370          CONTINUE
		   NZROW  = NZROW - LENRL(I)
  380          IF (K.EQ.ILAST) GO TO 400
  390       CONTINUE
  400       K      = PIVOT - 1
		DO 410 I = ISTART,ILAST
		   IF (IPC(I).NE.0) GO TO 410
		   K      = K + 1
		   IPC(I) = K
		   IF (K.EQ.ILAST) GO TO 990
  410       CONTINUE
C
C THE PIVOT HAS NOW BEEN FOUND IN POSITION (IPIV,JPIV) IN LOCATION
C     IJPOS IN ROW FILE.
C UPDATE COLUMN AND ROW ORDERING ARRAYS TO CORRESPOND WITH REMOVAL
C     OF THE ACTIVE PART OF THE MATRIX.
  420       ISING  = PIVOT
		IF (A(IJPOS).NE.ZERO) GO TO 430
C NUMERICAL SINGULARITY IS RECORDED HERE.
		ISING  = -ISING
		IF (IFLAG.NE.-5) IFLAG  = 2
		IF (.NOT.ABORT2) GO TO 430
		IDISP(2) = IACTIV
		IFLAG  = -2
		IF (LP.NE.0) WRITE (LP,FMT=99998)
		GO TO 1120

  430       OLDPIV = IPTR(IPIV) + LENRL(IPIV)
		OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHANGES TO COLUMN ORDERING.
		IF (NSRCH.LE.NN) GO TO 460
		COLUPD = NN + 1
		DO 450 JJ = OLDPIV,OLDEND
		   J      = ICN(JJ)
		   LC     = LASTC(J)
		   NC     = NEXTC(J)
		   NEXTC(J) = -COLUPD
		   IF (JJ.NE.IJPOS) COLUPD = J
		   IF (NC.NE.0) LASTC(NC) = LC
		   IF (LC.EQ.0) GO TO 440
		   NEXTC(LC) = NC
		   GO TO 450

  440          NZ     = LENC(J)
		   ISW    = IFIRST(NZ)
		   IF (ISW.GT.0) LASTR(ISW) = -NC
		   IF (ISW.LT.0) IFIRST(NZ) = -NC
  450       CONTINUE
C CHANGES TO ROW ORDERING.
  460       I1     = IPC(JPIV)
		I2     = I1 + LENC(JPIV) - 1
		DO 480 II = I1,I2
		   I      = IRN(II)
		   LR     = LASTR(I)
		   NR     = NEXTR(I)
		   IF (NR.NE.0) LASTR(NR) = LR
		   IF (LR.LE.0) GO TO 470
		   NEXTR(LR) = NR
		   GO TO 480

  470          NZ     = LENR(I) - LENRL(I)
		   IF (NR.NE.0) IFIRST(NZ) = NR
		   IF (NR.EQ.0) IFIRST(NZ) = LR
  480       CONTINUE
C
C MOVE PIVOT TO POSITION LENRL+1 IN PIVOT ROW AND MOVE PIVOT ROW
C     TO THE BEGINNING OF THE AVAILABLE STORAGE.
C THE L PART AND THE PIVOT IN THE OLD COPY OF THE PIVOT ROW IS
C     NULLIFIED WHILE, IN THE STRICTLY UPPER TRIANGULAR PART, THE
C     COLUMN INDICES, J SAY, ARE OVERWRITTEN BY THE CORRESPONDING
C     ENTRY OF IQ (IQ(J)) AND IQ(J) IS SET TO THE NEGATIVE OF THE
C     DISPLACEMENT OF THE COLUMN INDEX FROM THE PIVOT ENTRY.
		IF (OLDPIV.EQ.IJPOS) GO TO 490
		AU     = A(OLDPIV)
		A(OLDPIV) = A(IJPOS)
		A(IJPOS) = AU
		ICN(IJPOS) = ICN(OLDPIV)
		ICN(OLDPIV) = JPIV
C CHECK TO SEE IF THERE IS SPACE IMMEDIATELY AVAILABLE IN A/ICN TO
C     HOLD NEW COPY OF PIVOT ROW.
  490       MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENR(IPIV))
		IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
		CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
		OLDPIV = IPTR(IPIV) + LENRL(IPIV)
		OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
		IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
		MOREI  = MOREI + IBEG - IDISP(1)
		IBEG   = IDISP(1)
		IF (LP.NE.0) WRITE (LP,FMT=99997)
		IFLAG  = -5
		IF (ABORT3) GO TO 1090
		IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C THERE IS STILL NOT ENOUGH ROOM IN A/ICN.
		IFLAG  = -4
		GO TO 1090
C COPY PIVOT ROW AND SET UP IQ ARRAY.
  500       IJPOS  = 0
		J1     = IPTR(IPIV)
C
		DO 530 JJ = J1,OLDEND
		   A(IBEG) = A(JJ)
		   ICN(IBEG) = ICN(JJ)
		   IF (IJPOS.NE.0) GO TO 510
		   IF (ICN(JJ).EQ.JPIV) IJPOS  = IBEG
		   ICN(JJ) = 0
		   GO TO 520

  510          K      = IBEG - IJPOS
		   J      = ICN(JJ)
		   ICN(JJ) = IQ(J)
		   IQ(J)  = -K
  520          IBEG   = IBEG + 1
  530       CONTINUE
C
		IJP1   = IJPOS + 1
		PIVEND = IBEG - 1
		LENPIV = PIVEND - IJPOS
		NZROW  = NZROW - LENRL(IPIV) - 1
		IPTR(IPIV) = OLDPIV + 1
		IF (LENPIV.EQ.0) IPTR(IPIV) = 0
C
C REMOVE PIVOT ROW (INCLUDING PIVOT) FROM COLUMN ORIENTED FILE.
		DO 560 JJ = IJPOS,PIVEND
		   J      = ICN(JJ)
		   I1     = IPC(J)
		   LENC(J) = LENC(J) - 1
C I2 IS LAST POSITION IN NEW COLUMN.
		   I2     = IPC(J) + LENC(J) - 1
		   IF (I2.LT.I1) GO TO 550
		   DO 540 II = I1,I2
			IF (IRN(II).NE.IPIV) GO TO 540
			IRN(II) = IRN(I2+1)
			GO TO 550

  540          CONTINUE
  550          IRN(I2+1) = 0
  560       CONTINUE
		NZCOL  = NZCOL - LENPIV - 1
C
C GO DOWN THE PIVOT COLUMN AND FOR EACH ROW WITH A NON-ZERO ADD
C     THE APPROPRIATE MULTIPLE OF THE PIVOT ROW TO IT.
C WE LOOP ON THE NUMBER OF NON-ZEROS IN THE PIVOT COLUMN SINCE
C     MA30D/DD MAY CHANGE ITS ACTUAL POSITION.
C
		NZPC   = LENC(JPIV)
		IF (NZPC.EQ.0) GO TO 900
		DO 840 III = 1,NZPC
		   II     = IPC(JPIV) + III - 1
		   I      = IRN(II)
C SEARCH ROW I FOR NON-ZERO TO BE ELIMINATED, CALCULATE MULTIPLIER,
C     AND PLACE IT IN POSITION LENRL+1 IN ITS ROW.
C  IDROP IS THE NUMBER OF NON-ZERO ENTRIES DROPPED FROM ROW    I
C        BECAUSE THESE FALL BENEATH TOLERANCE LEVEL.
C
		   IDROP  = 0
		   J1     = IPTR(I) + LENRL(I)
		   IEND   = IPTR(I) + LENR(I) - 1
		   DO 570 JJ = J1,IEND
			IF (ICN(JJ).NE.JPIV) GO TO 570
C IF PIVOT IS ZERO, REST OF COLUMN IS AND SO MULTIPLIER IS ZERO.
			AU     = ZERO
			IF (A(IJPOS).NE.ZERO) AU     = -A(JJ)/A(IJPOS)
			IF (LBIG) BIG    = DMAX1(BIG,DABS(AU))
			A(JJ)  = A(J1)
			A(J1)  = AU
			ICN(JJ) = ICN(J1)
			ICN(J1) = JPIV
			LENRL(I) = LENRL(I) + 1
			GO TO 580

  570          CONTINUE
C JUMP IF PIVOT ROW IS A SINGLETON.
  580          IF (LENPIV.EQ.0) GO TO 840
C NOW PERFORM NECESSARY OPERATIONS ON REST OF NON-PIVOT ROW I.
		   ROWI   = J1 + 1
		   IOP    = 0
C JUMP IF ALL THE PIVOT ROW CAUSES FILL-IN.
		   IF (ROWI.GT.IEND) GO TO 650
C PERFORM OPERATIONS ON CURRENT NON-ZEROS IN ROW I.
C INNERMOST LOOP.
		   DO 590 JJ = ROWI,IEND
			J      = ICN(JJ)
			IF (IQ(J).GT.0) GO TO 590
			IOP    = IOP + 1
			PIVROW = IJPOS - IQ(J)
			A(JJ)  = A(JJ) + AU*A(PIVROW)
			IF (LBIG) BIG    = DMAX1(DABS(A(JJ)),BIG)
			ICN(PIVROW) = -ICN(PIVROW)
			IF (DABS(A(JJ)).LT.TOL) IDROP  = IDROP + 1
  590          CONTINUE
C
C  JUMP IF NO NON-ZEROS IN NON-PIVOT ROW HAVE BEEN REMOVED
C       BECAUSE THESE ARE BENEATH THE DROP-TOLERANCE  TOL.
C
		   IF (IDROP.EQ.0) GO TO 650
C
C  RUN THROUGH NON-PIVOT ROW COMPRESSING ROW SO THAT ONLY
C      NON-ZEROS GREATER THAN   TOL   ARE STORED.  ALL NON-ZEROS
C      LESS THAN   TOL   ARE ALSO REMOVED FROM THE COLUMN STRUCTURE.
C
		   JNEW   = ROWI
		   DO 630 JJ = ROWI,IEND
			IF (DABS(A(JJ)).LT.TOL) GO TO 600
			A(JNEW) = A(JJ)
			ICN(JNEW) = ICN(JJ)
			JNEW   = JNEW + 1
			GO TO 630
C
C  REMOVE NON-ZERO ENTRY FROM COLUMN STRUCTURE.
C
  600             J      = ICN(JJ)
			I1     = IPC(J)
			I2     = I1 + LENC(J) - 1
			DO 610 II = I1,I2
			   IF (IRN(II).EQ.I) GO TO 620
  610             CONTINUE
  620             IRN(II) = IRN(I2)
			IRN(I2) = 0
			LENC(J) = LENC(J) - 1
			IF (NSRCH.LE.NN) GO TO 630
C REMOVE COLUMN FROM COLUMN CHAIN AND PLACE IN UPDATE CHAIN.
			IF (NEXTC(J).LT.0) GO TO 630
C JUMP IF COLUMN ALREADY IN UPDATE CHAIN.
			LC     = LASTC(J)
			NC     = NEXTC(J)
			NEXTC(J) = -COLUPD
			COLUPD = J
			IF (NC.NE.0) LASTC(NC) = LC
			IF (LC.EQ.0) GO TO 622
			NEXTC(LC) = NC
			GO TO 630

  622             NZ     = LENC(J) + 1
			ISW    = IFIRST(NZ)
			IF (ISW.GT.0) LASTR(ISW) = -NC
			IF (ISW.LT.0) IFIRST(NZ) = -NC
  630          CONTINUE
		   DO 640 JJ = JNEW,IEND
			ICN(JJ) = 0
  640          CONTINUE
C THE VALUE OF IDROP MIGHT BE DIFFERENT FROM THAT CALCULATED EARLIER
C     BECAUSE, WE MAY NOW HAVE DROPPED SOME NON-ZEROS WHICH WERE NOT
C     MODIFIED BY THE PIVOT ROW.
		   IDROP  = IEND + 1 - JNEW
		   IEND   = JNEW - 1
		   LENR(I) = LENR(I) - IDROP
		   NZROW  = NZROW - IDROP
		   NZCOL  = NZCOL - IDROP
		   NDROP  = NDROP + IDROP
  650          IFILL  = LENPIV - IOP
C JUMP IS IF THERE IS NO FILL-IN.
		   IF (IFILL.EQ.0) GO TO 750
C NOW FOR THE FILL-IN.
		   MINICN = MAX0(MINICN,MOREI+IBEG-1+NZROW+IFILL+LENR(I))
C SEE IF THERE IS ROOM FOR FILL-IN.
C GET MAXIMUM SPACE FOR ROW I IN SITU.
		   DO 660 JDIFF = 1,IFILL
			JNPOS  = IEND + JDIFF
			IF (JNPOS.GT.LICN) GO TO 670
			IF (ICN(JNPOS).NE.0) GO TO 670
  660          CONTINUE
C THERE IS ROOM FOR ALL THE FILL-IN AFTER THE END OF THE ROW SO IT
C     CAN BE LEFT IN SITU.
C NEXT AVAILABLE SPACE FOR FILL-IN.
		   IEND   = IEND + 1
		   GO TO 750
C JMORE SPACES FOR FILL-IN ARE REQUIRED IN FRONT OF ROW.
  670          JMORE  = IFILL - JDIFF + 1
		   I1     = IPTR(I)
C WE NOW LOOK IN FRONT OF THE ROW TO SEE IF THERE IS SPACE FOR
C     THE REST OF THE FILL-IN.
		   DO 680 JDIFF = 1,JMORE
			JNPOS  = I1 - JDIFF
			IF (JNPOS.LT.IACTIV) GO TO 690
			IF (ICN(JNPOS).NE.0) GO TO 700
  680          CONTINUE
  690          JNPOS  = I1 - JMORE
		   GO TO 710
C WHOLE ROW MUST BE MOVED TO THE BEGINNING OF AVAILABLE STORAGE.
  700          JNPOS  = IACTIV - LENR(I) - IFILL
C JUMP IF THERE IS SPACE IMMEDIATELY AVAILABLE FOR THE SHIFTED ROW.
  710          IF (JNPOS.GE.IBEG) GO TO 730
		   CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
		   I1     = IPTR(I)
		   IEND   = I1 + LENR(I) - 1
		   JNPOS  = IACTIV - LENR(I) - IFILL
		   IF (JNPOS.GE.IBEG) GO TO 730
C NO SPACE AVAILABLE SO TRY TO CREATE SOME BY THROWING AWAY PREVIOUS
C     LU DECOMPOSITION.
		   MOREI  = MOREI + IBEG - IDISP(1) - LENPIV - 1
		   IF (LP.NE.0) WRITE (LP,FMT=99997)
		   IFLAG  = -5
		   IF (ABORT3) GO TO 1090
C KEEP RECORD OF CURRENT PIVOT ROW.
		   IBEG   = IDISP(1)
		   ICN(IBEG) = JPIV
		   A(IBEG) = A(IJPOS)
		   IJPOS  = IBEG
		   DO 720 JJ = IJP1,PIVEND
			IBEG   = IBEG + 1
			A(IBEG) = A(JJ)
			ICN(IBEG) = ICN(JJ)
  720          CONTINUE
		   IJP1   = IJPOS + 1
		   PIVEND = IBEG
		   IBEG   = IBEG + 1
		   IF (JNPOS.GE.IBEG) GO TO 730
C THIS STILL DOES NOT GIVE ENOUGH ROOM.
		   IFLAG  = -4
		   GO TO 1090

  730          IACTIV = MIN0(IACTIV,JNPOS)
C MOVE NON-PIVOT ROW I.
		   IPTR(I) = JNPOS
		   DO 740 JJ = I1,IEND
			A(JNPOS) = A(JJ)
			ICN(JNPOS) = ICN(JJ)
			JNPOS  = JNPOS + 1
			ICN(JJ) = 0
  740          CONTINUE
C FIRST NEW AVAILABLE SPACE.
		   IEND   = JNPOS
  750          NZROW  = NZROW + IFILL
C INNERMOST FILL-IN LOOP WHICH ALSO RESETS ICN.
		   IDROP  = 0
		   DO 830 JJ = IJP1,PIVEND
			J      = ICN(JJ)
			IF (J.LT.0) GO TO 820
			ANEW   = AU*A(JJ)
			AANEW  = DABS(ANEW)
			IF (AANEW.GE.TOL) GO TO 760
			IDROP  = IDROP + 1
			NDROP  = NDROP + 1
			NZROW  = NZROW - 1
			MINICN = MINICN - 1
			IFILL  = IFILL - 1
			GO TO 830

  760             IF (LBIG) BIG    = DMAX1(AANEW,BIG)
			A(IEND) = ANEW
			ICN(IEND) = J
			IEND   = IEND + 1
C
C PUT NEW ENTRY IN COLUMN FILE.
			MINIRN = MAX0(MINIRN,NZCOL+LENC(J)+1)
			JEND   = IPC(J) + LENC(J)
			JROOM  = NZPC - III + 1 + LENC(J)
			IF (JEND.GT.LIRN) GO TO 770
			IF (IRN(JEND).EQ.0) GO TO 810
  770             IF (JROOM.LT.DISPC) GO TO 780
C COMPRESS COLUMN FILE TO OBTAIN SPACE FOR NEW COPY OF COLUMN.
			CALL MA30DD(A,IRN,IPC(ISTART),N,DISPC,LIRN,.FALSE.)
			IF (JROOM.LT.DISPC) GO TO 780
			JROOM  = DISPC - 1
			IF (JROOM.GE.LENC(J)+1) GO TO 780
C COLUMN FILE IS NOT LARGE ENOUGH.
			GO TO 1100
C COPY COLUMN TO BEGINNING OF FILE.
  780             JBEG   = IPC(J)
			JEND   = IPC(J) + LENC(J) - 1
			JZERO  = DISPC - 1
			DISPC  = DISPC - JROOM
			IDISPC = DISPC
			DO 790 II = JBEG,JEND
			   IRN(IDISPC) = IRN(II)
			   IRN(II) = 0
			   IDISPC = IDISPC + 1
  790             CONTINUE
			IPC(J) = DISPC
			JEND   = IDISPC
			DO 800 II = JEND,JZERO
			   IRN(II) = 0
  800             CONTINUE
  810             IRN(JEND) = I
			NZCOL  = NZCOL + 1
			LENC(J) = LENC(J) + 1
C END OF ADJUSTMENT TO COLUMN FILE.
			GO TO 830
C
  820             ICN(JJ) = -J
  830          CONTINUE
		   IF (IDROP.EQ.0) GO TO 834
		   DO 832 KDROP = 1,IDROP
			ICN(IEND) = 0
			IEND   = IEND + 1
  832          CONTINUE
  834          LENR(I) = LENR(I) + IFILL
C END OF SCAN OF PIVOT COLUMN.
  840       CONTINUE
C
C
C REMOVE PIVOT COLUMN FROM COLUMN ORIENTED STORAGE AND UPDATE ROW
C     ORDERING ARRAYS.
		I1     = IPC(JPIV)
		I2     = IPC(JPIV) + LENC(JPIV) - 1
		NZCOL  = NZCOL - LENC(JPIV)
		DO 890 II = I1,I2
		   I      = IRN(II)
		   IRN(II) = 0
		   NZ     = LENR(I) - LENRL(I)
		   IF (NZ.NE.0) GO TO 850
		   LASTR(I) = 0
		   GO TO 890

  850          IFIR   = IFIRST(NZ)
		   IFIRST(NZ) = I
		   IF (IFIR) 860,880,870
  860          LASTR(I) = IFIR
		   NEXTR(I) = 0
		   GO TO 890

  870          LASTR(I) = LASTR(IFIR)
		   NEXTR(I) = IFIR
		   LASTR(IFIR) = I
		   GO TO 890

  880          LASTR(I) = 0
		   NEXTR(I) = 0
		   NZMIN  = MIN0(NZMIN,NZ)
  890       CONTINUE
C RESTORE IQ AND NULLIFY U PART OF OLD PIVOT ROW.
C    RECORD THE COLUMN PERMUTATION IN LASTC(JPIV) AND THE ROW
C    PERMUTATION IN LASTR(IPIV).
  900       IPC(JPIV) = -ISING
		LASTR(IPIV) = PIVOT
		IF (LENPIV.EQ.0) GO TO 980
		NZROW  = NZROW - LENPIV
		JVAL   = IJP1
		JZER   = IPTR(IPIV)
		IPTR(IPIV) = 0
		DO 910 JCOUNT = 1,LENPIV
		   J      = ICN(JVAL)
		   IQ(J)  = ICN(JZER)
		   ICN(JZER) = 0
		   JVAL   = JVAL + 1
		   JZER   = JZER + 1
  910       CONTINUE
C ADJUST COLUMN ORDERING ARRAYS.
		IF (NSRCH.GT.NN) GO TO 920
		DO 916 JJ = IJP1,PIVEND
		   J      = ICN(JJ)
		   NZ     = LENC(J)
		   IF (NZ.NE.0) GO TO 914
		   IPC(J) = 0
		   GO TO 916

  914          NZMIN  = MIN0(NZMIN,NZ)
  916       CONTINUE
		GO TO 980

  920       JJ     = COLUPD
		DO 970 JDUMMY = 1,NN
		   J      = JJ
		   IF (J.EQ.NN+1) GO TO 980
		   JJ     = -NEXTC(J)
		   NZ     = LENC(J)
		   IF (NZ.NE.0) GO TO 924
		   IPC(J) = 0
		   GO TO 970

  924          IFIR   = IFIRST(NZ)
		   LASTC(J) = 0
		   IF (IFIR) 930,940,950
  930          IFIRST(NZ) = -J
		   IFIR   = -IFIR
		   LASTC(IFIR) = J
		   NEXTC(J) = IFIR
		   GO TO 970

  940          IFIRST(NZ) = -J
		   NEXTC(J) = 0
		   GO TO 960

  950          LC     = -LASTR(IFIR)
		   LASTR(IFIR) = -J
		   NEXTC(J) = LC
		   IF (LC.NE.0) LASTC(LC) = J
  960          NZMIN  = MIN0(NZMIN,NZ)
  970       CONTINUE
  980    CONTINUE
C ********************************************
C ****    END OF MAIN ELIMINATION LOOP    ****
C ********************************************
C
C RESET IACTIV TO POINT TO THE BEGINNING OF THE NEXT BLOCK.
  990    IF (ILAST.NE.NN) IACTIV = IPTR(ILAST+1)
 1000 CONTINUE
C
C ********************************************
C ****    END OF DEOMPOSITION OF BLOCK    ****
C ********************************************
C
C RECORD SINGULARITY (IF ANY) IN IQ ARRAY.
	IF (IRANK.EQ.NN) GO TO 1020
	DO 1010 I = 1,NN
	   IF (IPC(I).LT.0) GO TO 1010
	   ISING  = IPC(I)
	   IQ(ISING) = -IQ(ISING)
	   IPC(I) = -ISING
 1010 CONTINUE
C
C RUN THROUGH LU DECOMPOSITION CHANGING COLUMN INDICES TO THAT OF NEW
C     ORDER AND PERMUTING LENR AND LENRL ARRAYS ACCORDING TO PIVOT
C     PERMUTATIONS.
 1020 ISTART = IDISP(1)
	IEND   = IBEG - 1
	IF (IEND.LT.ISTART) GO TO 1040
	DO 1030 JJ = ISTART,IEND
	   JOLD   = ICN(JJ)
	   ICN(JJ) = -IPC(JOLD)
 1030 CONTINUE
 1040 DO 1050 II = 1,NN
	   I      = LASTR(II)
	   NEXTR(I) = LENR(II)
	   IPTR(I) = LENRL(II)
 1050 CONTINUE
	DO 1060 I = 1,NN
	   LENRL(I) = IPTR(I)
	   LENR(I) = NEXTR(I)
 1060 CONTINUE
C
C UPDATE PERMUTATION ARRAYS IP AND IQ.
	DO 1070 II = 1,NN
	   I      = LASTR(II)
	   J      = -IPC(II)
	   NEXTR(I) = IABS(IP(II)+0)
	   IPTR(J) = IABS(IQ(II)+0)
 1070 CONTINUE
	DO 1080 I = 1,NN
	   IF (IP(I).LT.0) NEXTR(I) = -NEXTR(I)
	   IP(I)  = NEXTR(I)
	   IF (IQ(I).LT.0) IPTR(I) = -IPTR(I)
	   IQ(I)  = IPTR(I)
 1080 CONTINUE
	IP(NN) = IABS(IP(NN)+0)
	IDISP(2) = IEND
	GO TO 1120
C
C   ***    ERROR RETURNS    ***
 1090 IDISP(2) = IACTIV
	IF (LP.EQ.0) GO TO 1120
	WRITE (LP,FMT=99996)
	GO TO 1110

 1100 IF (IFLAG.EQ.-5) IFLAG  = -6
	IF (IFLAG.NE.-6) IFLAG  = -3
	IDISP(2) = IACTIV
	IF (LP.EQ.0) GO TO 1120
	IF (IFLAG.EQ.-3) WRITE (LP,FMT=99995)
	IF (IFLAG.EQ.-6) WRITE (LP,FMT=99994)
 1110 PIVOT  = PIVOT - ISTART + 1
	WRITE (LP,FMT=99993) PIVOT,NBLOCK,ISTART,ILAST
	IF (PIVOT.EQ.0) WRITE (LP,FMT=99992) MINIRN
C
C
 1120 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS STRUCTUR',
     +       'ALLY SINGULAR')
99998 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS NUMERICA',
     +       'LLY SINGULAR')
99997 FORMAT (' LU DECOMPOSITION DESTROYED TO CREATE MORE SPACE')
99996 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LICN NOT BIG ENOUG',
     +       'H')
99995 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LIRN NOT BIG ENOUG',
     +       'H')
99994 FORMAT (' ERROR RETURN FROM MA30A/AD LIRN AND LICN TOO SMALL')
99993 FORMAT (' AT STAGE ',I5,' IN BLOCK ',I5,' WITH FIRST ROW ',I5,
     +       ' AND LAST ROW ',I5)
99992 FORMAT (' TO CONTINUE SET LIRN TO AT LEAST ',I8)

	END
	SUBROUTINE MA30BD(N,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,W,IW,IFLAG)
C MA30B/BD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF A
C     NEW MATRIX PAQ OF THE SAME SPARSITY PATTERN, USING INFORMATION
C     FROM A PREVIOUS CALL TO MA30A/AD. THE ENTRIES OF THE INPUT
C     MATRIX  MUST ALREADY BE IN THEIR FINAL POSITIONS IN THE LU
C     DECOMPOSITION STRUCTURE.  THIS ROUTINE EXECUTES ABOUT FIVE TIMES
C     FASTER THAN MA30A/AD.
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30B/BD. CONSULT MA30A/AD FOR
C     FURTHER INFORMATION ON THESE PARAMETERS.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. IT SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN THE USER MUST SET
C     ENTRIES IDISP(1) TO IDISP(2) TO CONTAIN THE ENTRIES IN THE
C     DIAGONAL BLOCKS OF THE MATRIX PAQ WHOSE COLUMN NUMBERS ARE HELD
C     IN ICN, USING CORRESPONDING POSITIONS. NOTE THAT SOME ZEROS MAY
C     NEED TO BE HELD EXPLICITLY. ON OUTPUT ENTRIES IDISP(1) TO
C     IDISP(2) OF ARRAY A CONTAIN THE LU DECOMPOSITION OF THE DIAGONAL
C     BLOCKS OF PAQ. ENTRIES A(1) TO A(IDISP(1)-1) ARE NEITHER
C     REQUIRED NOR ALTERED BY MA30B/BD.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY MA30B/BD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30B/BD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. IT SHOULD BE UNCHANGED SINCE
C     THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C IP,IQ  ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30B/BD.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30B/BD.
C IW  IS AN INTEGER ARRAY OF LENGTH N WHICH IS USED AS WORKSPACE BY
C     MA30B/BD.
C IFLAG  IS AN INTEGER VARIABLE. ON OUTPUT FROM MA30B/BD, IFLAG HAS
C     THE VALUE ZERO IF THE FACTORIZATION WAS SUCCESSFUL, HAS THE
C     VALUE I IF PIVOT I WAS VERY SMALL AND HAS THE VALUE -I IF AN
C     UNEXPECTED SINGULARITY WAS DETECTED AT STAGE I OF THE
C     DECOMPOSITION.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Scalar Arguments ..
	INTEGER IFLAG,LICN,N
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),W(N)
	INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),IW(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION AU,ONE,ROWMAX,ZERO
	INTEGER I,IFIN,ILEND,IPIVJ,ISING,ISTART,J,JAY,JAYJAY,JFIN,JJ,
     +        PIVPOS
	LOGICAL STAB
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1
C     ..
C     .. Common blocks ..
	COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
	COMMON /MA30GD/EPS,RMIN
	COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
	DOUBLE PRECISION BIG,EPS,RMIN,TOL
	INTEGER LP,NDROP,NSRCH
	LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
	DATA  ZERO/0.0D0/,ONE/1.0D0/
C     ..
	STAB   = EPS .LE. ONE
	RMIN   = EPS
	ISING  = 0
	IFLAG  = 0
	DO 10 I = 1,N
	   W(I)   = ZERO
   10 CONTINUE
C SET UP POINTERS TO THE BEGINNING OF THE ROWS.
	IW(1)  = IDISP(1)
	IF (N.EQ.1) GO TO 25
	DO 20 I = 2,N
	   IW(I)  = IW(I-1) + LENR(I-1)
   20 CONTINUE
C
C   ****   START  OF MAIN LOOP    ****
C AT STEP I, ROW I OF A IS TRANSFORMED TO ROW I OF L/U BY ADDING
C     APPROPRIATE MULTIPLES OF ROWS 1 TO I-1.
C     .... USING ROW-GAUSS ELIMINATION.
   25 DO 160 I = 1,N
C ISTART IS BEGINNING OF ROW I OF A AND ROW I OF L.
	   ISTART = IW(I)
C IFIN IS END OF ROW I OF A AND ROW I OF U.
	   IFIN   = ISTART + LENR(I) - 1
C ILEND IS END OF ROW I OF L.
	   ILEND  = ISTART + LENRL(I) - 1
	   IF (ISTART.GT.ILEND) GO TO 90
C LOAD ROW I OF A INTO VECTOR W.
	   DO 30 JJ = ISTART,IFIN
		J      = ICN(JJ)
		W(J)   = A(JJ)
   30    CONTINUE
C
C ADD MULTIPLES OF APPROPRIATE ROWS OF  I TO I-1  TO ROW I.
	   DO 70 JJ = ISTART,ILEND
		J      = ICN(JJ)
C IPIVJ IS POSITION OF PIVOT IN ROW J.
		IPIVJ  = IW(J) + LENRL(J)
C FORM MULTIPLIER AU.
		AU     = -W(J)/A(IPIVJ)
		IF (LBIG) BIG    = DMAX1(DABS(AU),BIG)
		W(J)   = AU
C AU * ROW J (U PART) IS ADDED TO ROW I.
		IPIVJ  = IPIVJ + 1
		JFIN   = IW(J) + LENR(J) - 1
		IF (IPIVJ.GT.JFIN) GO TO 70
C INNERMOST LOOP.
		IF (LBIG) GO TO 50
		DO 40 JAYJAY = IPIVJ,JFIN
		   JAY    = ICN(JAYJAY)
		   W(JAY) = W(JAY) + AU*A(JAYJAY)
   40       CONTINUE
		GO TO 70

   50       DO 60 JAYJAY = IPIVJ,JFIN
		   JAY    = ICN(JAYJAY)
		   W(JAY) = W(JAY) + AU*A(JAYJAY)
		   BIG    = DMAX1(DABS(W(JAY)),BIG)
   60       CONTINUE
   70    CONTINUE
C
C RELOAD W BACK INTO A (NOW L/U)
	   DO 80 JJ = ISTART,IFIN
		J      = ICN(JJ)
		A(JJ)  = W(J)
		W(J)   = ZERO
   80    CONTINUE
C WE NOW PERFORM THE STABILITY CHECKS.
   90    PIVPOS = ILEND + 1
	   IF (IQ(I).GT.0) GO TO 140
C MATRIX HAD SINGULARITY AT THIS POINT IN MA30A/AD.
C IS IT THE FIRST SUCH PIVOT IN CURRENT BLOCK ?
	   IF (ISING.EQ.0) ISING  = I
C DOES CURRENT MATRIX HAVE A SINGULARITY IN THE SAME PLACE ?
	   IF (PIVPOS.GT.IFIN) GO TO 100
	   IF (A(PIVPOS).NE.ZERO) GO TO 170
C IT DOES .. SO SET ISING IF IT IS NOT THE END OF THE CURRENT BLOCK
C CHECK TO SEE THAT APPROPRIATE PART OF L/U IS ZERO OR NULL.
  100    IF (ISTART.GT.IFIN) GO TO 120
	   DO 110 JJ = ISTART,IFIN
		IF (ICN(JJ).LT.ISING) GO TO 110
		IF (A(JJ).NE.ZERO) GO TO 170
  110    CONTINUE
  120    IF (PIVPOS.LE.IFIN) A(PIVPOS) = ONE
	   IF (IP(I).GT.0 .AND. I.NE.N) GO TO 160
C END OF CURRENT BLOCK ... RESET ZERO PIVOTS AND ISING.
	   DO 130 J = ISING,I
		IF ((LENR(J)-LENRL(J)).EQ.0) GO TO 130
		JJ     = IW(J) + LENRL(J)
		A(JJ)  = ZERO
  130    CONTINUE
	   ISING  = 0
	   GO TO 160
C MATRIX HAD NON-ZERO PIVOT IN MA30A/AD AT THIS STAGE.
  140    IF (PIVPOS.GT.IFIN) GO TO 170
	   IF (A(PIVPOS).EQ.ZERO) GO TO 170
	   IF (.NOT.STAB) GO TO 160
	   ROWMAX = ZERO
	   DO 150 JJ = PIVPOS,IFIN
		ROWMAX = DMAX1(ROWMAX,DABS(A(JJ)))
  150    CONTINUE
	   IF (DABS(A(PIVPOS))/ROWMAX.GE.RMIN) GO TO 160
	   IFLAG  = I
	   RMIN   = DABS(A(PIVPOS))/ROWMAX
C   ****    END OF MAIN LOOP    ****
  160 CONTINUE
C
	GO TO 180
C   ***   ERROR RETURN   ***
  170 IF (LP.NE.0) WRITE (LP,FMT=99999) I
	IFLAG  = -I
C
  180 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30B/BD SINGULARITY DETECTED IN RO',
     +       'W',I8)

        END
	SUBROUTINE MA30CD(N,ICN,A,LICN,LENR,LENRL,LENOFF,IDISP,IP,IQ,X,W,
     +                  MTYPE)
C MA30C/CD USES THE FACTORS PRODUCED BY MA30A/AD OR MA30B/BD TO SOLVE
C     AX=B OR A TRANSPOSE X=B WHEN THE MATRIX P1*A*Q1 (PAQ) IS BLOCK
C     LOWER TRIANGULAR (INCLUDING THE CASE OF ONLY ONE DIAGONAL
C     BLOCK).
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30C/CD.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX. IT IS NOT
C     ALTERED BY THE SUBROUTINE.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. ENTRIES IDISP(1) TO
C     IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO MA30A/AD. IF
C     THE MATRIX HAS MORE THAN ONE DIAGONAL BLOCK, THEN COLUMN INDICES
C     CORRESPONDING TO NON-ZEROS IN SUB-DIAGONAL BLOCKS OF PAQ MUST
C     APPEAR IN POSITIONS 1 TO IDISP(1)-1. FOR THE SAME ROW THOSE
C     ENTRIES MUST BE CONTIGUOUS, WITH THOSE IN ROW I PRECEDING THOSE
C     IN ROW I+1 (I=1,...,N-1) AND NO WASTED SPACE BETWEEN ROWS.
C     ENTRIES MAY BE IN ANY ORDER WITHIN EACH ROW. IT IS NOT ALTERED
C     BY MA30C/CD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN.  ENTRIES
C     IDISP(1) TO IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO
C     MA30A/AD OR MA30B/BD.  IF THE MATRIX HAS MORE THAN ONE DIAGONAL
C     BLOCK, THEN THE VALUES OF THE NON-ZEROS IN SUB-DIAGONAL BLOCKS
C     MUST BE IN POSITIONS 1 TO IDISP(1)-1 IN THE ORDER GIVEN BY ICN.
C     IT IS NOT ALTERED BY MA30C/CD.
C LICN  IS AN INTEGER VARIABLE SET TO THE SIZE OF ARRAYS ICN AND A.
C     IT IS NOT ALTERED BY MA30C/CD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30C/CD.
C LENOFF  IS AN INTEGER ARRAY OF LENGTH N. IF THE MATRIX PAQ (OR
C     P1*A*Q1) HAS MORE THAN ONE DIAGONAL BLOCK, THEN LENOFF(I),
C     I=1,...,N SHOULD BE SET TO THE NUMBER OF NON-ZEROS IN ROW I OF
C     THE MATRIX PAQ WHICH ARE IN SUB-DIAGONAL BLOCKS.  IF THERE IS
C     ONLY ONE DIAGONAL BLOCK THEN LENOFF(1) MAY BE SET TO -1, IN
C     WHICH CASE THE OTHER ENTRIES OF LENOFF ARE NEVER ACCESSED. IT IS
C     NOT ALTERED BY MA30C/CD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2 WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30C/CD.
C IP,IQ ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30C/CD.
C X IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N. IT MUST BE SET BY
C     THE USER TO THE VALUES OF THE RIGHT HAND SIDE VECTOR B FOR THE
C     EQUATIONS BEING SOLVED.  ON EXIT FROM MA30C/CD IT WILL BE EQUAL
C     TO THE SOLUTION X REQUIRED.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30C/CD.
C MTYPE IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER. IF
C     MTYPE=1, THEN THE SOLUTION TO THE SYSTEM AX=B IS RETURNED; ANY
C     OTHER VALUE FOR MTYPE WILL RETURN THE SOLUTION TO THE SYSTEM A
C     TRANSPOSE X=B. IT IS NOT ALTERED BY MA30C/CD.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Scalar Arguments ..
	INTEGER LICN,MTYPE,N
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN),W(N),X(N)
	INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),LENOFF(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION WI,WII,ZERO
	INTEGER I,IB,IBACK,IBLEND,IBLOCK,IEND,IFIRST,II,III,ILAST,J,J1,J2,
     +        J3,JJ,JPIV,JPIVP1,K,LJ1,LJ2,LT,LTEND,NUMBLK
	LOGICAL NEG,NOBLOC
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC DABS,DMAX1,IABS
C     ..
C     .. Common blocks ..
	COMMON /MA30HD/RESID
	DOUBLE PRECISION RESID
C     ..
C     .. Data statements ..
	DATA  ZERO/0.0D0/
C     ..
C
C THE FINAL VALUE OF RESID IS THE MAXIMUM RESIDUAL FOR AN INCONSISTENT
C     SET OF EQUATIONS.
	RESID  = ZERO
C NOBLOC IS .TRUE. IF SUBROUTINE BLOCK HAS BEEN USED PREVIOUSLY AND
C     IS .FALSE. OTHERWISE.  THE VALUE .FALSE. MEANS THAT LENOFF
C     WILL NOT BE SUBSEQUENTLY ACCESSED.
	NOBLOC = LENOFF(1) .LT. 0
	IF (MTYPE.NE.1) GO TO 140
C
C WE NOW SOLVE   A * X = B.
C NEG IS USED TO INDICATE WHEN THE LAST ROW IN A BLOCK HAS BEEN
C     REACHED.  IT IS THEN SET TO TRUE WHEREAFTER BACKSUBSTITUTION IS
C     PERFORMED ON THE BLOCK.
	NEG    = .FALSE.
C IP(N) IS NEGATED SO THAT THE LAST ROW OF THE LAST BLOCK CAN BE
C     RECOGNISED.  IT IS RESET TO ITS POSITIVE VALUE ON EXIT.
	IP(N)  = -IP(N)
C PREORDER VECTOR ... W(I) = X(IP(I))
	DO 10 II = 1,N
	   I      = IP(II)
	   I      = IABS(I)           
	   W(II)  = X(I)
   10 CONTINUE
C LT HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW OF THE
C     OFF-DIAGONAL BLOCKS.
	LT     = 1
C IFIRST HOLDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
	IFIRST = 1
C IBLOCK HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW
C     OF THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS.
	IBLOCK = IDISP(1)
C IF I IS NOT THE LAST ROW OF A BLOCK, THEN A PASS THROUGH THIS LOOP
C     ADDS THE INNER PRODUCT OF ROW I OF THE OFF-DIAGONAL BLOCKS AND W
C     TO W AND PERFORMS FORWARD ELIMINATION USING ROW I OF THE LU
C     DECOMPOSITION.   IF I IS THE LAST ROW OF A BLOCK THEN, AFTER
C     PERFORMING THESE AFOREMENTIONED OPERATIONS, BACKSUBSTITUTION IS
C     PERFORMED USING THE ROWS OF THE BLOCK.
	DO 120 I = 1,N
	   WI     = W(I)
	   IF (NOBLOC) GO TO 30
	   IF (LENOFF(I).EQ.0) GO TO 30
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
C LTEND IS THE END OF ROW I IN THE OFF-DIAGONAL BLOCKS.
	   LTEND  = LT + LENOFF(I) - 1
	   DO 20 JJ = LT,LTEND
		J      = ICN(JJ)
		WI     = WI - A(JJ)*W(J)
   20    CONTINUE
C LT IS SET THE BEGINNING OF THE NEXT OFF-DIAGONAL ROW.
	   LT     = LTEND + 1
C SET NEG TO .TRUE. IF WE ARE ON THE LAST ROW OF THE BLOCK.
   30    IF (IP(I).LT.0) NEG    = .TRUE.
	   IF (LENRL(I).EQ.0) GO TO 50
C FORWARD ELIMINATION PHASE.
C IEND IS THE END OF THE L PART OF ROW I IN THE LU DECOMPOSITION.
	   IEND   = IBLOCK + LENRL(I) - 1
	   DO 40 JJ = IBLOCK,IEND
		J      = ICN(JJ)
		WI     = WI + A(JJ)*W(J)
   40    CONTINUE
C IBLOCK IS ADJUSTED TO POINT TO THE START OF THE NEXT ROW.
   50    IBLOCK = IBLOCK + LENR(I)
	   W(I)   = WI
	   IF (.NOT.NEG) GO TO 120
C BACK SUBSTITUTION PHASE.
C J1 IS POSITION IN A/ICN AFTER END OF BLOCK BEGINNING IN ROW IFIRST
C     AND ENDING IN ROW I.
	   J1     = IBLOCK
C ARE THERE ANY SINGULARITIES IN THIS BLOCK?  IF NOT, CONTINUE WITH
C     THE BACKSUBSTITUTION.
	   IB     = I
	   IF (IQ(I).GT.0) GO TO 70
	   DO 60 III = IFIRST,I
		IB     = I - III + IFIRST
		IF (IQ(IB).GT.0) GO TO 70
		J1     = J1 - LENR(IB)
		RESID  = DMAX1(RESID,DABS(W(IB)))
		W(IB)  = ZERO
   60    CONTINUE
C ENTIRE BLOCK IS SINGULAR.
	   GO TO 110
C EACH PASS THROUGH THIS LOOP PERFORMS THE BACK-SUBSTITUTION
C     OPERATIONS FOR A SINGLE ROW, STARTING AT THE END OF THE BLOCK AND
C     WORKING THROUGH IT IN REVERSE ORDER.
   70    DO 100 III = IFIRST,IB
		II     = IB - III + IFIRST
C J2 IS END OF ROW II.
		J2     = J1 - 1
C J1 IS BEGINNING OF ROW II.
		J1     = J1 - LENR(II)
C JPIV IS THE POSITION OF THE PIVOT IN ROW II.
		JPIV   = J1 + LENRL(II)
		JPIVP1 = JPIV + 1
C JUMP IF ROW  II OF U HAS NO NON-ZEROS.
		IF (J2.LT.JPIVP1) GO TO 90
		WII    = W(II)
		DO 80 JJ = JPIVP1,J2
		   J      = ICN(JJ)
		   WII    = WII - A(JJ)*W(J)
   80       CONTINUE
		W(II)  = WII
   90       W(II)  = W(II)/A(JPIV)
  100    CONTINUE
  110    IFIRST = I + 1
	   NEG    = .FALSE.
  120 CONTINUE
C
C REORDER SOLUTION VECTOR ... X(I) = W(IQINVERSE(I))
	DO 130 II = 1,N
	   I      = IQ(II)
	   I      = IABS(I)
	   X(I)   = W(II)
  130 CONTINUE
	IP(N)  = -IP(N)
	GO TO 320
C
C
C WE NOW SOLVE   ATRANSPOSE * X = B.
C PREORDER VECTOR ... W(I)=X(IQ(I))
  140 DO 150 II = 1,N
	   I      = IQ(II)
	   I      = IABS(I)
	   W(II)  = X(I)
  150 CONTINUE
C LJ1 POINTS TO THE BEGINNING THE CURRENT ROW IN THE OFF-DIAGONAL
C     BLOCKS.
	LJ1    = IDISP(1)
C IBLOCK IS INITIALIZED TO POINT TO THE BEGINNING OF THE BLOCK AFTER
C     THE LAST ONE !
	IBLOCK = IDISP(2) + 1
C ILAST IS THE LAST ROW IN THE CURRENT BLOCK.
	ILAST  = N
C IBLEND POINTS TO THE POSITION AFTER THE LAST NON-ZERO IN THE
C     CURRENT BLOCK.
	IBLEND = IBLOCK
C EACH PASS THROUGH THIS LOOP OPERATES WITH ONE DIAGONAL BLOCK AND
C     THE OFF-DIAGONAL PART OF THE MATRIX CORRESPONDING TO THE ROWS
C     OF THIS BLOCK.  THE BLOCKS ARE TAKEN IN REVERSE ORDER AND THE
C     NUMBER OF TIMES THE LOOP IS ENTERED IS MIN(N,NO. BLOCKS+1).
	DO 290 NUMBLK = 1,N
	   IF (ILAST.EQ.0) GO TO 300
	   IBLOCK = IBLOCK - LENR(ILAST)
C THIS LOOP FINDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK..
C     IT IS FIRST AND IBLOCK IS SET TO THE POSITION OF THE BEGINNING
C     OF THIS FIRST ROW.
	   DO 160 K = 1,N
		II     = ILAST - K
		IF (II.EQ.0) GO TO 170
		IF (IP(II).LT.0) GO TO 170
		IBLOCK = IBLOCK - LENR(II)
  160    CONTINUE
  170    IFIRST = II + 1
C J1 POINTS TO THE POSITION OF THE BEGINNING OF ROW I (LT PART) OR PIVOT
	   J1     = IBLOCK
C FORWARD ELIMINATION.
C EACH PASS THROUGH THIS LOOP PERFORMS THE OPERATIONS FOR ONE ROW OF THE
C     BLOCK.  IF THE CORRESPONDING ENTRY OF W IS ZERO THEN THE
C     OPERATIONS CAN BE AVOIDED.
	   DO 210 I = IFIRST,ILAST
		IF (W(I).EQ.ZERO) GO TO 200
C JUMP IF ROW I SINGULAR.
		IF (IQ(I).LT.0) GO TO 220
C J2 FIRST POINTS TO THE PIVOT IN ROW I AND THEN IS MADE TO POINT TO THE
C     FIRST NON-ZERO IN THE U TRANSPOSE PART OF THE ROW.
		J2     = J1 + LENRL(I)
		WI     = W(I)/A(J2)
		IF (LENR(I)-LENRL(I).EQ.1) GO TO 190
		J2     = J2 + 1
C J3 POINTS TO THE END OF ROW I.
		J3     = J1 + LENR(I) - 1
		DO 180 JJ = J2,J3
		   J      = ICN(JJ)
		   W(J)   = W(J) - A(JJ)*WI
  180       CONTINUE
  190       W(I)   = WI
  200       J1     = J1 + LENR(I)
  210    CONTINUE
	   GO TO 240
C DEALS WITH REST OF BLOCK WHICH IS SINGULAR.
  220    DO 230 II = I,ILAST
		RESID  = DMAX1(RESID,DABS(W(II)))
		W(II)  = ZERO
  230    CONTINUE
C BACK SUBSTITUTION.
C THIS LOOP DOES THE BACK SUBSTITUTION ON THE ROWS OF THE BLOCK IN
C     THE REVERSE ORDER DOING IT SIMULTANEOUSLY ON THE L TRANSPOSE PART
C     OF THE DIAGONAL BLOCKS AND THE OFF-DIAGONAL BLOCKS.
  240    J1     = IBLEND
	   DO 280 IBACK = IFIRST,ILAST
		I      = ILAST - IBACK + IFIRST
C J1 POINTS TO THE BEGINNING OF ROW I.
		J1     = J1 - LENR(I)
		IF (LENRL(I).EQ.0) GO TO 260
C J2 POINTS TO THE END OF THE L TRANSPOSE PART OF ROW I.
		J2     = J1 + LENRL(I) - 1
		DO 250 JJ = J1,J2
		   J      = ICN(JJ)
		   W(J)   = W(J) + A(JJ)*W(I)
  250       CONTINUE
  260       IF (NOBLOC) GO TO 280
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
		IF (LENOFF(I).EQ.0) GO TO 280
C LJ2 POINTS TO THE END OF ROW I OF THE OFF-DIAGONAL BLOCKS.
		LJ2    = LJ1 - 1
C LJ1 POINTS TO THE BEGINNING OF ROW I OF THE OFF-DIAGONAL BLOCKS.
		LJ1    = LJ1 - LENOFF(I)
		DO 270 JJ = LJ1,LJ2
		   J      = ICN(JJ)
		   W(J)   = W(J) - A(JJ)*W(I)
  270       CONTINUE
  280    CONTINUE
	   IBLEND = J1
	   ILAST  = IFIRST - 1
  290 CONTINUE
C REORDER SOLUTION VECTOR ... X(I)=W(IPINVERSE(I))
  300 DO 310 II = 1,N
	   I      = IP(II)
	   I      = IABS(I)
	   X(I)   = W(II)
  310 CONTINUE
C
  320 RETURN

	END
	SUBROUTINE MA30DD(A,ICN,IPTR,N,IACTIV,ITOP,REALS)
C THIS SUBROUTINE PERFORMS GARBAGE COLLECTION OPERATIONS ON THE
C     ARRAYS A, ICN AND IRN.
C IACTIV IS THE FIRST POSITION IN ARRAYS A/ICN FROM WHICH THE COMPRESS
C     STARTS.  ON EXIT, IACTIV EQUALS THE POSITION OF THE FIRST ENTRY
C     IN THE COMPRESSED PART OF A/ICN
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C
C     .. Scalar Arguments ..
	INTEGER IACTIV,ITOP,N
	LOGICAL REALS
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(ITOP)
	INTEGER ICN(ITOP),IPTR(N)
C     ..
C     .. Local Scalars ..
	INTEGER J,JPOS,K,KL,KN
C     ..
C     .. Common blocks ..
	COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
	INTEGER ICNCP,IRANK,IRNCP,MINICN,MINIRN
C     ..
	IF (REALS) ICNCP  = ICNCP + 1
	IF (.NOT.REALS) IRNCP  = IRNCP + 1
C SET THE FIRST NON-ZERO ENTRY IN EACH ROW TO THE NEGATIVE OF THE
C     ROW/COL NUMBER AND HOLD THIS ROW/COL INDEX IN THE ROW/COL
C     POINTER.  THIS IS SO THAT THE BEGINNING OF EACH ROW/COL CAN
C     BE RECOGNIZED IN THE SUBSEQUENT SCAN.
	DO 10 J = 1,N
	   K      = IPTR(J)
	   IF (K.LT.IACTIV) GO TO 10
	   IPTR(J) = ICN(K)
	   ICN(K) = -J
   10 CONTINUE
	KN     = ITOP + 1
	KL     = ITOP - IACTIV + 1
C GO THROUGH ARRAYS IN REVERSE ORDER COMPRESSING TO THE BACK SO
C     THAT THERE ARE NO ZEROS HELD IN POSITIONS IACTIV TO ITOP IN ICN.
C     RESET FIRST ENTRY OF EACH ROW/COL AND POINTER ARRAY IPTR.
	DO 30 K = 1,KL
	   JPOS   = ITOP - K + 1
	   IF (ICN(JPOS).EQ.0) GO TO 30
	   KN     = KN - 1
	   IF (REALS) A(KN)  = A(JPOS)
	   IF (ICN(JPOS).GE.0) GO TO 20
C FIRST NON-ZERO OF ROW/COL HAS BEEN LOCATED
	   J      = -ICN(JPOS)
	   ICN(JPOS) = IPTR(J)
	   IPTR(J) = KN
   20    ICN(KN) = ICN(JPOS)
   30 CONTINUE
	IACTIV = KN
	RETURN

	END
	BLOCK DATA MA30JD
C ALTHOUGH ALL COMMON BLOCK VARIABLES DO NOT HAVE DEFAULT VALUES,
C     WE COMMENT ON ALL THE COMMON BLOCK VARIABLES HERE.
C
C COMMON BLOCK MA30E/ED HOLDS CONTROL PARAMETERS ....
C     COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3
C THE INTEGER LP IS THE UNIT NUMBER TO WHICH THE ERROR MESSAGES ARE
C     SENT. LP HAS A DEFAULT VALUE OF 6.  THIS DEFAULT VALUE CAN BE
C     RESET BY THE USER, IF DESIRED.  A VALUE OF 0 SUPPRESSES ALL
C     MESSAGES.
C THE LOGICAL VARIABLES ABORT1,ABORT2,ABORT3 ARE USED TO CONTROL THE
C     CONDITIONS UNDER WHICH THE SUBROUTINE WILL TERMINATE.
C IF ABORT1 IS .TRUE. THEN THE SUBROUTINE WILL EXIT  IMMEDIATELY ON
C     DETECTING STRUCTURAL SINGULARITY.
C IF ABORT2 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY ON
C     DETECTING NUMERICAL SINGULARITY.
C IF ABORT3 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY WHEN
C     THE AVAILABLE SPACE IN A/ICN IS FILLED UP BY THE PREVIOUSLY
C     DECOMPOSED, ACTIVE, AND UNDECOMPOSED PARTS OF THE MATRIX.
C THE DEFAULT VALUES FOR ABORT1,ABORT2,ABORT3 ARE SET TO .TRUE.,.TRUE.
C     AND .FALSE. RESPECTIVELY.
C
C THE VARIABLES IN THE COMMON BLOCK MA30F/FD ARE USED TO PROVIDE THE
C     USER WITH INFORMATION ON THE DECOMPOSITION.
C     COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN
C IRNCP AND ICNCP ARE INTEGER VARIABLES USED TO MONITOR THE ADEQUACY
C     OF THE ALLOCATED SPACE IN ARRAYS IRN AND A/ICN RESPECTIVELY, BY
C     TAKING ACCOUNT OF THE NUMBER OF DATA MANAGEMENT COMPRESSES
C     REQUIRED ON THESE ARRAYS. IF IRNCP OR ICNCP IS FAIRLY LARGE (SAY
C     GREATER THAN N/10), IT MAY BE ADVANTAGEOUS TO INCREASE THE SIZE
C     OF THE CORRESPONDING ARRAY(S).  IRNCP AND ICNCP ARE INITIALIZED
C     TO ZERO ON ENTRY TO MA30A/AD AND ARE INCREMENTED EACH TIME THE
C     COMPRESSING ROUTINE MA30D/DD IS ENTERED.
C ICNCP IS THE NUMBER OF COMPRESSES ON A/ICN.
C IRNCP IS THE NUMBER OF COMPRESSES ON IRN.
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN ESTIMATE (ACTUALLY AN
C     UPPER BOUND) OF THE RANK OF THE MATRIX. ON AN EXIT WITH IFLAG
C     EQUAL TO 0, THIS WILL BE EQUAL TO N.
C MINIRN IS AN INTEGER VARIABLE WHICH, AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM LENGTH TO WHICH IRN CAN BE
C     REDUCED WHILE STILL PERMITTING A SUCCESSFUL DECOMPOSITION OF THE
C     SAME MATRIX. IF, HOWEVER, THE USER WERE TO DECREASE THE LENGTH
C     OF IRN TO THAT SIZE, THE NUMBER OF COMPRESSES (IRNCP) MAY BE
C     VERY HIGH AND QUITE COSTLY. IF LIRN IS NOT LARGE ENOUGH TO BEGIN
C     THE DECOMPOSITION ON A DIAGONAL BLOCK, MINIRN WILL BE EQUAL TO
C     THE VALUE REQUIRED TO CONTINUE THE DECOMPOSITION AND IFLAG WILL
C     BE SET TO -3 OR -6. A VALUE OF LIRN SLIGHTLY GREATER THAN THIS
C     (SAY ABOUT N/2) WILL USUALLY PROVIDE ENOUGH SPACE TO COMPLETE
C     THE DECOMPOSITION ON THAT BLOCK. IN THE EVENT OF ANY OTHER
C     FAILURE MINIRN GIVES THE MINIMUM SIZE OF IRN REQUIRED FOR A
C     SUCCESSFUL DECOMPOSITION UP TO THAT POINT.
C MINICN IS AN INTEGER VARIABLE WHICH AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM SIZE OF LICN REQUIRED TO ENABLE
C     A SUCCESSFUL DECOMPOSITION. IN THE EVENT OF FAILURE WITH IFLAG=
C     -5, MINICN WILL, IF ABORT3 IS LEFT SET TO .FALSE., INDICATE THE
C     MINIMUM LENGTH THAT WOULD BE SUFFICIENT TO PREVENT THIS ERROR IN
C     A SUBSEQUENT RUN ON AN IDENTICAL MATRIX. AGAIN THE USER MAY
C     PREFER TO USE A VALUE OF ICN SLIGHTLY GREATER THAN MINICN FOR
C     SUBSEQUENT RUNS TO AVOID TOO MANY CONPRESSES (ICNCP). IN THE
C     EVENT OF FAILURE WITH IFLAG EQUAL TO ANY NEGATIVE VALUE EXCEPT
C     -4, MINICN WILL GIVE THE MINIMUM LENGTH TO WHICH LICN COULD BE
C     REDUCED TO ENABLE A SUCCESSFUL DECOMPOSITION TO THE POINT AT
C     WHICH FAILURE OCCURRED.  NOTICE THAT, ON A SUCCESSFUL ENTRY
C     IDISP(2) GIVES THE AMOUNT OF SPACE IN A/ICN REQUIRED FOR THE
C     DECOMPOSITION WHILE MINICN WILL USUALLY BE SLIGHTLY GREATER
C     BECAUSE OF THE NEED FOR "ELBOW ROOM".  IF THE USER IS VERY
C     UNSURE HOW LARGE TO MAKE LICN, THE VARIABLE MINICN CAN BE USED
C     TO PROVIDE THAT INFORMATION. A PRELIMINARY RUN SHOULD BE
C     PERFORMED WITH ABORT3 LEFT SET TO .FALSE. AND LICN ABOUT 3/2
C     TIMES AS BIG AS THE NUMBER OF NON-ZEROS IN THE ORIGINAL MATRIX.
C     UNLESS THE INITIAL PROBLEM IS VERY SPARSE (WHEN THE RUN WILL BE
C     SUCCESSFUL) OR FILLS IN EXTREMELY BADLY (GIVING AN ERROR RETURN
C     WITH IFLAG EQUAL TO -4), AN ERROR RETURN WITH IFLAG EQUAL TO -5
C     SHOULD RESULT AND MINICN WILL GIVE THE AMOUNT OF SPACE REQUIRED
C     FOR A SUCCESSFUL DECOMPOSITION.
C
C COMMON BLOCK MA30G/GD IS USED BY THE MA30B/BD ENTRY ONLY.
C     COMMON /MA30GD/ EPS, RMIN
C EPS IS A REAL/DOUBLE PRECISION VARIABLE. IT IS USED TO TEST FOR
C     SMALL PIVOTS. ITS DEFAULT VALUE IS 1.0E-4 (1.0D-4 IN D VERSION).
C     IF THE USER SETS EPS TO ANY VALUE GREATER THAN 1.0, THEN NO
C     CHECK IS MADE ON THE SIZE OF THE PIVOTS. ALTHOUGH THE ABSENCE OF
C     SUCH A CHECK WOULD FAIL TO WARN THE USER OF BAD INSTABILITY, ITS
C     ABSENCE WILL ENABLE MA30B/BD TO RUN SLIGHTLY FASTER. AN  A
C     POSTERIORI  CHECK ON THE STABILITY OF THE FACTORIZATION CAN BE
C     OBTAINED FROM MC24A/AD.
C RMIN IS A REAL/DOUBLE PRECISION VARIABLE WHICH GIVES THE USER SOME
C     INFORMATION ABOUT THE STABILITY OF THE DECOMPOSITION.  AT EACH
C     STAGE OF THE LU DECOMPOSITION THE MAGNITUDE OF THE PIVOT APIV
C     IS COMPARED WITH THE LARGEST OFF-DIAGONAL ENTRY CURRENTLY IN ITS
C     ROW (ROW OF U), ROWMAX SAY. IF THE RATIO
C                       MIN (APIV/ROWMAX)
C     WHERE THE MINIMUM IS TAKEN OVER ALL THE ROWS, IS LESS THAN EPS
C     THEN RMIN IS SET TO THIS MINIMUM VALUE AND IFLAG IS RETURNED
C     WITH THE VALUE +I WHERE I IS THE ROW IN WHICH THIS MINIMUM
C     OCCURS.  IF THE USER SETS EPS GREATER THAN ONE, THEN THIS TEST
C     IS NOT PERFORMED. IN THIS CASE, AND WHEN THERE ARE NO SMALL
C     PIVOTS RMIN WILL BE SET EQUAL TO EPS.
C
C COMMON BLOCK MA30H/HD IS USED BY MA30C/CD ONLY.
C     COMMON /MA30HD/ RESID
C RESID IS A REAL/DOUBLE PRECISION VARIABLE. IN THE CASE OF SINGULAR
C     OR RECTANGULAR MATRICES ITS FINAL VALUE WILL BE EQUAL TO THE
C     MAXIMUM RESIDUAL FOR THE UNSATISFIED EQUATIONS; OTHERWISE ITS
C     VALUE WILL BE SET TO ZERO.
C
C COMMON  BLOCK MA30I/ID CONTROLS THE USE OF DROP TOLERANCES, THE
C     MODIFIED PIVOT OPTION AND THE THE CALCULATION OF THE LARGEST
C     ENTRY IN THE FACTORIZATION PROCESS. THIS COMMON BLOCK WAS ADDED
C     TO THE MA30 PACKAGE IN FEBRUARY, 1983.
C     COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG
C TOL IS A REAL/DOUBLE PRECISION VARIABLE.  IF IT IS SET TO A POSITIVE
C     VALUE, THEN MA30A/AD WILL DROP FROM THE FACTORS ANY NON-ZERO
C     WHOSE MODULUS IS LESS THAN TOL.  THE FACTORIZATION WILL THEN
C     REQUIRE LESS STORAGE BUT WILL BE INACCURATE.  AFTER A RUN OF
C     MA30A/AD WHERE ENTRIES HAVE BEEN DROPPED, MA30B/BD  SHOULD NOT
C     BE CALLED.  THE DEFAULT VALUE FOR TOL IS 0.0.
C BIG IS A REAL/DOUBLE PRECISION VARIABLE.  IF LBIG HAS BEEN SET TO
C     .TRUE., BIG WILL BE SET TO THE LARGEST ENTRY ENCOUNTERED DURING
C     THE FACTORIZATION.
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT
C     FROM MA30A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED
C     FROM THE DATA STRUCTURE.
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN
C     OR EQUAL TO N, THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY
C     MA30A/AD.  THIS MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION
C     TIME FOR MA30A/AD. IF NSRCH IS LESS THAN OR EQUAL TO N, THE
C     WORKSPACE ARRAYS LASTC AND NEXTC ARE NOT REFERENCED BY MA30A/AD.
C     THE DEFAULT VALUE FOR NSRCH IS 32768.
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF
C     THE LARGEST ENTRY ENCOUNTERED IN THE FACTORIZATION BY MA30A/AD
C     IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL MARGINALLY
C     INCREASE THE FACTORIZATION TIME FOR MA30A/AD AND WILL INCREASE
C     THAT FOR MA30B/BD BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS
C     .FALSE.
C
C     .. Common blocks ..
	COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
	COMMON /MA30GD/EPS,RMIN
	COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
	DOUBLE PRECISION BIG,EPS,RMIN,TOL
	INTEGER LP,NDROP,NSRCH
	LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Data statements ..
	DATA  EPS/1.0D-4/,TOL/0.0D0/,BIG/0.0D0/
	DATA  LP/6/,NSRCH/32768/
	DATA  LBIG/.FALSE./
	DATA  ABORT1/.TRUE./,ABORT2/.TRUE./,ABORT3/.FALSE./
C     ..
	END
C######ALIAS   MC13D
C######DATE   09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
	SUBROUTINE MC13D(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW)
C     .. Scalar Arguments ..
	INTEGER LICN,N,NUM
C     ..
C     .. Array Arguments ..
	INTEGER IB(N),ICN(LICN),IOR(N),IP(N),IW(N,3),LENR(N)
C     ..
C     .. External Subroutines ..
	EXTERNAL MC13E
C     ..
	CALL MC13E(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW(1,1),IW(1,2),IW(1,3))
	RETURN

	END
	SUBROUTINE MC13E(N,ICN,LICN,IP,LENR,ARP,IB,NUM,LOWL,NUMB,PREV)
C
C ARP(I) IS ONE LESS THAN THE NUMBER OF UNSEARCHED EDGES LEAVING
C     NODE I.  AT THE END OF THE ALGORITHM IT IS SET TO A
C     PERMUTATION WHICH PUTS THE MATRIX IN BLOCK LOWER
C     TRIANGULAR FORM.
C IB(I) IS THE POSITION IN THE ORDERING OF THE START OF THE ITH
C     BLOCK.  IB(N+1-I) HOLDS THE NODE NUMBER OF THE ITH NODE
C     ON THE STACK.
C LOWL(I) IS THE SMALLEST STACK POSITION OF ANY NODE TO WHICH A PATH
C     FROM NODE I HAS BEEN FOUND.  IT IS SET TO N+1 WHEN NODE I
C     IS REMOVED FROM THE STACK.
C NUMB(I) IS THE POSITION OF NODE I IN THE STACK IF IT IS ON
C     IT, IS THE PERMUTED ORDER OF NODE I FOR THOSE NODES
C     WHOSE FINAL POSITION HAS BEEN FOUND AND IS OTHERWISE ZERO.
C PREV(I) IS THE NODE AT THE END OF THE PATH WHEN NODE I WAS
C     PLACED ON THE STACK.
C
C
C   ICNT IS THE NUMBER OF NODES WHOSE POSITIONS IN FINAL ORDERING HAVE
C     BEEN FOUND.
C     .. Scalar Arguments ..
	INTEGER LICN,N,NUM
C     ..
C     .. Array Arguments ..
	INTEGER ARP(N),IB(N),ICN(LICN),IP(N),LENR(N),LOWL(N),NUMB(N),
     +        PREV(N)
C     ..
C     .. Local Scalars ..
	INTEGER DUMMY,I,I1,I2,ICNT,II,ISN,IST,IST1,IV,IW,J,K,LCNT,NNM1,STP
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC MIN0
C     ..
	ICNT   = 0
C NUM IS THE NUMBER OF BLOCKS THAT HAVE BEEN FOUND.
	NUM    = 0
	NNM1   = N + N - 1
C
C INITIALIZATION OF ARRAYS.
	DO 20 J = 1,N
	   NUMB(J) = 0
	   ARP(J) = LENR(J) - 1
   20 CONTINUE
C
C
	DO 120 ISN = 1,N
C LOOK FOR A STARTING NODE
	   IF (NUMB(ISN).NE.0) GO TO 120
	   IV     = ISN
C IST IS THE NUMBER OF NODES ON THE STACK ... IT IS THE STACK POINTER.
	   IST    = 1
C PUT NODE IV AT BEGINNING OF STACK.
	   LOWL(IV) = 1
	   NUMB(IV) = 1
	   IB(N)  = IV
C
C THE BODY OF THIS LOOP PUTS A NEW NODE ON THE STACK OR BACKTRACKS.
	   DO 110 DUMMY = 1,NNM1
		I1     = ARP(IV)
C HAVE ALL EDGES LEAVING NODE IV BEEN SEARCHED.
		IF (I1.LT.0) GO TO 60
		I2     = IP(IV) + LENR(IV) - 1
		I1     = I2 - I1
C
C LOOK AT EDGES LEAVING NODE IV UNTIL ONE ENTERS A NEW NODE OR
C     ALL EDGES ARE EXHAUSTED.
		DO 50 II = I1,I2
		   IW     = ICN(II)
C HAS NODE IW BEEN ON STACK ALREADY.
		   IF (NUMB(IW).EQ.0) GO TO 100
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
   50       LOWL(IV) = MIN0(LOWL(IV),LOWL(IW))
C
C THERE ARE NO MORE EDGES LEAVING NODE IV.
		ARP(IV) = -1
C IS NODE IV THE ROOT OF A BLOCK.
   60       IF (LOWL(IV).LT.NUMB(IV)) GO TO 90
C
C ORDER NODES IN A BLOCK.
		NUM    = NUM + 1
		IST1   = N + 1 - IST
		LCNT   = ICNT + 1
C PEEL BLOCK OFF THE TOP OF THE STACK STARTING AT THE TOP AND
C     WORKING DOWN TO THE ROOT OF THE BLOCK.
		DO 70 STP = IST1,N
		   IW     = IB(STP)
		   LOWL(IW) = N + 1
		   ICNT   = ICNT + 1
		   NUMB(IW) = ICNT
		   IF (IW.EQ.IV) GO TO 80
   70       CONTINUE
   80       IST    = N - STP
		IB(NUM) = LCNT
C ARE THERE ANY NODES LEFT ON THE STACK.
		IF (IST.NE.0) GO TO 90
C HAVE ALL THE NODES BEEN ORDERED.
		IF (ICNT.LT.N) GO TO 120
		GO TO 130
C
C BACKTRACK TO PREVIOUS NODE ON PATH.
   90       IW     = IV
		IV     = PREV(IV)
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
		LOWL(IV) = MIN0(LOWL(IV),LOWL(IW))
		GO TO 110
C
C PUT NEW NODE ON THE STACK.
  100       ARP(IV) = I2 - II - 1
		PREV(IW) = IV
		IV     = IW
		IST    = IST + 1
		LOWL(IV) = IST
		NUMB(IV) = IST
		K      = N + 1 - IST
		IB(K)  = IV
  110    CONTINUE
C
  120 CONTINUE
C
C
C PUT PERMUTATION IN THE REQUIRED FORM.
  130 DO 140 I = 1,N
	   II     = NUMB(I)
  140 ARP(II) = I
	RETURN

	END
C######ALIAS   MC19AD
C######DATE   09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
	SUBROUTINE MC19AD(N,NA,A,IRN,ICN,R,C,W)
	INTEGER   N,NA,IRN(*),ICN(*)
	DOUBLE PRECISION A(*)
C      IRN(K) GIVES ROW NUMBER OF ELEMENT IN A(K).
C      ICN(K) GIVES COL NUMBER OF ELEMENT IN A(K).
	REAL R(N),C(N),W(N,5)
C      R(I) IS USED TO RETURN LOG(SCALING FACTOR FOR ROW I).
C      C(J) IS USED TO RETURN LOG(SCALING FACTOR FOR COL J).
C      W(I,1),  W(I,2) HOLD ROW, COL NON-ZERO COUNTS.
C      W(J,3) HOLDS - COL J LOG DURING EXECUTION.
C      W(J,4) HOLDS 2-ITERATION CHANGE IN W(J,3).
C      W(I,5) IS USED TO SAVE AVERAGE ELEMENT LOG FOR ROW I.
	INTEGER LP,IFAIL
	COMMON/MC19BD/LP,IFAIL
	INTEGER I,I1,I2,ITER,J,K,L,MAXIT
        REAL E,E1,EM,Q,Q1,QM,S,S1,SM,SMIN,U,V      
	EXTERNAL MC19CD
	INTRINSIC ALOG,DABS,FLOAT
	DATA MAXIT/100/,SMIN/0.1/
C MAXIT IS THE MAXIMAL PERMITTED NUMBER OF ITERATIONS
C     SMIN IS USED IN A CONVERGENCE TEST ON (RESIDUAL NORM)**2
C
C CHECK SCALAR DATA
	IFAIL=1
	IF(N.LT.1)GO TO 230
	IFAIL=2
	IFAIL=0
C
C     INITIALISE FOR ACCUMULATION OF SUMS AND PRODUCTS
	DO 5 I=1,N
	C(I)=0.
	R(I)=0.
5     CONTINUE
	DO 10 L=1,4
	DO 10 I=1,N
	W(I,L)=0.
10    CONTINUE
	IF(NA.LE.0)GO TO 250
	DO 30 K=1,NA
	U=DABS(A(K))
	IF(U.EQ.0.)GO TO 30
	U=ALOG(U)
	I1=IRN(K)
	I2=ICN(K)
	IF(I1.GE.1 .AND. I1.LE.N .AND. I2.GE.1 .AND. I2.LE.N)GO TO 20
	IF(LP.GT.0)WRITE(LP,15)K,I1,I2
15    FORMAT(20H MC19 ERROR. ELEMENT,I5,10H IS IN ROW,I5,
     1 8H AND COL,I5)
	IFAIL=3
	GO TO 30
C     COUNT ROW/COL NON-ZEROS, AND COMPUTE RHS VECTORS.
20    W(I1,1)=W(I1,1)+1.
	W(I2,2)=W(I2,2)+1.
	R(I1)=R(I1)+U
	W(I2,3)=W(I2,3)+U
   30 CONTINUE
	IF(IFAIL.EQ.3)GO TO 230
C
C     DIVIDE RHS BY DIAG MATRICES
	DO 70 I=1,N
	IF(W(I,1).EQ.0.)W(I,1)=1.
	R(I)=R(I)/W(I,1)
C     SAVE R(I) FOR USE AT END.
	W(I,5)=R(I)
	IF(W(I,2).EQ.0.)W(I,2)=1.
	W(I,3)=W(I,3)/W(I,2)
70    CONTINUE
	SM=SMIN*FLOAT(NA)
C     SWEEP TO COMPUTE INITIAL RESIDUAL VECTOR
	DO 80 K=1,NA
	 IF(A(K).EQ.0.0 )GO TO 80
	I=IRN(K)
	J=ICN(K)
	R(I)=R(I)-W(J,3)/W(I,1)
   80 CONTINUE
C
C     INITIALISE ITERATION
	E=0.
	Q=1.
	S=0.
	DO 100 I=1,N
	S=S+W(I,1)*R(I)**2
100   CONTINUE
	IF(S.LE.SM)GO TO 186
C
C     ITERATION LOOP
	DO 185 ITER=1,MAXIT
C    SWEEP THROUGH MATRIX TO UPDATE RESIDUAL VECTOR
	DO 130 K=1,NA
	IF(A(K).EQ.0.)GO TO 130
	I=ICN(K)
	J=IRN(K)
	C(I)=C(I)+R(J)
  130 CONTINUE
	S1=S
	S=0.
	DO 140 I=1,N
	V=-C(I)/Q
	C(I)=V/W(I,2)
	S=S+V*C(I)
140   CONTINUE
	E1=E
	E=Q*S/S1
	Q=1.-E
	IF(S.LE.SM)E=0.
C     UPDATE RESIDUAL.
	DO 150 I=1,N
	R(I)=R(I)*E*W(I,1)
150   CONTINUE
	IF(S.LE.SM)GO TO 190
	EM=E*E1
C    SWEEP THROUGH MATRIX TO UPDATE RESIDUAL VECTOR
	DO 152 K=1,NA
	IF(A(K).EQ.0.0 ) GO TO 152
	I=IRN(K)
	J=ICN(K)
	R(I)=R(I)+C(J)
152   CONTINUE
	S1=S
	S=0.
	DO 155 I=1,N
	V=-R(I)/Q
	R(I)=V/W(I,1)
	S=S+V*R(I)
155   CONTINUE
	E1=E
	E=Q*S/S1
	Q1=Q
	Q=1.-E
C     SPECIAL FIXUP FOR LAST ITERATION.
	IF(S.LE.SM)Q=1.
C     UPDATE COL. SCALING POWERS
	QM=Q*Q1
	DO 160 I=1,N
	W(I,4)=(EM*W(I,4)+C(I))/QM
	W(I,3)=W(I,3)+W(I,4)
160   CONTINUE
	IF(S.LE.SM)GO TO 186
C     UPDATE RESIDUAL.
	DO 180 I=1,N
	C(I)=C(I)*E*W(I,2)
180   CONTINUE
185   CONTINUE
186   DO 188 I=1,N
	R(I)=R(I)*W(I,1)
188   CONTINUE
C
C      SWEEP THROUGH MATRIX TO PREPARE TO GET ROW SCALING POWERS
190   DO 200 K=1,NA
	IF(A(K).EQ.0.0 )GO TO 200
	I=IRN(K)
	J=ICN(K)
	R(I)=R(I)+W(J,3)
  200 CONTINUE
C
C      FINAL CONVERSION TO OUTPUT VALUES.
	DO 220 I=1,N
	R(I)=R(I)/W(I,1)-W(I,5)
	C(I)=-W(I,3)
220   CONTINUE
	GO TO 250
230   IF(LP.GT.0)WRITE(LP,240)IFAIL
240   FORMAT(//13H ERROR RETURN,I2,10H FROM MC19)
250   RETURN
	END
	BLOCK DATA MC19CD
	INTEGER LP,IFAIL
	COMMON/MC19BD/LP,IFAIL
	DATA LP/6/
	END
C######DATE  09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC20AD MC20BD
	SUBROUTINE MC20AD(NC,MAXA,A,INUM,JPTR,JNUM,JDISP)
C
C
C     ******************************************************************
C
C     .. Scalar Arguments ..
	INTEGER JDISP,MAXA,NC
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(*)
	INTEGER INUM(*),JNUM(*),JPTR(*)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION ACE,ACEP
	INTEGER I,ICE,ICEP,J,JA,JB,JCE,JCEP,K,KR,LOC,NULL
C     ..
	NULL   = -JDISP
C**      CLEAR JPTR
	DO 60 J = 1,NC
   60 JPTR(J) = 0
C**      COUNT THE NUMBER OF ELEMENTS IN EACH COLUMN.
	DO 120 K = 1,MAXA
	   J      = JNUM(K) + JDISP
	   JPTR(J) = JPTR(J) + 1
  120 CONTINUE
C**      SET THE JPTR ARRAY
	K      = 1
	DO 150 J = 1,NC
	   KR     = K + JPTR(J)
	   JPTR(J) = K
  150 K      = KR
C
C**      REORDER THE ELEMENTS INTO COLUMN ORDER.  THE ALGORITHM IS AN
C        IN-PLACE SORT AND IS OF ORDER MAXA.
	DO 230 I = 1,MAXA
C        ESTABLISH THE CURRENT ENTRY.
	   JCE    = JNUM(I) + JDISP
	   IF (JCE.EQ.0) GO TO 230
	   ACE    = A(I)
	   ICE    = INUM(I)
C        CLEAR THE LOCATION VACATED.
	   JNUM(I) = NULL
C        CHAIN FROM CURRENT ENTRY TO STORE ITEMS.
	   DO 200 J = 1,MAXA
C        CURRENT ENTRY NOT IN CORRECT POSITION.  DETERMINE CORRECT
C        POSITION TO STORE ENTRY.
		LOC    = JPTR(JCE)
		JPTR(JCE) = JPTR(JCE) + 1
C        SAVE CONTENTS OF THAT LOCATION.
		ACEP   = A(LOC)
		ICEP   = INUM(LOC)
		JCEP   = JNUM(LOC)
C        STORE CURRENT ENTRY.
		A(LOC) = ACE
		INUM(LOC) = ICE
		JNUM(LOC) = NULL
C        CHECK IF NEXT CURRENT ENTRY NEEDS TO BE PROCESSED.
		IF (JCEP.EQ.NULL) GO TO 230
C        IT DOES.  COPY INTO CURRENT ENTRY.
		ACE    = ACEP
		ICE    = ICEP
  200    JCE    = JCEP + JDISP
C
  230 CONTINUE
C
C**      RESET JPTR VECTOR.
	JA     = 1
	DO 250 J = 1,NC
	   JB     = JPTR(J)
	   JPTR(J) = JA
  250 JA     = JB
	RETURN

	END
	SUBROUTINE MC20BD(NC,MAXA,A,INUM,JPTR)
C
C     ******************************************************************
C
C     .. Scalar Arguments ..
	INTEGER MAXA,NC
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(*)
	INTEGER INUM(*),JPTR(*)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION ACE
	INTEGER ICE,IK,J,JJ,K,KDUMMY,KLO,KMAX,KOR
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC IABS
C     ..
	KMAX   = MAXA
	DO 30 JJ = 1,NC
	   J      = NC + 1 - JJ
	   KLO    = JPTR(J) + 1
	   IF (KLO.GT.KMAX) GO TO 30
	   KOR    = KMAX
	   DO 25 KDUMMY = KLO,KMAX
C ITEMS KOR, KOR+1, .... ,KMAX ARE IN ORDER
		ACE    = A(KOR-1)
		ICE    = INUM(KOR-1)
		DO 10 K = KOR,KMAX
		   IK     = INUM(K)
		   IF (IABS(ICE).LE.IABS(IK)) GO TO 20
		   INUM(K-1) = IK
   10       A(K-1) = A(K)
		K      = KMAX + 1
   20       INUM(K-1) = ICE
		A(K-1) = ACE
   25    KOR    = KOR - 1
C        NEXT COLUMN
   30 KMAX   = KLO - 2
	RETURN

	END
C######ALIAS   MC21A
C######DATE   09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
	SUBROUTINE MC21A(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW)
C     .. Scalar Arguments ..
	INTEGER LICN,N,NUMNZ
C     ..
C     .. Array Arguments ..
	INTEGER ICN(LICN),IP(N),IPERM(N),IW(N,4),LENR(N)
C     ..
C     .. External Subroutines ..
	EXTERNAL MC21B
C     ..
	CALL MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW(1,1),IW(1,2),IW(1,3),
     +           IW(1,4))
	RETURN

	END
	SUBROUTINE MC21B(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,PR,ARP,CV,OUT)
C   PR(I) IS THE PREVIOUS ROW TO I IN THE DEPTH FIRST SEARCH.
C IT IS USED AS A WORK ARRAY IN THE SORTING ALGORITHM.
C   ELEMENTS (IPERM(I),I) I=1, ... N  ARE NON-ZERO AT THE END OF THE
C ALGORITHM UNLESS N ASSIGNMENTS HAVE NOT BEEN MADE.  IN WHICH CASE
C (IPERM(I),I) WILL BE ZERO FOR N-NUMNZ ENTRIES.
C   CV(I) IS THE MOST RECENT ROW EXTENSION AT WHICH COLUMN I
C WAS VISITED.
C   ARP(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED WHEN LOOKING FOR A CHEAP ASSIGNMENT.
C   OUT(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED DURING ONE PASS THROUGH THE MAIN LOOP.
C
C   INITIALIZATION OF ARRAYS.
C     .. Scalar Arguments ..
	INTEGER LICN,N,NUMNZ
C     ..
C     .. Array Arguments ..
	INTEGER ARP(N),CV(N),ICN(LICN),IP(N),IPERM(N),LENR(N),OUT(N),PR(N)
C     ..
C     .. Local Scalars ..
	INTEGER I,II,IN1,IN2,IOUTK,J,J1,JORD,K,KK
C     ..
	DO 10 I = 1,N
	   ARP(I) = LENR(I) - 1
	   CV(I)  = 0
   10 IPERM(I) = 0
	NUMNZ  = 0
C
C
C   MAIN LOOP.
C   EACH PASS ROUND THIS LOOP EITHER RESULTS IN A NEW ASSIGNMENT
C OR GIVES A ROW WITH NO ASSIGNMENT.
	DO 130 JORD = 1,N
	   J      = JORD
	   PR(J)  = -1
	   DO 100 K = 1,JORD
C LOOK FOR A CHEAP ASSIGNMENT
		IN1    = ARP(J)
		IF (IN1.LT.0) GO TO 60
		IN2    = IP(J) + LENR(J) - 1
		IN1    = IN2 - IN1
		DO 50 II = IN1,IN2
		   I      = ICN(II)
		   IF (IPERM(I).EQ.0) GO TO 110
   50       CONTINUE
C   NO CHEAP ASSIGNMENT IN ROW.
		ARP(J) = -1
C   BEGIN LOOKING FOR ASSIGNMENT CHAIN STARTING WITH ROW J.
   60       OUT(J) = LENR(J) - 1
C INNER LOOP.  EXTENDS CHAIN BY ONE OR BACKTRACKS.
		DO 90 KK = 1,JORD
		   IN1    = OUT(J)
		   IF (IN1.LT.0) GO TO 80
		   IN2    = IP(J) + LENR(J) - 1
		   IN1    = IN2 - IN1
C FORWARD SCAN.
		   DO 70 II = IN1,IN2
			I      = ICN(II)
			IF (CV(I).EQ.JORD) GO TO 70
C   COLUMN I HAS NOT YET BEEN ACCESSED DURING THIS PASS.
			J1     = J
			J      = IPERM(I)
			CV(I)  = JORD
			PR(J)  = J1
			OUT(J1) = IN2 - II - 1
			GO TO 100

   70          CONTINUE
C
C   BACKTRACKING STEP.
   80          J      = PR(J)
		   IF (J.EQ.-1) GO TO 130
   90       CONTINUE
C
  100    CONTINUE
C
C   NEW ASSIGNMENT IS MADE.
  110    IPERM(I) = J
	   ARP(J) = IN2 - II - 1
	   NUMNZ  = NUMNZ + 1
	   DO 120 K = 1,JORD
		J      = PR(J)
		IF (J.EQ.-1) GO TO 130
		II     = IP(J) + LENR(J) - OUT(J) - 2
		I      = ICN(II)
		IPERM(I) = J
  120    CONTINUE
C
  130 CONTINUE
C
C   IF MATRIX IS STRUCTURALLY SINGULAR, WE NOW COMPLETE THE
C PERMUTATION IPERM.
	IF (NUMNZ.EQ.N) RETURN
	DO 140 I = 1,N
  140 ARP(I) = 0
	K      = 0
	DO 160 I = 1,N
	   IF (IPERM(I).NE.0) GO TO 150
	   K      = K + 1
	   OUT(K) = I
	   GO TO 160

  150    J      = IPERM(I)
	   ARP(J) = I
  160 CONTINUE
	K      = 0
	DO 170 I = 1,N
	   IF (ARP(I).NE.0) GO TO 170
	   K      = K + 1
	   IOUTK  = OUT(K)
	   IPERM(IOUTK) = I
  170 CONTINUE
	RETURN

	END
C######DATE   09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS   MC22AD
	SUBROUTINE MC22AD(N,ICN,A,NZ,LENROW,IP,IQ,IW,IW1)
C     .. Scalar Arguments ..
	INTEGER N,NZ
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(NZ)
	INTEGER ICN(NZ),IP(N),IQ(N),IW(N,2),IW1(NZ),LENROW(N)
C     ..
C     .. Local Scalars ..
	DOUBLE PRECISION AVAL
	INTEGER I,ICHAIN,IOLD,IPOS,J,J2,JJ,JNUM,JVAL,LENGTH,NEWPOS
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC IABS
C     ..
	IF (NZ.LE.0) GO TO 1000
	IF (N.LE.0) GO TO 1000
C SET START OF ROW I IN IW(I,1) AND LENROW(I) IN IW(I,2)
	IW(1,1) = 1
	IW(1,2) = LENROW(1)
	DO 10 I = 2,N
	   IW(I,1) = IW(I-1,1) + LENROW(I-1)
   10 IW(I,2) = LENROW(I)
C PERMUTE LENROW ACCORDING TO IP.  SET OFF-SETS FOR NEW POSITION
C     OF ROW IOLD IN IW(IOLD,1) AND PUT OLD ROW INDICES IN IW1 IN
C     POSITIONS CORRESPONDING TO THE NEW POSITION OF THIS ROW IN A/ICN.
	JJ     = 1
	DO 20 I = 1,N
	   IOLD   = IP(I)
	   IOLD   = IABS(IOLD)
	   LENGTH = IW(IOLD,2)
	   LENROW(I) = LENGTH
	   IF (LENGTH.EQ.0) GO TO 20
	   IW(IOLD,1) = IW(IOLD,1) - JJ
	   J2     = JJ + LENGTH - 1
	   DO 15 J = JJ,J2
   15    IW1(J) = IOLD
	   JJ     = J2 + 1
   20 CONTINUE
C SET INVERSE PERMUTATION TO IQ IN IW(.,2).
	DO 30 I = 1,N
	   IOLD   = IQ(I)
	   IOLD   = IABS(IOLD)
   30 IW(IOLD,2) = I
C PERMUTE A AND ICN IN PLACE, CHANGING TO NEW COLUMN NUMBERS.
C
C ***   MAIN LOOP   ***
C EACH PASS THROUGH THIS LOOP PLACES A CLOSED CHAIN OF COLUMN INDICES
C     IN THEIR NEW (AND FINAL) POSITIONS ... THIS IS RECORDED BY
C     SETTING THE IW1 ENTRY TO ZERO SO THAT ANY WHICH ARE SUBSEQUENTLY
C     ENCOUNTERED DURING THIS MAJOR SCAN CAN BE BYPASSED.
	DO 200 I = 1,NZ
	   IOLD   = IW1(I)
	   IF (IOLD.EQ.0) GO TO 200
	   IPOS   = I
	   JVAL   = ICN(I)
C IF ROW IOLD IS IN SAME POSITIONS AFTER PERMUTATION GO TO 150.
	   IF (IW(IOLD,1).EQ.0) GO TO 150
	   AVAL   = A(I)
C **  CHAIN LOOP  **
C EACH PASS THROUGH THIS LOOP PLACES ONE (PERMUTED) COLUMN INDEX
C     IN ITS FINAL POSITION  .. VIZ. IPOS.
	   DO 100 ICHAIN = 1,NZ
C NEWPOS IS THE ORIGINAL POSITION IN A/ICN OF THE ELEMENT TO BE PLACED
C IN POSITION IPOS.  IT IS ALSO THE POSITION OF THE NEXT ELEMENT IN
C     THE CHAIN.
		NEWPOS = IPOS + IW(IOLD,1)
C IS CHAIN COMPLETE ?
		IF (NEWPOS.EQ.I) GO TO 130
		A(IPOS) = A(NEWPOS)
		JNUM   = ICN(NEWPOS)
		ICN(IPOS) = IW(JNUM,2)
		IPOS   = NEWPOS
		IOLD   = IW1(IPOS)
		IW1(IPOS) = 0
C **  END OF CHAIN LOOP  **
  100    CONTINUE
  130    A(IPOS) = AVAL
  150    ICN(IPOS) = IW(JVAL,2)
C ***   END OF MAIN LOOP   ***
  200 CONTINUE
C
 1000 RETURN

	END
C######DATE   09 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC23AD
C###### CALLS   MC13    MC21
	SUBROUTINE MC23AD(N,ICN,A,LICN,LENR,IDISP,IP,IQ,LENOFF,IW,IW1)
C INPUT ... N,ICN .. A,ICN,LENR ....
C
C SET UP POINTERS IW(.,1) TO THE BEGINNING OF THE ROWS AND SET LENOFF
C     EQUAL TO LENR.
C     .. Scalar Arguments ..
	INTEGER LICN,N
C     ..
C     .. Array Arguments ..
	DOUBLE PRECISION A(LICN)
	INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),IW(N,5),IW1(N,2),LENOFF(N),
     +        LENR(N)
C     ..
C     .. Local Scalars ..
	INTEGER I,I1,I2,IBEG,IBLOCK,IEND,II,ILEND,INEW,IOLD,IROWB,IROWE,J,
     +        JJ,JNEW,JNPOS,JOLD,K,LENI,NZ
C     ..
C     .. External Subroutines ..
	EXTERNAL MC13D,MC21A,MC23CD
C     ..
C     .. Intrinsic Functions ..
	INTRINSIC MAX0,MIN0
C     ..
C     .. Common blocks ..
	COMMON /MC23BD/LP,NUMNZ,NUM,LARGE,ABORT
	INTEGER LARGE,LP,NUM,NUMNZ
	LOGICAL ABORT
C     ..
	IW1(1,1) = 1
	LENOFF(1) = LENR(1)
	IF (N.EQ.1) GO TO 20
	DO 10 I = 2,N
	   LENOFF(I) = LENR(I)
   10 IW1(I,1) = IW1(I-1,1) + LENR(I-1)
C IDISP(1) POINTS TO THE FIRST POSITION IN A/ICN AFTER THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
   20 IDISP(1) = IW1(N,1) + LENR(N)
C
C FIND ROW PERMUTATION IP TO MAKE DIAGONAL ZERO-FREE.
	CALL MC21A(N,ICN,LICN,IW1,LENR,IP,NUMNZ,IW)
C
C POSSIBLE ERROR RETURN FOR STRUCTURALLY SINGULAR MATRICES.
	IF (NUMNZ.NE.N .AND. ABORT) GO TO 170
C
C IW1(.,2) AND LENR ARE PERMUTATIONS OF IW1(.,1) AND LENR/LENOFF
C     SUITABLE FOR ENTRY
C     TO MC13D SINCE MATRIX WITH THESE ROW POINTER AND LENGTH ARRAYS
C     HAS MAXIMUM NUMBER OF NON-ZEROS ON THE DIAGONAL.
	DO 30 II = 1,N
	   I      = IP(II)
	   IW1(II,2) = IW1(I,1)
   30 LENR(II) = LENOFF(I)
C
C FIND SYMMETRIC PERMUTATION IQ TO BLOCK LOWER TRIANGULAR FORM.
	CALL MC13D(N,ICN,LICN,IW1(1,2),LENR,IQ,IW(1,4),NUM,IW)
C
	IF (NUM.NE.1) GO TO 60
C
C ACTION TAKEN IF MATRIX IS IRREDUCIBLE.
C WHOLE MATRIX IS JUST MOVED TO THE END OF THE STORAGE.
	DO 40 I = 1,N
	   LENR(I) = LENOFF(I)
	   IP(I)  = I
   40 IQ(I)  = I
	LENOFF(1) = -1
C IDISP(1) IS THE FIRST POSITION AFTER THE LAST ELEMENT IN THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
	NZ     = IDISP(1) - 1
	IDISP(1) = 1
C IDISP(2) IS THE POSITION IN A/ICN OF THE FIRST ELEMENT IN THE
C     DIAGONAL BLOCKS.
	IDISP(2) = LICN - NZ + 1
	LARGE  = N
	IF (NZ.EQ.LICN) GO TO 230
	DO 50 K = 1,NZ
	   J      = NZ - K + 1
	   JJ     = LICN - K + 1
	   A(JJ)  = A(J)
   50 ICN(JJ) = ICN(J)
C 230 = RETURN
	GO TO 230
C
C DATA STRUCTURE REORDERED.
C
C FORM COMPOSITE ROW PERMUTATION ... IP(I) = IP(IQ(I)).
   60 DO 70 II = 1,N
	   I      = IQ(II)
   70 IW(II,1) = IP(I)
	DO 80 I = 1,N
   80 IP(I)  = IW(I,1)
C
C RUN THROUGH BLOCKS IN REVERSE ORDER SEPARATING DIAGONAL BLOCKS
C     WHICH ARE MOVED TO THE END OF THE STORAGE.  ELEMENTS IN
C     OFF-DIAGONAL BLOCKS ARE LEFT IN PLACE UNLESS A COMPRESS IS
C     NECESSARY.
C
C IBEG INDICATES THE LOWEST VALUE OF J FOR WHICH ICN(J) HAS BEEN
C     SET TO ZERO WHEN ELEMENT IN POSITION J WAS MOVED TO THE
C     DIAGONAL BLOCK PART OF STORAGE.
	IBEG   = LICN + 1
C IEND IS THE POSITION OF THE FIRST ELEMENT OF THOSE TREATED ROWS
C     WHICH ARE IN DIAGONAL BLOCKS.
	IEND   = LICN + 1
C LARGE IS THE DIMENSION OF THE LARGEST BLOCK ENCOUNTERED SO FAR.
	LARGE  = 0
C
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
	DO 150 K = 1,NUM
	   IBLOCK = NUM - K + 1
C I1 IS FIRST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
C I2 IS LAST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
	   I1     = IW(IBLOCK,4)
	   I2     = N
	   IF (K.NE.1) I2     = IW(IBLOCK+1,4) - 1
	   LARGE  = MAX0(LARGE,I2-I1+1)
C GO THROUGH THE ROWS OF BLOCK IBLOCK IN THE REVERSE ORDER.
	   DO 140 II = I1,I2
		INEW   = I2 - II + I1
C WE NOW DEAL WITH ROW INEW IN PERMUTED FORM (ROW IOLD IN ORIGINAL
C     MATRIX).
		IOLD   = IP(INEW)
C IF THERE IS SPACE TO MOVE UP DIAGONAL BLOCK PORTION OF ROW GO TO 110
		IF (IEND-IDISP(1).GE.LENOFF(IOLD)) GO TO 110
C
C IN-LINE COMPRESS.
C MOVES SEPARATED OFF-DIAGONAL ELEMENTS AND UNTREATED ROWS TO
C     FRONT OF STORAGE.
		JNPOS  = IBEG
		ILEND  = IDISP(1) - 1
		IF (ILEND.LT.IBEG) GO TO 190
		DO 90 J = IBEG,ILEND
		   IF (ICN(J).EQ.0) GO TO 90
		   ICN(JNPOS) = ICN(J)
		   A(JNPOS) = A(J)
		   JNPOS  = JNPOS + 1
   90       CONTINUE
		IDISP(1) = JNPOS
		IF (IEND-JNPOS.LT.LENOFF(IOLD)) GO TO 190
		IBEG   = LICN + 1
C RESET POINTERS TO THE BEGINNING OF THE ROWS.
		DO 100 I = 2,N
  100       IW1(I,1) = IW1(I-1,1) + LENOFF(I-1)
C
C ROW IOLD IS NOW SPLIT INTO DIAG. AND OFF-DIAG. PARTS.
  110       IROWB  = IW1(IOLD,1)
		LENI   = 0
		IROWE  = IROWB + LENOFF(IOLD) - 1
C BACKWARD SCAN OF WHOLE OF ROW IOLD (IN ORIGINAL MATRIX).
		IF (IROWE.LT.IROWB) GO TO 130
		DO 120 JJ = IROWB,IROWE
		   J      = IROWE - JJ + IROWB
		   JOLD   = ICN(J)
C IW(.,2) HOLDS THE INVERSE PERMUTATION TO IQ.
C     ..... IT WAS SET TO THIS IN MC13D.
		   JNEW   = IW(JOLD,2)
C IF (JNEW.LT.I1) THEN ....
C ELEMENT IS IN OFF-DIAGONAL BLOCK AND SO IS LEFT IN SITU.
		   IF (JNEW.LT.I1) GO TO 120
C ELEMENT IS IN DIAGONAL BLOCK AND IS MOVED TO THE END OF THE STORAGE.
		   IEND   = IEND - 1
		   A(IEND) = A(J)
		   ICN(IEND) = JNEW
		   IBEG   = MIN0(IBEG,J)
		   ICN(J) = 0
		   LENI   = LENI + 1
  120       CONTINUE
C
		LENOFF(IOLD) = LENOFF(IOLD) - LENI
  130       LENR(INEW) = LENI
  140    CONTINUE
C
	   IP(I2) = -IP(I2)
  150 CONTINUE
C RESETS IP(N) TO POSITIVE VALUE.
	IP(N)  = -IP(N)
C IDISP(2) IS POSITION OF FIRST ELEMENT IN DIAGONAL BLOCKS.
	IDISP(2) = IEND
C
C THIS COMPRESS IS USED TO MOVE ALL OFF-DIAGONAL ELEMENTS TO THE
C     FRONT OF THE STORAGE.
	IF (IBEG.GT.LICN) GO TO 230
	JNPOS  = IBEG
	ILEND  = IDISP(1) - 1
	DO 160 J = IBEG,ILEND
	   IF (ICN(J).EQ.0) GO TO 160
	   ICN(JNPOS) = ICN(J)
	   A(JNPOS) = A(J)
	   JNPOS  = JNPOS + 1
  160 CONTINUE
C IDISP(1) IS FIRST POSITION AFTER LAST ELEMENT OF OFF-DIAGONAL BLOCKS.
	IDISP(1) = JNPOS
	GO TO 230
C
C
C ERROR RETURN
  170 IF (LP.NE.0) WRITE (LP,FMT=180) NUMNZ

  180 FORMAT (/,' ERROR RETURN FROM MC23A  BECAUSE',/,10X,
     +       ' MATRIX IS STRUCTURALLY SINGULAR, RANK = ',I6)

	IDISP(1) = -1
	GO TO 230

  190 IF (LP.NE.0) WRITE (LP,FMT=200) N

  200 FORMAT (/,' ERROR RETURN FROM MC23A  BECAUSE',/,10X,
     +       ' LICN NOT BIG ENOUGH INCREASE BY ',I6)

	IDISP(1) = -2
C
  230 RETURN

	END
	BLOCK DATA MC23CD
C     .. Common blocks ..
	COMMON /MC23BD/LP,NUMNZ,NUM,LARGE,ABORT
	INTEGER LARGE,LP,NUM,NUMNZ
	LOGICAL ABORT
C     ..
C     .. Data statements ..
	DATA  LP/6/,ABORT/.FALSE./
C     ..
	END
*######DATE 13 MAR 1989     COPYRIGHT UKAEA, HARWELL.
C######ALIAS MC24AD
	SUBROUTINE MC24AD(N,ICN,A,LICN,LENR,LENRL,W)
	INTEGER N , LICN
	DOUBLE PRECISION A(LICN),W(N),AMAXL,WROWL,AMAXU,ZERO
	INTEGER   ICN(LICN),LENR(N),LENRL(N)
	INTEGER  I , J , J0 , J1 , J2 , JJ
	INTRINSIC DABS , DMAX1
	DATA ZERO/0.0D0/
	AMAXL=ZERO
	DO 10 I=1,N
 10   W(I)=ZERO
	J0=1
	DO 100 I=1,N
	IF (LENR(I).EQ.0) GO TO 100
	J2=J0+LENR(I)-1
	IF (LENRL(I).EQ.0) GO TO 50
C CALCULATION OF 1-NORM OF L.
	J1=J0+LENRL(I)-1
	WROWL=ZERO
	DO 30 JJ=J0,J1
 30   WROWL=WROWL+DABS(A(JJ))
C AMAXL IS THE MAXIMUM NORM OF COLUMNS OF L SO FAR FOUND.
	AMAXL=DMAX1(AMAXL,WROWL)
	J0=J1+1
C CALCULATION OF NORMS OF COLUMNS OF U (MAX-NORMS).
 50   J0=J0+1
	IF (J0.GT.J2) GO TO 90
	DO 80 JJ=J0,J2
	J=ICN(JJ)
 80   W(J)=DMAX1(DABS(A(JJ)),W(J))
 90   J0=J2+1
 100  CONTINUE
C AMAXU IS SET TO MAXIMUM MAX-NORM OF COLUMNS OF U.
	AMAXU=ZERO
	DO 200 I=1,N
 200  AMAXU=DMAX1(AMAXU,W(I))
C GROFAC IS MAX U MAX-NORM TIMES MAX L 1-NORM.
	W(1)=AMAXL*AMAXU
	RETURN
	END

