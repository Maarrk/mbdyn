//
// time: Wed Apr 28 14:06:31 1993

//
// version: 1.0.0
//
// Begin MDF
// MODULE P3TimesM3
// CATEGORY Vectors and Matrices
// DESCRIPTION returns 3D vector (point) post-multiplied by 3x3 matrix (1x9 row vector)
// INPUT P3; value list or field; {[0,0,0]}; 3D point
// INPUT M3; value list or field; {[1,0,0,0,1,0,0,0,1]}; 3x3 matrix (1x9 row vector)
// OUTPUT P3timesM3; value or value list or field; 1x3 vector (point) post-multiplied by 3x3 matrix
// End MDF
//
//
// comment: Network name: P3TimesM3.net
// comment: Macro name: P3TimesM3
// comment: Category: Vectors and Matrices
// comment: Author: Chris Pelkie, Cornell Theory Center Visualization staff, chrisp@tc.cornell.edu
// comment: Date last modified: 04/19/93
// comment: Other required files: none
// comment: 
// comment: P3TimesM3 multiplies (transforms) a 3D point (or field) by the specified M3 transformation matrix. This routine uses normal coordinate representation (rather than homogeneous). Thus, you may rotate or scale, but you cannot translate via matrix multiplication using this routine. However, you can simply add the translate vector to the vector you wish to translate.
// comment: 
// comment: See also:
// comment: P2TimesProjM3 (Vectors and Matrices macro)
// comment: P3TimesProjM4 (Vectors and Matrices macro)
//
// workspace: width = 1000, height = 1000
// layout: snap = 0, width = 50, height = 50, align = C
//
macro P3TimesM3(
        P3 = {[0,0,0]},
        M3 = {[1,0,0,0,1,0,0,0,1]}) -> (
        P3timesM3)
{
    //
    // node Input[1]: x = 46, y = 70, inputs = 0, label = Input
    // parameter: position = 1, name = 'P3', value = '{[0,0,0]}', descriptive = 0, description = '3D point', required = 0
    //
    Input_1_out_1 = P3;
    //
    // node Input[2]: x = 156, y = 69, inputs = 0, label = Input
    // parameter: position = 2, name = 'M3', value = '{[1,0,0,0,1,0,0,0,1]}', descriptive = 0, description = '3x3 matrix (1x9 row vector)', required = 0
    //
    Input_2_out_1 = M3;
    //
    // node Compute[2]: x = 89, y = 181, inputs = 3, label = Compute
    // input[1]: type = 64, value = "[$0.0*$1.0 + $0.1*$1.3 + $0.2*$1.6,   $0.0*$1.1 + $0.1*$1.4 + $0.2*$1.7,   $0.0*$1.2 + $0.1*$1.5 + $0.2*$1.8]"
    // expression: value = [P.0*M.0 + P.1*M.3 + P.2*M.6,   P.0*M.1 + P.1*M.4 + P.2*M.7,   P.0*M.2 + P.1*M.5 + P.2*M.8]
    // name[2]: value = P
    // name[3]: value = M
    //
    Compute_2_out_1 =
        Compute(
            Compute_2_in_1,
            Input_1_out_1,
            Input_2_out_1
        ) [instance: 2];
    //
    // node Output[1]: x = 96, y = 283, inputs = 1, label = Output
    // parameter: position = 1, name = 'P3timesM3', value = ' ', descriptive = 0, description = '1x3 vector (point) post-multiplied by 3x3 matrix', required = 0
    //
    Output_1_in_1 = Compute_2_out_1;
    P3timesM3 = Output_1_in_1;
}

Compute_2_in_1 = "[$0.0*$1.0 + $0.1*$1.3 + $0.2*$1.6,   $0.0*$1.1 + $0.1*$1.4 + $0.2*$1.7,   $0.0*$1.2 + $0.1*$1.5 + $0.2*$1.8]";
Compute_2_in_2 = NULL;
Compute_2_in_3 = NULL;
Output_1_in_1 = NULL;
