//
// time: Fri Nov  1 09:46:15 2002
//
// version: 3.1.2 (format), 4.1.1 (DX Beta)
//
//
// Begin MDF
// MODULE M3TimesP3
// CATEGORY Vectors and Matrices
// DESCRIPTION returns 3D vector (point) pre-multiplied by 3x3 matrix (1x9 row vector)
// INPUT M3; value list or field or string or string list; {[1,0,0,0,1,0,0,0,1]}; 3x3 matrix (1x9 row vector)
// INPUT P3; value list or field or string or string list; {[0,0,0]}; 3D point
// OUTPUT P3timesM3; value or value list or field; 1x3 vector (point) post-multiplied by 3x3 matrix
// End MDF
//
// comment: Network name: M3TimesP3.net
// comment: Macro name: M3TimesP3
// comment: Category: Vectors and Matrices
// comment: Author: Marco Morandini, from Chris Pelkie's P3TimesM3
// comment: Date last modified: 31/10/2002
// comment: Other required files: none
// comment: 
// comment: M3TimesP3 multiplies (transforms) a 3D point (or field) by the specified M3 transformation matrix. This routine uses normal coordinate representation (rather than homogeneous). Thus, you may rotate or scale, but you cannot translate via matrix multiplication using this routine. However, you can simply add the translate vector to the vector you wish to translate.
// comment: 
// comment: See also:
// comment: P2TimesProjM3 (Vectors and Matrices macro)
// comment: P3TimesProjM4 (Vectors and Matrices macro)
// workspace: width = 220, height = 345
// layout: snap = 0, width = 50, height = 50, align = CC
//
macro M3TimesP3(
 M3 = {[1,0,0,0,1,0,0,0,1]}
,P3 = {[0,0,0]}
) -> (
 P3timesM3
) {
    // 
    // node Input[2]: x = 32, y = 57, inputs = 0, label = Input
    // parameter: position = 1, name = 'M3', value = '{[1,0,0,0,1,0,0,0,1]}', descriptive = 0, description = '3x3 matrix (1x9 row vector)', required = 0, visible = 1
    //
M3TimesP3_Input_2_out_1 = M3;
    // 
    // node Input[1]: x = 178, y = 48, inputs = 0, label = Input
    // parameter: position = 2, name = 'P3', value = '{[0,0,0]}', descriptive = 0, description = '3D point', required = 0, visible = 1
    //
M3TimesP3_Input_1_out_1 = P3;
    // 
    // node Compute[2]: x = 90, y = 181, inputs = 3, label = Compute
    // input[1]: defaulting = 0, visible = 0, type = 32, value = "[$1.0*$0.0 + $1.1*$0.1 + $1.2*$0.2,   $1.0*$0.3+$1.1*$0.4+$1.2*$0.5,   $1.0*$0.6+$1.1*$0.7+$1.2*$0.8]"
    // expression: value = [P.0*M.0 + P.1*M.1 + P.2*M.2,   P.0*M.3+P.1*M.4+P.2*M.5,   P.0*M.6+P.1*M.7+P.2*M.8]
    // name[2]: value = M
    // name[3]: value = P
    //
M3TimesP3_Compute_2_out_1 = 
    Compute(
    "[$1.0*$0.0 + $1.1*$0.1 + $1.2*$0.2,   $1.0*$0.3+$1.1*$0.4+$1.2*$0.5,   $1.0*$0.6+$1.1*$0.7+$1.2*$0.8]",
    M3TimesP3_Input_2_out_1,
    M3TimesP3_Input_1_out_1
    ) [instance: 2, cache: 1];
    // 
    // node Output[1]: x = 96, y = 283, inputs = 1, label = Output
    // parameter: position = 1, name = 'P3timesM3', value = ' ', descriptive = 0, description = '1x3 vector (point) post-multiplied by 3x3 matrix', required = 0, visible = 1
    //
P3timesM3 = M3TimesP3_Compute_2_out_1;
// network: end of macro body
}
M3TimesP3_Input_2_out_1 = NULL;
M3TimesP3_Input_1_out_1 = NULL;
M3TimesP3_Compute_2_out_1 = NULL;
