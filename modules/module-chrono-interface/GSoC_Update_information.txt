Objective:

Minimum: interface for single node in MBDyn & in C::E
MBDyn-side code for MBDyn module
C::E-side code for MBDyn-C::E interface
C::E code for example (e.f. a mass, or a mass and a spring, ...)
Desired: interface for arbitrary number of nodes


First step: the minimum objective;
1. A define element: like the external structural force element, yet without communication tools, such as the sockets or the files; (2-3 weeks)
2. MBDyn-C::E interfaces; (3 weeks)
3. a simple C::E system; (1-2 day)


Update 2-Week 2;

create the following Files:

ce_models.cc. //the C::E model;
mass1.mbd. //script for mbdyn;
mbdyn_ce.cc. //some C::E-interface functions;
module-chrono-interface.cc. //mbdyn module;

libCE_models.so. //generated by files ce_models.cc, mbdyn_ce.cc, and mbdyn_ce.h.


In this week, the library "libCE_models.so" including an easy C::E model is generated, and connected to the MBDyn module::module-chrono-interface. And now, the C::E model and the MBDyn model couled be loaded and solved in the meantime. In next week, attention will be paid to the data exchange between two solvers.



The following functions are designed:
// using to create the C::E model, defined by the users;
extern "C" void
MBDyn_CE_CEModel_create(ChSystemParallelNSC *pMBDyn_CE_CEModel);

// create the C::E model
pMBDyn_CE_CEModel_t MBDyn_CE_CEModel_init();

// destroy the C::E model
extern void
MBDyn_CE_CEModel_destroy(pMBDyn_CE_CEModel_t);

// update C::E Model, now just do step integration and output the C::E time;
extern void
MBDyn_CE_CEModel_update(pMBDyn_CE_CEModel_t, double time_step);
