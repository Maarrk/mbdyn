Objective:

Minimum: interface for single node in MBDyn & in C::E
MBDyn-side code for MBDyn module
C::E-side code for MBDyn-C::E interface
C::E code for example (e.f. a mass, or a mass and a spring, ...)
Desired: interface for arbitrary number of nodes


First step: the minimum objective;
1. A define element: like the external structural force element, yet without communication tools, such as the sockets or the files; (2-3 weeks)
2. MBDyn-C::E interfaces; (3 weeks)
3. a simple C::E system; (1-2 day)


Update 2-Week 2;

Files:

ce_models.cc: the C::E model;
mass1.mbd: script for mbdyn;
mbdyn_ce.cc: some C::E-interface functions;
module-chrono-interface.cc: mbdyn module;

libCE_models.so: generated by files ce_models.cc, mbdyn_ce.cc, and mbdyn_ce.h.


In this week, a easy C::E model is created in library "libCE_models.so", and connected to module-chrono-interface.
The include file is "mbdyn_ce.h". But the data is not exchanged.

The following functions are designed:
// using to create the C::E model, defined by the users;
extern "C" void
MBDyn_CE_CEModel_create(ChSystemParallelNSC *pMBDyn_CE_CEModel);

// create the C::E model
pMBDyn_CE_CEModel_t MBDyn_CE_CEModel_init();

// destroy the C::E model
extern void
MBDyn_CE_CEModel_destroy(pMBDyn_CE_CEModel_t);

// update C::E Model, now just do step integration and output the C::E time;
extern void
MBDyn_CE_CEModel_update(pMBDyn_CE_CEModel_t, double time_step);
